// Code generated by SQLBoiler 4.17.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/site-name/decimal"
	"github.com/sitename/sitename/modules/model_types"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// OrderLine is an object representing the database table.
type OrderLine struct {
	ID                                string                  `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt                         int64                   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	OrderID                           string                  `boil:"order_id" json:"order_id" toml:"order_id" yaml:"order_id"`
	VariantID                         model_types.NullString  `boil:"variant_id" json:"variant_id,omitempty" toml:"variant_id" yaml:"variant_id,omitempty"`
	ProductName                       string                  `boil:"product_name" json:"product_name" toml:"product_name" yaml:"product_name"`
	VariantName                       string                  `boil:"variant_name" json:"variant_name" toml:"variant_name" yaml:"variant_name"`
	TranslatedProductName             string                  `boil:"translated_product_name" json:"translated_product_name" toml:"translated_product_name" yaml:"translated_product_name"`
	TranslatedVariantName             string                  `boil:"translated_variant_name" json:"translated_variant_name" toml:"translated_variant_name" yaml:"translated_variant_name"`
	ProductSku                        model_types.NullString  `boil:"product_sku" json:"product_sku,omitempty" toml:"product_sku" yaml:"product_sku,omitempty"`
	ProductVariantID                  model_types.NullString  `boil:"product_variant_id" json:"product_variant_id,omitempty" toml:"product_variant_id" yaml:"product_variant_id,omitempty"`
	IsShippingRequired                bool                    `boil:"is_shipping_required" json:"is_shipping_required" toml:"is_shipping_required" yaml:"is_shipping_required"`
	IsGiftcard                        bool                    `boil:"is_giftcard" json:"is_giftcard" toml:"is_giftcard" yaml:"is_giftcard"`
	IsGift                            bool                    `boil:"is_gift" json:"is_gift" toml:"is_gift" yaml:"is_gift"`
	Quantity                          int                     `boil:"quantity" json:"quantity" toml:"quantity" yaml:"quantity"`
	QuantityFulfilled                 int                     `boil:"quantity_fulfilled" json:"quantity_fulfilled" toml:"quantity_fulfilled" yaml:"quantity_fulfilled"`
	Currency                          Currency                `boil:"currency" json:"currency" toml:"currency" yaml:"currency"`
	UnitDiscountAmount                decimal.Decimal         `boil:"unit_discount_amount" json:"unit_discount_amount" toml:"unit_discount_amount" yaml:"unit_discount_amount"`
	UnitDiscountType                  DiscountValueType       `boil:"unit_discount_type" json:"unit_discount_type" toml:"unit_discount_type" yaml:"unit_discount_type"`
	UnitDiscountReason                model_types.NullString  `boil:"unit_discount_reason" json:"unit_discount_reason,omitempty" toml:"unit_discount_reason" yaml:"unit_discount_reason,omitempty"`
	UnitPriceNetAmount                decimal.Decimal         `boil:"unit_price_net_amount" json:"unit_price_net_amount" toml:"unit_price_net_amount" yaml:"unit_price_net_amount"`
	UnitDiscountValue                 decimal.Decimal         `boil:"unit_discount_value" json:"unit_discount_value" toml:"unit_discount_value" yaml:"unit_discount_value"`
	UnitPriceGrossAmount              decimal.Decimal         `boil:"unit_price_gross_amount" json:"unit_price_gross_amount" toml:"unit_price_gross_amount" yaml:"unit_price_gross_amount"`
	TotalPriceNetAmount               model_types.NullDecimal `boil:"total_price_net_amount" json:"total_price_net_amount,omitempty" toml:"total_price_net_amount" yaml:"total_price_net_amount,omitempty"`
	TotalPriceGrossAmount             model_types.NullDecimal `boil:"total_price_gross_amount" json:"total_price_gross_amount,omitempty" toml:"total_price_gross_amount" yaml:"total_price_gross_amount,omitempty"`
	UndiscountedUnitPriceGrossAmount  decimal.Decimal         `boil:"undiscounted_unit_price_gross_amount" json:"undiscounted_unit_price_gross_amount" toml:"undiscounted_unit_price_gross_amount" yaml:"undiscounted_unit_price_gross_amount"`
	UndiscountedUnitPriceNetAmount    decimal.Decimal         `boil:"undiscounted_unit_price_net_amount" json:"undiscounted_unit_price_net_amount" toml:"undiscounted_unit_price_net_amount" yaml:"undiscounted_unit_price_net_amount"`
	UndiscountedTotalPriceGrossAmount decimal.Decimal         `boil:"undiscounted_total_price_gross_amount" json:"undiscounted_total_price_gross_amount" toml:"undiscounted_total_price_gross_amount" yaml:"undiscounted_total_price_gross_amount"`
	UndiscountedTotalPriceNetAmount   decimal.Decimal         `boil:"undiscounted_total_price_net_amount" json:"undiscounted_total_price_net_amount" toml:"undiscounted_total_price_net_amount" yaml:"undiscounted_total_price_net_amount"`
	BaseUnitPriceAmount               decimal.Decimal         `boil:"base_unit_price_amount" json:"base_unit_price_amount" toml:"base_unit_price_amount" yaml:"base_unit_price_amount"`
	UndiscountedBaseUnitPriceAmount   decimal.Decimal         `boil:"undiscounted_base_unit_price_amount" json:"undiscounted_base_unit_price_amount" toml:"undiscounted_base_unit_price_amount" yaml:"undiscounted_base_unit_price_amount"`
	TaxRate                           model_types.NullDecimal `boil:"tax_rate" json:"tax_rate,omitempty" toml:"tax_rate" yaml:"tax_rate,omitempty"`
	TaxClassID                        model_types.NullString  `boil:"tax_class_id" json:"tax_class_id,omitempty" toml:"tax_class_id" yaml:"tax_class_id,omitempty"`
	TaxClassName                      model_types.NullString  `boil:"tax_class_name" json:"tax_class_name,omitempty" toml:"tax_class_name" yaml:"tax_class_name,omitempty"`
	TaxClassPrivateMetadata           model_types.JSONString  `boil:"tax_class_private_metadata" json:"tax_class_private_metadata,omitempty" toml:"tax_class_private_metadata" yaml:"tax_class_private_metadata,omitempty"`
	TaxClassMetadata                  model_types.JSONString  `boil:"tax_class_metadata" json:"tax_class_metadata,omitempty" toml:"tax_class_metadata" yaml:"tax_class_metadata,omitempty"`
	IsPriceOverridden                 model_types.NullBool    `boil:"is_price_overridden" json:"is_price_overridden,omitempty" toml:"is_price_overridden" yaml:"is_price_overridden,omitempty"`
	VoucherCode                       model_types.NullString  `boil:"voucher_code" json:"voucher_code,omitempty" toml:"voucher_code" yaml:"voucher_code,omitempty"`
	SaleID                            model_types.NullString  `boil:"sale_id" json:"sale_id,omitempty" toml:"sale_id" yaml:"sale_id,omitempty"`

	R *orderLineR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L orderLineL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var OrderLineColumns = struct {
	ID                                string
	CreatedAt                         string
	OrderID                           string
	VariantID                         string
	ProductName                       string
	VariantName                       string
	TranslatedProductName             string
	TranslatedVariantName             string
	ProductSku                        string
	ProductVariantID                  string
	IsShippingRequired                string
	IsGiftcard                        string
	IsGift                            string
	Quantity                          string
	QuantityFulfilled                 string
	Currency                          string
	UnitDiscountAmount                string
	UnitDiscountType                  string
	UnitDiscountReason                string
	UnitPriceNetAmount                string
	UnitDiscountValue                 string
	UnitPriceGrossAmount              string
	TotalPriceNetAmount               string
	TotalPriceGrossAmount             string
	UndiscountedUnitPriceGrossAmount  string
	UndiscountedUnitPriceNetAmount    string
	UndiscountedTotalPriceGrossAmount string
	UndiscountedTotalPriceNetAmount   string
	BaseUnitPriceAmount               string
	UndiscountedBaseUnitPriceAmount   string
	TaxRate                           string
	TaxClassID                        string
	TaxClassName                      string
	TaxClassPrivateMetadata           string
	TaxClassMetadata                  string
	IsPriceOverridden                 string
	VoucherCode                       string
	SaleID                            string
}{
	ID:                                "id",
	CreatedAt:                         "created_at",
	OrderID:                           "order_id",
	VariantID:                         "variant_id",
	ProductName:                       "product_name",
	VariantName:                       "variant_name",
	TranslatedProductName:             "translated_product_name",
	TranslatedVariantName:             "translated_variant_name",
	ProductSku:                        "product_sku",
	ProductVariantID:                  "product_variant_id",
	IsShippingRequired:                "is_shipping_required",
	IsGiftcard:                        "is_giftcard",
	IsGift:                            "is_gift",
	Quantity:                          "quantity",
	QuantityFulfilled:                 "quantity_fulfilled",
	Currency:                          "currency",
	UnitDiscountAmount:                "unit_discount_amount",
	UnitDiscountType:                  "unit_discount_type",
	UnitDiscountReason:                "unit_discount_reason",
	UnitPriceNetAmount:                "unit_price_net_amount",
	UnitDiscountValue:                 "unit_discount_value",
	UnitPriceGrossAmount:              "unit_price_gross_amount",
	TotalPriceNetAmount:               "total_price_net_amount",
	TotalPriceGrossAmount:             "total_price_gross_amount",
	UndiscountedUnitPriceGrossAmount:  "undiscounted_unit_price_gross_amount",
	UndiscountedUnitPriceNetAmount:    "undiscounted_unit_price_net_amount",
	UndiscountedTotalPriceGrossAmount: "undiscounted_total_price_gross_amount",
	UndiscountedTotalPriceNetAmount:   "undiscounted_total_price_net_amount",
	BaseUnitPriceAmount:               "base_unit_price_amount",
	UndiscountedBaseUnitPriceAmount:   "undiscounted_base_unit_price_amount",
	TaxRate:                           "tax_rate",
	TaxClassID:                        "tax_class_id",
	TaxClassName:                      "tax_class_name",
	TaxClassPrivateMetadata:           "tax_class_private_metadata",
	TaxClassMetadata:                  "tax_class_metadata",
	IsPriceOverridden:                 "is_price_overridden",
	VoucherCode:                       "voucher_code",
	SaleID:                            "sale_id",
}

var OrderLineTableColumns = struct {
	ID                                string
	CreatedAt                         string
	OrderID                           string
	VariantID                         string
	ProductName                       string
	VariantName                       string
	TranslatedProductName             string
	TranslatedVariantName             string
	ProductSku                        string
	ProductVariantID                  string
	IsShippingRequired                string
	IsGiftcard                        string
	IsGift                            string
	Quantity                          string
	QuantityFulfilled                 string
	Currency                          string
	UnitDiscountAmount                string
	UnitDiscountType                  string
	UnitDiscountReason                string
	UnitPriceNetAmount                string
	UnitDiscountValue                 string
	UnitPriceGrossAmount              string
	TotalPriceNetAmount               string
	TotalPriceGrossAmount             string
	UndiscountedUnitPriceGrossAmount  string
	UndiscountedUnitPriceNetAmount    string
	UndiscountedTotalPriceGrossAmount string
	UndiscountedTotalPriceNetAmount   string
	BaseUnitPriceAmount               string
	UndiscountedBaseUnitPriceAmount   string
	TaxRate                           string
	TaxClassID                        string
	TaxClassName                      string
	TaxClassPrivateMetadata           string
	TaxClassMetadata                  string
	IsPriceOverridden                 string
	VoucherCode                       string
	SaleID                            string
}{
	ID:                                "order_lines.id",
	CreatedAt:                         "order_lines.created_at",
	OrderID:                           "order_lines.order_id",
	VariantID:                         "order_lines.variant_id",
	ProductName:                       "order_lines.product_name",
	VariantName:                       "order_lines.variant_name",
	TranslatedProductName:             "order_lines.translated_product_name",
	TranslatedVariantName:             "order_lines.translated_variant_name",
	ProductSku:                        "order_lines.product_sku",
	ProductVariantID:                  "order_lines.product_variant_id",
	IsShippingRequired:                "order_lines.is_shipping_required",
	IsGiftcard:                        "order_lines.is_giftcard",
	IsGift:                            "order_lines.is_gift",
	Quantity:                          "order_lines.quantity",
	QuantityFulfilled:                 "order_lines.quantity_fulfilled",
	Currency:                          "order_lines.currency",
	UnitDiscountAmount:                "order_lines.unit_discount_amount",
	UnitDiscountType:                  "order_lines.unit_discount_type",
	UnitDiscountReason:                "order_lines.unit_discount_reason",
	UnitPriceNetAmount:                "order_lines.unit_price_net_amount",
	UnitDiscountValue:                 "order_lines.unit_discount_value",
	UnitPriceGrossAmount:              "order_lines.unit_price_gross_amount",
	TotalPriceNetAmount:               "order_lines.total_price_net_amount",
	TotalPriceGrossAmount:             "order_lines.total_price_gross_amount",
	UndiscountedUnitPriceGrossAmount:  "order_lines.undiscounted_unit_price_gross_amount",
	UndiscountedUnitPriceNetAmount:    "order_lines.undiscounted_unit_price_net_amount",
	UndiscountedTotalPriceGrossAmount: "order_lines.undiscounted_total_price_gross_amount",
	UndiscountedTotalPriceNetAmount:   "order_lines.undiscounted_total_price_net_amount",
	BaseUnitPriceAmount:               "order_lines.base_unit_price_amount",
	UndiscountedBaseUnitPriceAmount:   "order_lines.undiscounted_base_unit_price_amount",
	TaxRate:                           "order_lines.tax_rate",
	TaxClassID:                        "order_lines.tax_class_id",
	TaxClassName:                      "order_lines.tax_class_name",
	TaxClassPrivateMetadata:           "order_lines.tax_class_private_metadata",
	TaxClassMetadata:                  "order_lines.tax_class_metadata",
	IsPriceOverridden:                 "order_lines.is_price_overridden",
	VoucherCode:                       "order_lines.voucher_code",
	SaleID:                            "order_lines.sale_id",
}

// Generated where

var OrderLineWhere = struct {
	ID                                whereHelperstring
	CreatedAt                         whereHelperint64
	OrderID                           whereHelperstring
	VariantID                         whereHelpermodel_types_NullString
	ProductName                       whereHelperstring
	VariantName                       whereHelperstring
	TranslatedProductName             whereHelperstring
	TranslatedVariantName             whereHelperstring
	ProductSku                        whereHelpermodel_types_NullString
	ProductVariantID                  whereHelpermodel_types_NullString
	IsShippingRequired                whereHelperbool
	IsGiftcard                        whereHelperbool
	IsGift                            whereHelperbool
	Quantity                          whereHelperint
	QuantityFulfilled                 whereHelperint
	Currency                          whereHelperCurrency
	UnitDiscountAmount                whereHelperdecimal_Decimal
	UnitDiscountType                  whereHelperDiscountValueType
	UnitDiscountReason                whereHelpermodel_types_NullString
	UnitPriceNetAmount                whereHelperdecimal_Decimal
	UnitDiscountValue                 whereHelperdecimal_Decimal
	UnitPriceGrossAmount              whereHelperdecimal_Decimal
	TotalPriceNetAmount               whereHelpermodel_types_NullDecimal
	TotalPriceGrossAmount             whereHelpermodel_types_NullDecimal
	UndiscountedUnitPriceGrossAmount  whereHelperdecimal_Decimal
	UndiscountedUnitPriceNetAmount    whereHelperdecimal_Decimal
	UndiscountedTotalPriceGrossAmount whereHelperdecimal_Decimal
	UndiscountedTotalPriceNetAmount   whereHelperdecimal_Decimal
	BaseUnitPriceAmount               whereHelperdecimal_Decimal
	UndiscountedBaseUnitPriceAmount   whereHelperdecimal_Decimal
	TaxRate                           whereHelpermodel_types_NullDecimal
	TaxClassID                        whereHelpermodel_types_NullString
	TaxClassName                      whereHelpermodel_types_NullString
	TaxClassPrivateMetadata           whereHelpermodel_types_JSONString
	TaxClassMetadata                  whereHelpermodel_types_JSONString
	IsPriceOverridden                 whereHelpermodel_types_NullBool
	VoucherCode                       whereHelpermodel_types_NullString
	SaleID                            whereHelpermodel_types_NullString
}{
	ID:                                whereHelperstring{field: "\"order_lines\".\"id\""},
	CreatedAt:                         whereHelperint64{field: "\"order_lines\".\"created_at\""},
	OrderID:                           whereHelperstring{field: "\"order_lines\".\"order_id\""},
	VariantID:                         whereHelpermodel_types_NullString{field: "\"order_lines\".\"variant_id\""},
	ProductName:                       whereHelperstring{field: "\"order_lines\".\"product_name\""},
	VariantName:                       whereHelperstring{field: "\"order_lines\".\"variant_name\""},
	TranslatedProductName:             whereHelperstring{field: "\"order_lines\".\"translated_product_name\""},
	TranslatedVariantName:             whereHelperstring{field: "\"order_lines\".\"translated_variant_name\""},
	ProductSku:                        whereHelpermodel_types_NullString{field: "\"order_lines\".\"product_sku\""},
	ProductVariantID:                  whereHelpermodel_types_NullString{field: "\"order_lines\".\"product_variant_id\""},
	IsShippingRequired:                whereHelperbool{field: "\"order_lines\".\"is_shipping_required\""},
	IsGiftcard:                        whereHelperbool{field: "\"order_lines\".\"is_giftcard\""},
	IsGift:                            whereHelperbool{field: "\"order_lines\".\"is_gift\""},
	Quantity:                          whereHelperint{field: "\"order_lines\".\"quantity\""},
	QuantityFulfilled:                 whereHelperint{field: "\"order_lines\".\"quantity_fulfilled\""},
	Currency:                          whereHelperCurrency{field: "\"order_lines\".\"currency\""},
	UnitDiscountAmount:                whereHelperdecimal_Decimal{field: "\"order_lines\".\"unit_discount_amount\""},
	UnitDiscountType:                  whereHelperDiscountValueType{field: "\"order_lines\".\"unit_discount_type\""},
	UnitDiscountReason:                whereHelpermodel_types_NullString{field: "\"order_lines\".\"unit_discount_reason\""},
	UnitPriceNetAmount:                whereHelperdecimal_Decimal{field: "\"order_lines\".\"unit_price_net_amount\""},
	UnitDiscountValue:                 whereHelperdecimal_Decimal{field: "\"order_lines\".\"unit_discount_value\""},
	UnitPriceGrossAmount:              whereHelperdecimal_Decimal{field: "\"order_lines\".\"unit_price_gross_amount\""},
	TotalPriceNetAmount:               whereHelpermodel_types_NullDecimal{field: "\"order_lines\".\"total_price_net_amount\""},
	TotalPriceGrossAmount:             whereHelpermodel_types_NullDecimal{field: "\"order_lines\".\"total_price_gross_amount\""},
	UndiscountedUnitPriceGrossAmount:  whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_unit_price_gross_amount\""},
	UndiscountedUnitPriceNetAmount:    whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_unit_price_net_amount\""},
	UndiscountedTotalPriceGrossAmount: whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_total_price_gross_amount\""},
	UndiscountedTotalPriceNetAmount:   whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_total_price_net_amount\""},
	BaseUnitPriceAmount:               whereHelperdecimal_Decimal{field: "\"order_lines\".\"base_unit_price_amount\""},
	UndiscountedBaseUnitPriceAmount:   whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_base_unit_price_amount\""},
	TaxRate:                           whereHelpermodel_types_NullDecimal{field: "\"order_lines\".\"tax_rate\""},
	TaxClassID:                        whereHelpermodel_types_NullString{field: "\"order_lines\".\"tax_class_id\""},
	TaxClassName:                      whereHelpermodel_types_NullString{field: "\"order_lines\".\"tax_class_name\""},
	TaxClassPrivateMetadata:           whereHelpermodel_types_JSONString{field: "\"order_lines\".\"tax_class_private_metadata\""},
	TaxClassMetadata:                  whereHelpermodel_types_JSONString{field: "\"order_lines\".\"tax_class_metadata\""},
	IsPriceOverridden:                 whereHelpermodel_types_NullBool{field: "\"order_lines\".\"is_price_overridden\""},
	VoucherCode:                       whereHelpermodel_types_NullString{field: "\"order_lines\".\"voucher_code\""},
	SaleID:                            whereHelpermodel_types_NullString{field: "\"order_lines\".\"sale_id\""},
}

// OrderLineRels is where relationship names are stored.
var OrderLineRels = struct {
	Order                   string
	Variant                 string
	TaxClass                string
	LineDigitalContentURL   string
	Allocations             string
	FulfillmentLines        string
	OrderGrantedRefundLines string
	OrderLineDiscounts      string
}{
	Order:                   "Order",
	Variant:                 "Variant",
	TaxClass:                "TaxClass",
	LineDigitalContentURL:   "LineDigitalContentURL",
	Allocations:             "Allocations",
	FulfillmentLines:        "FulfillmentLines",
	OrderGrantedRefundLines: "OrderGrantedRefundLines",
	OrderLineDiscounts:      "OrderLineDiscounts",
}

// orderLineR is where relationships are stored.
type orderLineR struct {
	Order                   *Order                      `boil:"Order" json:"Order" toml:"Order" yaml:"Order"`
	Variant                 *ProductVariant             `boil:"Variant" json:"Variant" toml:"Variant" yaml:"Variant"`
	TaxClass                *TaxClass                   `boil:"TaxClass" json:"TaxClass" toml:"TaxClass" yaml:"TaxClass"`
	LineDigitalContentURL   *DigitalContentURL          `boil:"LineDigitalContentURL" json:"LineDigitalContentURL" toml:"LineDigitalContentURL" yaml:"LineDigitalContentURL"`
	Allocations             AllocationSlice             `boil:"Allocations" json:"Allocations" toml:"Allocations" yaml:"Allocations"`
	FulfillmentLines        FulfillmentLineSlice        `boil:"FulfillmentLines" json:"FulfillmentLines" toml:"FulfillmentLines" yaml:"FulfillmentLines"`
	OrderGrantedRefundLines OrderGrantedRefundLineSlice `boil:"OrderGrantedRefundLines" json:"OrderGrantedRefundLines" toml:"OrderGrantedRefundLines" yaml:"OrderGrantedRefundLines"`
	OrderLineDiscounts      OrderLineDiscountSlice      `boil:"OrderLineDiscounts" json:"OrderLineDiscounts" toml:"OrderLineDiscounts" yaml:"OrderLineDiscounts"`
}

// NewStruct creates a new relationship struct
func (*orderLineR) NewStruct() *orderLineR {
	return &orderLineR{}
}

func (r *orderLineR) GetOrder() *Order {
	if r == nil {
		return nil
	}
	return r.Order
}

func (r *orderLineR) GetVariant() *ProductVariant {
	if r == nil {
		return nil
	}
	return r.Variant
}

func (r *orderLineR) GetTaxClass() *TaxClass {
	if r == nil {
		return nil
	}
	return r.TaxClass
}

func (r *orderLineR) GetLineDigitalContentURL() *DigitalContentURL {
	if r == nil {
		return nil
	}
	return r.LineDigitalContentURL
}

func (r *orderLineR) GetAllocations() AllocationSlice {
	if r == nil {
		return nil
	}
	return r.Allocations
}

func (r *orderLineR) GetFulfillmentLines() FulfillmentLineSlice {
	if r == nil {
		return nil
	}
	return r.FulfillmentLines
}

func (r *orderLineR) GetOrderGrantedRefundLines() OrderGrantedRefundLineSlice {
	if r == nil {
		return nil
	}
	return r.OrderGrantedRefundLines
}

func (r *orderLineR) GetOrderLineDiscounts() OrderLineDiscountSlice {
	if r == nil {
		return nil
	}
	return r.OrderLineDiscounts
}

// orderLineL is where Load methods for each relationship are stored.
type orderLineL struct{}

var (
	orderLineAllColumns            = []string{"id", "created_at", "order_id", "variant_id", "product_name", "variant_name", "translated_product_name", "translated_variant_name", "product_sku", "product_variant_id", "is_shipping_required", "is_giftcard", "is_gift", "quantity", "quantity_fulfilled", "currency", "unit_discount_amount", "unit_discount_type", "unit_discount_reason", "unit_price_net_amount", "unit_discount_value", "unit_price_gross_amount", "total_price_net_amount", "total_price_gross_amount", "undiscounted_unit_price_gross_amount", "undiscounted_unit_price_net_amount", "undiscounted_total_price_gross_amount", "undiscounted_total_price_net_amount", "base_unit_price_amount", "undiscounted_base_unit_price_amount", "tax_rate", "tax_class_id", "tax_class_name", "tax_class_private_metadata", "tax_class_metadata", "is_price_overridden", "voucher_code", "sale_id"}
	orderLineColumnsWithoutDefault = []string{"id", "created_at", "order_id", "product_name", "variant_name", "translated_product_name", "translated_variant_name", "is_shipping_required", "is_giftcard", "quantity", "quantity_fulfilled", "currency", "unit_discount_type"}
	orderLineColumnsWithDefault    = []string{"variant_id", "product_sku", "product_variant_id", "is_gift", "unit_discount_amount", "unit_discount_reason", "unit_price_net_amount", "unit_discount_value", "unit_price_gross_amount", "total_price_net_amount", "total_price_gross_amount", "undiscounted_unit_price_gross_amount", "undiscounted_unit_price_net_amount", "undiscounted_total_price_gross_amount", "undiscounted_total_price_net_amount", "base_unit_price_amount", "undiscounted_base_unit_price_amount", "tax_rate", "tax_class_id", "tax_class_name", "tax_class_private_metadata", "tax_class_metadata", "is_price_overridden", "voucher_code", "sale_id"}
	orderLinePrimaryKeyColumns     = []string{"id"}
	orderLineGeneratedColumns      = []string{}
)

type (
	// OrderLineSlice is an alias for a slice of pointers to OrderLine.
	// This should almost always be used instead of []OrderLine.
	OrderLineSlice []*OrderLine

	orderLineQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	orderLineType                 = reflect.TypeOf(&OrderLine{})
	orderLineMapping              = queries.MakeStructMapping(orderLineType)
	orderLinePrimaryKeyMapping, _ = queries.BindMapping(orderLineType, orderLineMapping, orderLinePrimaryKeyColumns)
	orderLineInsertCacheMut       sync.RWMutex
	orderLineInsertCache          = make(map[string]insertCache)
	orderLineUpdateCacheMut       sync.RWMutex
	orderLineUpdateCache          = make(map[string]updateCache)
	orderLineUpsertCacheMut       sync.RWMutex
	orderLineUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single orderLine record from the query.
func (q orderLineQuery) One(exec boil.Executor) (*OrderLine, error) {
	o := &OrderLine{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for order_lines")
	}

	return o, nil
}

// All returns all OrderLine records from the query.
func (q orderLineQuery) All(exec boil.Executor) (OrderLineSlice, error) {
	var o []*OrderLine

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to OrderLine slice")
	}

	return o, nil
}

// Count returns the count of all OrderLine records in the query.
func (q orderLineQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count order_lines rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q orderLineQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if order_lines exists")
	}

	return count > 0, nil
}

// Order pointed to by the foreign key.
func (o *OrderLine) Order(mods ...qm.QueryMod) orderQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OrderID),
	}

	queryMods = append(queryMods, mods...)

	return Orders(queryMods...)
}

// Variant pointed to by the foreign key.
func (o *OrderLine) Variant(mods ...qm.QueryMod) productVariantQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.VariantID),
	}

	queryMods = append(queryMods, mods...)

	return ProductVariants(queryMods...)
}

// TaxClass pointed to by the foreign key.
func (o *OrderLine) TaxClass(mods ...qm.QueryMod) taxClassQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TaxClassID),
	}

	queryMods = append(queryMods, mods...)

	return TaxClasses(queryMods...)
}

// LineDigitalContentURL pointed to by the foreign key.
func (o *OrderLine) LineDigitalContentURL(mods ...qm.QueryMod) digitalContentURLQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"line_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return DigitalContentUrls(queryMods...)
}

// Allocations retrieves all the allocation's Allocations with an executor.
func (o *OrderLine) Allocations(mods ...qm.QueryMod) allocationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"allocations\".\"order_line_id\"=?", o.ID),
	)

	return Allocations(queryMods...)
}

// FulfillmentLines retrieves all the fulfillment_line's FulfillmentLines with an executor.
func (o *OrderLine) FulfillmentLines(mods ...qm.QueryMod) fulfillmentLineQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"fulfillment_lines\".\"order_line_id\"=?", o.ID),
	)

	return FulfillmentLines(queryMods...)
}

// OrderGrantedRefundLines retrieves all the order_granted_refund_line's OrderGrantedRefundLines with an executor.
func (o *OrderLine) OrderGrantedRefundLines(mods ...qm.QueryMod) orderGrantedRefundLineQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"order_granted_refund_lines\".\"order_line_id\"=?", o.ID),
	)

	return OrderGrantedRefundLines(queryMods...)
}

// OrderLineDiscounts retrieves all the order_line_discount's OrderLineDiscounts with an executor.
func (o *OrderLine) OrderLineDiscounts(mods ...qm.QueryMod) orderLineDiscountQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"order_line_discounts\".\"order_line_id\"=?", o.ID),
	)

	return OrderLineDiscounts(queryMods...)
}

// LoadOrder allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orderLineL) LoadOrder(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args[object.OrderID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			args[obj.OrderID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`orders`),
		qm.WhereIn(`orders.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Order")
	}

	var resultSlice []*Order
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Order")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for orders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orders")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Order = foreign
		if foreign.R == nil {
			foreign.R = &orderR{}
		}
		foreign.R.OrderLines = append(foreign.R.OrderLines, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.OrderID == foreign.ID {
				local.R.Order = foreign
				if foreign.R == nil {
					foreign.R = &orderR{}
				}
				foreign.R.OrderLines = append(foreign.R.OrderLines, local)
				break
			}
		}
	}

	return nil
}

// LoadVariant allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orderLineL) LoadVariant(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		if !queries.IsNil(object.VariantID) {
			args[object.VariantID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			if !queries.IsNil(obj.VariantID) {
				args[obj.VariantID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`product_variants`),
		qm.WhereIn(`product_variants.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ProductVariant")
	}

	var resultSlice []*ProductVariant
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ProductVariant")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for product_variants")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_variants")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Variant = foreign
		if foreign.R == nil {
			foreign.R = &productVariantR{}
		}
		foreign.R.VariantOrderLines = append(foreign.R.VariantOrderLines, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.VariantID, foreign.ID) {
				local.R.Variant = foreign
				if foreign.R == nil {
					foreign.R = &productVariantR{}
				}
				foreign.R.VariantOrderLines = append(foreign.R.VariantOrderLines, local)
				break
			}
		}
	}

	return nil
}

// LoadTaxClass allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orderLineL) LoadTaxClass(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		if !queries.IsNil(object.TaxClassID) {
			args[object.TaxClassID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			if !queries.IsNil(obj.TaxClassID) {
				args[obj.TaxClassID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`tax_classes`),
		qm.WhereIn(`tax_classes.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TaxClass")
	}

	var resultSlice []*TaxClass
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TaxClass")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for tax_classes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tax_classes")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.TaxClass = foreign
		if foreign.R == nil {
			foreign.R = &taxClassR{}
		}
		foreign.R.OrderLines = append(foreign.R.OrderLines, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TaxClassID, foreign.ID) {
				local.R.TaxClass = foreign
				if foreign.R == nil {
					foreign.R = &taxClassR{}
				}
				foreign.R.OrderLines = append(foreign.R.OrderLines, local)
				break
			}
		}
	}

	return nil
}

// LoadLineDigitalContentURL allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (orderLineL) LoadLineDigitalContentURL(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`digital_content_urls`),
		qm.WhereIn(`digital_content_urls.line_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DigitalContentURL")
	}

	var resultSlice []*DigitalContentURL
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DigitalContentURL")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for digital_content_urls")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for digital_content_urls")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.LineDigitalContentURL = foreign
		if foreign.R == nil {
			foreign.R = &digitalContentURLR{}
		}
		foreign.R.Line = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.LineID) {
				local.R.LineDigitalContentURL = foreign
				if foreign.R == nil {
					foreign.R = &digitalContentURLR{}
				}
				foreign.R.Line = local
				break
			}
		}
	}

	return nil
}

// LoadAllocations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orderLineL) LoadAllocations(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`allocations`),
		qm.WhereIn(`allocations.order_line_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load allocations")
	}

	var resultSlice []*Allocation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice allocations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on allocations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for allocations")
	}

	if singular {
		object.R.Allocations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &allocationR{}
			}
			foreign.R.OrderLine = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OrderLineID {
				local.R.Allocations = append(local.R.Allocations, foreign)
				if foreign.R == nil {
					foreign.R = &allocationR{}
				}
				foreign.R.OrderLine = local
				break
			}
		}
	}

	return nil
}

// LoadFulfillmentLines allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orderLineL) LoadFulfillmentLines(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`fulfillment_lines`),
		qm.WhereIn(`fulfillment_lines.order_line_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load fulfillment_lines")
	}

	var resultSlice []*FulfillmentLine
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice fulfillment_lines")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on fulfillment_lines")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for fulfillment_lines")
	}

	if singular {
		object.R.FulfillmentLines = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fulfillmentLineR{}
			}
			foreign.R.OrderLine = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OrderLineID {
				local.R.FulfillmentLines = append(local.R.FulfillmentLines, foreign)
				if foreign.R == nil {
					foreign.R = &fulfillmentLineR{}
				}
				foreign.R.OrderLine = local
				break
			}
		}
	}

	return nil
}

// LoadOrderGrantedRefundLines allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orderLineL) LoadOrderGrantedRefundLines(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`order_granted_refund_lines`),
		qm.WhereIn(`order_granted_refund_lines.order_line_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load order_granted_refund_lines")
	}

	var resultSlice []*OrderGrantedRefundLine
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice order_granted_refund_lines")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on order_granted_refund_lines")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for order_granted_refund_lines")
	}

	if singular {
		object.R.OrderGrantedRefundLines = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderGrantedRefundLineR{}
			}
			foreign.R.OrderLine = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.OrderLineID) {
				local.R.OrderGrantedRefundLines = append(local.R.OrderGrantedRefundLines, foreign)
				if foreign.R == nil {
					foreign.R = &orderGrantedRefundLineR{}
				}
				foreign.R.OrderLine = local
				break
			}
		}
	}

	return nil
}

// LoadOrderLineDiscounts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orderLineL) LoadOrderLineDiscounts(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`order_line_discounts`),
		qm.WhereIn(`order_line_discounts.order_line_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load order_line_discounts")
	}

	var resultSlice []*OrderLineDiscount
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice order_line_discounts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on order_line_discounts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for order_line_discounts")
	}

	if singular {
		object.R.OrderLineDiscounts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderLineDiscountR{}
			}
			foreign.R.OrderLine = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.OrderLineID) {
				local.R.OrderLineDiscounts = append(local.R.OrderLineDiscounts, foreign)
				if foreign.R == nil {
					foreign.R = &orderLineDiscountR{}
				}
				foreign.R.OrderLine = local
				break
			}
		}
	}

	return nil
}

// SetOrder of the orderLine to the related item.
// Sets o.R.Order to related.
// Adds o to related.R.OrderLines.
func (o *OrderLine) SetOrder(exec boil.Executor, insert bool, related *Order) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"order_lines\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"order_id"}),
		strmangle.WhereClause("\"", "\"", 2, orderLinePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.OrderID = related.ID
	if o.R == nil {
		o.R = &orderLineR{
			Order: related,
		}
	} else {
		o.R.Order = related
	}

	if related.R == nil {
		related.R = &orderR{
			OrderLines: OrderLineSlice{o},
		}
	} else {
		related.R.OrderLines = append(related.R.OrderLines, o)
	}

	return nil
}

// SetVariant of the orderLine to the related item.
// Sets o.R.Variant to related.
// Adds o to related.R.VariantOrderLines.
func (o *OrderLine) SetVariant(exec boil.Executor, insert bool, related *ProductVariant) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"order_lines\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"variant_id"}),
		strmangle.WhereClause("\"", "\"", 2, orderLinePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.VariantID, related.ID)
	if o.R == nil {
		o.R = &orderLineR{
			Variant: related,
		}
	} else {
		o.R.Variant = related
	}

	if related.R == nil {
		related.R = &productVariantR{
			VariantOrderLines: OrderLineSlice{o},
		}
	} else {
		related.R.VariantOrderLines = append(related.R.VariantOrderLines, o)
	}

	return nil
}

// RemoveVariant relationship.
// Sets o.R.Variant to nil.
// Removes o from all passed in related items' relationships struct.
func (o *OrderLine) RemoveVariant(exec boil.Executor, related *ProductVariant) error {
	var err error

	queries.SetScanner(&o.VariantID, nil)
	if _, err = o.Update(exec, boil.Whitelist("variant_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Variant = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.VariantOrderLines {
		if queries.Equal(o.VariantID, ri.VariantID) {
			continue
		}

		ln := len(related.R.VariantOrderLines)
		if ln > 1 && i < ln-1 {
			related.R.VariantOrderLines[i] = related.R.VariantOrderLines[ln-1]
		}
		related.R.VariantOrderLines = related.R.VariantOrderLines[:ln-1]
		break
	}
	return nil
}

// SetTaxClass of the orderLine to the related item.
// Sets o.R.TaxClass to related.
// Adds o to related.R.OrderLines.
func (o *OrderLine) SetTaxClass(exec boil.Executor, insert bool, related *TaxClass) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"order_lines\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"tax_class_id"}),
		strmangle.WhereClause("\"", "\"", 2, orderLinePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.TaxClassID, related.ID)
	if o.R == nil {
		o.R = &orderLineR{
			TaxClass: related,
		}
	} else {
		o.R.TaxClass = related
	}

	if related.R == nil {
		related.R = &taxClassR{
			OrderLines: OrderLineSlice{o},
		}
	} else {
		related.R.OrderLines = append(related.R.OrderLines, o)
	}

	return nil
}

// RemoveTaxClass relationship.
// Sets o.R.TaxClass to nil.
// Removes o from all passed in related items' relationships struct.
func (o *OrderLine) RemoveTaxClass(exec boil.Executor, related *TaxClass) error {
	var err error

	queries.SetScanner(&o.TaxClassID, nil)
	if _, err = o.Update(exec, boil.Whitelist("tax_class_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.TaxClass = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.OrderLines {
		if queries.Equal(o.TaxClassID, ri.TaxClassID) {
			continue
		}

		ln := len(related.R.OrderLines)
		if ln > 1 && i < ln-1 {
			related.R.OrderLines[i] = related.R.OrderLines[ln-1]
		}
		related.R.OrderLines = related.R.OrderLines[:ln-1]
		break
	}
	return nil
}

// SetLineDigitalContentURL of the orderLine to the related item.
// Sets o.R.LineDigitalContentURL to related.
// Adds o to related.R.Line.
func (o *OrderLine) SetLineDigitalContentURL(exec boil.Executor, insert bool, related *DigitalContentURL) error {
	var err error

	if insert {
		queries.Assign(&related.LineID, o.ID)

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"digital_content_urls\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"line_id"}),
			strmangle.WhereClause("\"", "\"", 2, digitalContentURLPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.LineID, o.ID)
	}

	if o.R == nil {
		o.R = &orderLineR{
			LineDigitalContentURL: related,
		}
	} else {
		o.R.LineDigitalContentURL = related
	}

	if related.R == nil {
		related.R = &digitalContentURLR{
			Line: o,
		}
	} else {
		related.R.Line = o
	}
	return nil
}

// RemoveLineDigitalContentURL relationship.
// Sets o.R.LineDigitalContentURL to nil.
// Removes o from all passed in related items' relationships struct.
func (o *OrderLine) RemoveLineDigitalContentURL(exec boil.Executor, related *DigitalContentURL) error {
	var err error

	queries.SetScanner(&related.LineID, nil)
	if _, err = related.Update(exec, boil.Whitelist("line_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.LineDigitalContentURL = nil
	}

	if related == nil || related.R == nil {
		return nil
	}

	related.R.Line = nil

	return nil
}

// AddAllocations adds the given related objects to the existing relationships
// of the order_line, optionally inserting them as new records.
// Appends related to o.R.Allocations.
// Sets related.R.OrderLine appropriately.
func (o *OrderLine) AddAllocations(exec boil.Executor, insert bool, related ...*Allocation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderLineID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"allocations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"order_line_id"}),
				strmangle.WhereClause("\"", "\"", 2, allocationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderLineID = o.ID
		}
	}

	if o.R == nil {
		o.R = &orderLineR{
			Allocations: related,
		}
	} else {
		o.R.Allocations = append(o.R.Allocations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &allocationR{
				OrderLine: o,
			}
		} else {
			rel.R.OrderLine = o
		}
	}
	return nil
}

// AddFulfillmentLines adds the given related objects to the existing relationships
// of the order_line, optionally inserting them as new records.
// Appends related to o.R.FulfillmentLines.
// Sets related.R.OrderLine appropriately.
func (o *OrderLine) AddFulfillmentLines(exec boil.Executor, insert bool, related ...*FulfillmentLine) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderLineID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"fulfillment_lines\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"order_line_id"}),
				strmangle.WhereClause("\"", "\"", 2, fulfillmentLinePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderLineID = o.ID
		}
	}

	if o.R == nil {
		o.R = &orderLineR{
			FulfillmentLines: related,
		}
	} else {
		o.R.FulfillmentLines = append(o.R.FulfillmentLines, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fulfillmentLineR{
				OrderLine: o,
			}
		} else {
			rel.R.OrderLine = o
		}
	}
	return nil
}

// AddOrderGrantedRefundLines adds the given related objects to the existing relationships
// of the order_line, optionally inserting them as new records.
// Appends related to o.R.OrderGrantedRefundLines.
// Sets related.R.OrderLine appropriately.
func (o *OrderLine) AddOrderGrantedRefundLines(exec boil.Executor, insert bool, related ...*OrderGrantedRefundLine) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderLineID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"order_granted_refund_lines\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"order_line_id"}),
				strmangle.WhereClause("\"", "\"", 2, orderGrantedRefundLinePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderLineID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &orderLineR{
			OrderGrantedRefundLines: related,
		}
	} else {
		o.R.OrderGrantedRefundLines = append(o.R.OrderGrantedRefundLines, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderGrantedRefundLineR{
				OrderLine: o,
			}
		} else {
			rel.R.OrderLine = o
		}
	}
	return nil
}

// SetOrderGrantedRefundLines removes all previously related items of the
// order_line replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderLine's OrderGrantedRefundLines accordingly.
// Replaces o.R.OrderGrantedRefundLines with related.
// Sets related.R.OrderLine's OrderGrantedRefundLines accordingly.
func (o *OrderLine) SetOrderGrantedRefundLines(exec boil.Executor, insert bool, related ...*OrderGrantedRefundLine) error {
	query := "update \"order_granted_refund_lines\" set \"order_line_id\" = null where \"order_line_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OrderGrantedRefundLines {
			queries.SetScanner(&rel.OrderLineID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.OrderLine = nil
		}
		o.R.OrderGrantedRefundLines = nil
	}

	return o.AddOrderGrantedRefundLines(exec, insert, related...)
}

// RemoveOrderGrantedRefundLines relationships from objects passed in.
// Removes related items from R.OrderGrantedRefundLines (uses pointer comparison, removal does not keep order)
// Sets related.R.OrderLine.
func (o *OrderLine) RemoveOrderGrantedRefundLines(exec boil.Executor, related ...*OrderGrantedRefundLine) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderLineID, nil)
		if rel.R != nil {
			rel.R.OrderLine = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("order_line_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderGrantedRefundLines {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderGrantedRefundLines)
			if ln > 1 && i < ln-1 {
				o.R.OrderGrantedRefundLines[i] = o.R.OrderGrantedRefundLines[ln-1]
			}
			o.R.OrderGrantedRefundLines = o.R.OrderGrantedRefundLines[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderLineDiscounts adds the given related objects to the existing relationships
// of the order_line, optionally inserting them as new records.
// Appends related to o.R.OrderLineDiscounts.
// Sets related.R.OrderLine appropriately.
func (o *OrderLine) AddOrderLineDiscounts(exec boil.Executor, insert bool, related ...*OrderLineDiscount) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderLineID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"order_line_discounts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"order_line_id"}),
				strmangle.WhereClause("\"", "\"", 2, orderLineDiscountPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderLineID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &orderLineR{
			OrderLineDiscounts: related,
		}
	} else {
		o.R.OrderLineDiscounts = append(o.R.OrderLineDiscounts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderLineDiscountR{
				OrderLine: o,
			}
		} else {
			rel.R.OrderLine = o
		}
	}
	return nil
}

// SetOrderLineDiscounts removes all previously related items of the
// order_line replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderLine's OrderLineDiscounts accordingly.
// Replaces o.R.OrderLineDiscounts with related.
// Sets related.R.OrderLine's OrderLineDiscounts accordingly.
func (o *OrderLine) SetOrderLineDiscounts(exec boil.Executor, insert bool, related ...*OrderLineDiscount) error {
	query := "update \"order_line_discounts\" set \"order_line_id\" = null where \"order_line_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OrderLineDiscounts {
			queries.SetScanner(&rel.OrderLineID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.OrderLine = nil
		}
		o.R.OrderLineDiscounts = nil
	}

	return o.AddOrderLineDiscounts(exec, insert, related...)
}

// RemoveOrderLineDiscounts relationships from objects passed in.
// Removes related items from R.OrderLineDiscounts (uses pointer comparison, removal does not keep order)
// Sets related.R.OrderLine.
func (o *OrderLine) RemoveOrderLineDiscounts(exec boil.Executor, related ...*OrderLineDiscount) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderLineID, nil)
		if rel.R != nil {
			rel.R.OrderLine = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("order_line_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderLineDiscounts {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderLineDiscounts)
			if ln > 1 && i < ln-1 {
				o.R.OrderLineDiscounts[i] = o.R.OrderLineDiscounts[ln-1]
			}
			o.R.OrderLineDiscounts = o.R.OrderLineDiscounts[:ln-1]
			break
		}
	}

	return nil
}

// OrderLines retrieves all the records using an executor.
func OrderLines(mods ...qm.QueryMod) orderLineQuery {
	mods = append(mods, qm.From("\"order_lines\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"order_lines\".*"})
	}

	return orderLineQuery{q}
}

// FindOrderLine retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindOrderLine(exec boil.Executor, iD string, selectCols ...string) (*OrderLine, error) {
	orderLineObj := &OrderLine{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"order_lines\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, orderLineObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from order_lines")
	}

	return orderLineObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *OrderLine) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no order_lines provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(orderLineColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	orderLineInsertCacheMut.RLock()
	cache, cached := orderLineInsertCache[key]
	orderLineInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			orderLineAllColumns,
			orderLineColumnsWithDefault,
			orderLineColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(orderLineType, orderLineMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"order_lines\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"order_lines\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into order_lines")
	}

	if !cached {
		orderLineInsertCacheMut.Lock()
		orderLineInsertCache[key] = cache
		orderLineInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the OrderLine.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *OrderLine) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	orderLineUpdateCacheMut.RLock()
	cache, cached := orderLineUpdateCache[key]
	orderLineUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			orderLineAllColumns,
			orderLinePrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update order_lines, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"order_lines\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, orderLinePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, append(wl, orderLinePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update order_lines row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for order_lines")
	}

	if !cached {
		orderLineUpdateCacheMut.Lock()
		orderLineUpdateCache[key] = cache
		orderLineUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q orderLineQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for order_lines")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o OrderLineSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"order_lines\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, orderLinePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in orderLine slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all orderLine")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *OrderLine) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("model: no order_lines provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(orderLineColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	orderLineUpsertCacheMut.RLock()
	cache, cached := orderLineUpsertCache[key]
	orderLineUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			orderLineAllColumns,
			orderLineColumnsWithDefault,
			orderLineColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			orderLineAllColumns,
			orderLinePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("model: unable to upsert order_lines, could not build update column list")
		}

		ret := strmangle.SetComplement(orderLineAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(orderLinePrimaryKeyColumns) == 0 {
				return errors.New("model: unable to upsert order_lines, could not build conflict column list")
			}

			conflict = make([]string, len(orderLinePrimaryKeyColumns))
			copy(conflict, orderLinePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"order_lines\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(orderLineType, orderLineMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "model: unable to upsert order_lines")
	}

	if !cached {
		orderLineUpsertCacheMut.Lock()
		orderLineUpsertCache[key] = cache
		orderLineUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single OrderLine record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *OrderLine) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no OrderLine provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), orderLinePrimaryKeyMapping)
	sql := "DELETE FROM \"order_lines\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for order_lines")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q orderLineQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no orderLineQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for order_lines")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o OrderLineSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"order_lines\" WHERE " +
		strmangle.WhereInClause(string(dialect.LQ), string(dialect.RQ), 1, orderLinePrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from orderLine slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for order_lines")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *OrderLine) Reload(exec boil.Executor) error {
	ret, err := FindOrderLine(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *OrderLineSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := OrderLineSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"order_lines\".* FROM \"order_lines\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orderLinePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in OrderLineSlice")
	}

	*o = slice

	return nil
}

// OrderLineExists checks if the OrderLine row exists.
func OrderLineExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"order_lines\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if order_lines exists")
	}

	return exists, nil
}

// Exists checks if the OrderLine row exists.
func (o *OrderLine) Exists(exec boil.Executor) (bool, error) {
	return OrderLineExists(exec, o.ID)
}
