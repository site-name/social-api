// Code generated by SQLBoiler 4.16.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/site-name/decimal"
	"github.com/sitename/sitename/modules/model_types"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// OrderLine is an object representing the database table.
type OrderLine struct {
	ID                                string                  `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt                         int64                   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	OrderID                           string                  `boil:"order_id" json:"order_id" toml:"order_id" yaml:"order_id"`
	VariantID                         model_types.NullString  `boil:"variant_id" json:"variant_id,omitempty" toml:"variant_id" yaml:"variant_id,omitempty"`
	ProductName                       string                  `boil:"product_name" json:"product_name" toml:"product_name" yaml:"product_name"`
	VariantName                       string                  `boil:"variant_name" json:"variant_name" toml:"variant_name" yaml:"variant_name"`
	TranslatedProductName             string                  `boil:"translated_product_name" json:"translated_product_name" toml:"translated_product_name" yaml:"translated_product_name"`
	TranslatedVariantName             string                  `boil:"translated_variant_name" json:"translated_variant_name" toml:"translated_variant_name" yaml:"translated_variant_name"`
	ProductSku                        model_types.NullString  `boil:"product_sku" json:"product_sku,omitempty" toml:"product_sku" yaml:"product_sku,omitempty"`
	ProductVariantID                  model_types.NullString  `boil:"product_variant_id" json:"product_variant_id,omitempty" toml:"product_variant_id" yaml:"product_variant_id,omitempty"`
	IsShippingRequired                bool                    `boil:"is_shipping_required" json:"is_shipping_required" toml:"is_shipping_required" yaml:"is_shipping_required"`
	IsGiftcard                        bool                    `boil:"is_giftcard" json:"is_giftcard" toml:"is_giftcard" yaml:"is_giftcard"`
	Quantity                          int                     `boil:"quantity" json:"quantity" toml:"quantity" yaml:"quantity"`
	QuantityFulfilled                 int                     `boil:"quantity_fulfilled" json:"quantity_fulfilled" toml:"quantity_fulfilled" yaml:"quantity_fulfilled"`
	Currency                          Currency                `boil:"currency" json:"currency" toml:"currency" yaml:"currency"`
	UnitDiscountAmount                decimal.Decimal         `boil:"unit_discount_amount" json:"unit_discount_amount" toml:"unit_discount_amount" yaml:"unit_discount_amount"`
	UnitDiscountType                  DiscountValueType       `boil:"unit_discount_type" json:"unit_discount_type" toml:"unit_discount_type" yaml:"unit_discount_type"`
	UnitDiscountReason                model_types.NullString  `boil:"unit_discount_reason" json:"unit_discount_reason,omitempty" toml:"unit_discount_reason" yaml:"unit_discount_reason,omitempty"`
	UnitPriceNetAmount                decimal.Decimal         `boil:"unit_price_net_amount" json:"unit_price_net_amount" toml:"unit_price_net_amount" yaml:"unit_price_net_amount"`
	UnitDiscountValue                 decimal.Decimal         `boil:"unit_discount_value" json:"unit_discount_value" toml:"unit_discount_value" yaml:"unit_discount_value"`
	UnitPriceGrossAmount              decimal.Decimal         `boil:"unit_price_gross_amount" json:"unit_price_gross_amount" toml:"unit_price_gross_amount" yaml:"unit_price_gross_amount"`
	TotalPriceNetAmount               model_types.NullDecimal `boil:"total_price_net_amount" json:"total_price_net_amount,omitempty" toml:"total_price_net_amount" yaml:"total_price_net_amount,omitempty"`
	TotalPriceGrossAmount             model_types.NullDecimal `boil:"total_price_gross_amount" json:"total_price_gross_amount,omitempty" toml:"total_price_gross_amount" yaml:"total_price_gross_amount,omitempty"`
	UndiscountedUnitPriceGrossAmount  decimal.Decimal         `boil:"undiscounted_unit_price_gross_amount" json:"undiscounted_unit_price_gross_amount" toml:"undiscounted_unit_price_gross_amount" yaml:"undiscounted_unit_price_gross_amount"`
	UndiscountedUnitPriceNetAmount    decimal.Decimal         `boil:"undiscounted_unit_price_net_amount" json:"undiscounted_unit_price_net_amount" toml:"undiscounted_unit_price_net_amount" yaml:"undiscounted_unit_price_net_amount"`
	UndiscountedTotalPriceGrossAmount decimal.Decimal         `boil:"undiscounted_total_price_gross_amount" json:"undiscounted_total_price_gross_amount" toml:"undiscounted_total_price_gross_amount" yaml:"undiscounted_total_price_gross_amount"`
	UndiscountedTotalPriceNetAmount   decimal.Decimal         `boil:"undiscounted_total_price_net_amount" json:"undiscounted_total_price_net_amount" toml:"undiscounted_total_price_net_amount" yaml:"undiscounted_total_price_net_amount"`
	TaxRate                           model_types.NullDecimal `boil:"tax_rate" json:"tax_rate,omitempty" toml:"tax_rate" yaml:"tax_rate,omitempty"`

	R *orderLineR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L orderLineL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var OrderLineColumns = struct {
	ID                                string
	CreatedAt                         string
	OrderID                           string
	VariantID                         string
	ProductName                       string
	VariantName                       string
	TranslatedProductName             string
	TranslatedVariantName             string
	ProductSku                        string
	ProductVariantID                  string
	IsShippingRequired                string
	IsGiftcard                        string
	Quantity                          string
	QuantityFulfilled                 string
	Currency                          string
	UnitDiscountAmount                string
	UnitDiscountType                  string
	UnitDiscountReason                string
	UnitPriceNetAmount                string
	UnitDiscountValue                 string
	UnitPriceGrossAmount              string
	TotalPriceNetAmount               string
	TotalPriceGrossAmount             string
	UndiscountedUnitPriceGrossAmount  string
	UndiscountedUnitPriceNetAmount    string
	UndiscountedTotalPriceGrossAmount string
	UndiscountedTotalPriceNetAmount   string
	TaxRate                           string
}{
	ID:                                "id",
	CreatedAt:                         "created_at",
	OrderID:                           "order_id",
	VariantID:                         "variant_id",
	ProductName:                       "product_name",
	VariantName:                       "variant_name",
	TranslatedProductName:             "translated_product_name",
	TranslatedVariantName:             "translated_variant_name",
	ProductSku:                        "product_sku",
	ProductVariantID:                  "product_variant_id",
	IsShippingRequired:                "is_shipping_required",
	IsGiftcard:                        "is_giftcard",
	Quantity:                          "quantity",
	QuantityFulfilled:                 "quantity_fulfilled",
	Currency:                          "currency",
	UnitDiscountAmount:                "unit_discount_amount",
	UnitDiscountType:                  "unit_discount_type",
	UnitDiscountReason:                "unit_discount_reason",
	UnitPriceNetAmount:                "unit_price_net_amount",
	UnitDiscountValue:                 "unit_discount_value",
	UnitPriceGrossAmount:              "unit_price_gross_amount",
	TotalPriceNetAmount:               "total_price_net_amount",
	TotalPriceGrossAmount:             "total_price_gross_amount",
	UndiscountedUnitPriceGrossAmount:  "undiscounted_unit_price_gross_amount",
	UndiscountedUnitPriceNetAmount:    "undiscounted_unit_price_net_amount",
	UndiscountedTotalPriceGrossAmount: "undiscounted_total_price_gross_amount",
	UndiscountedTotalPriceNetAmount:   "undiscounted_total_price_net_amount",
	TaxRate:                           "tax_rate",
}

var OrderLineTableColumns = struct {
	ID                                string
	CreatedAt                         string
	OrderID                           string
	VariantID                         string
	ProductName                       string
	VariantName                       string
	TranslatedProductName             string
	TranslatedVariantName             string
	ProductSku                        string
	ProductVariantID                  string
	IsShippingRequired                string
	IsGiftcard                        string
	Quantity                          string
	QuantityFulfilled                 string
	Currency                          string
	UnitDiscountAmount                string
	UnitDiscountType                  string
	UnitDiscountReason                string
	UnitPriceNetAmount                string
	UnitDiscountValue                 string
	UnitPriceGrossAmount              string
	TotalPriceNetAmount               string
	TotalPriceGrossAmount             string
	UndiscountedUnitPriceGrossAmount  string
	UndiscountedUnitPriceNetAmount    string
	UndiscountedTotalPriceGrossAmount string
	UndiscountedTotalPriceNetAmount   string
	TaxRate                           string
}{
	ID:                                "order_lines.id",
	CreatedAt:                         "order_lines.created_at",
	OrderID:                           "order_lines.order_id",
	VariantID:                         "order_lines.variant_id",
	ProductName:                       "order_lines.product_name",
	VariantName:                       "order_lines.variant_name",
	TranslatedProductName:             "order_lines.translated_product_name",
	TranslatedVariantName:             "order_lines.translated_variant_name",
	ProductSku:                        "order_lines.product_sku",
	ProductVariantID:                  "order_lines.product_variant_id",
	IsShippingRequired:                "order_lines.is_shipping_required",
	IsGiftcard:                        "order_lines.is_giftcard",
	Quantity:                          "order_lines.quantity",
	QuantityFulfilled:                 "order_lines.quantity_fulfilled",
	Currency:                          "order_lines.currency",
	UnitDiscountAmount:                "order_lines.unit_discount_amount",
	UnitDiscountType:                  "order_lines.unit_discount_type",
	UnitDiscountReason:                "order_lines.unit_discount_reason",
	UnitPriceNetAmount:                "order_lines.unit_price_net_amount",
	UnitDiscountValue:                 "order_lines.unit_discount_value",
	UnitPriceGrossAmount:              "order_lines.unit_price_gross_amount",
	TotalPriceNetAmount:               "order_lines.total_price_net_amount",
	TotalPriceGrossAmount:             "order_lines.total_price_gross_amount",
	UndiscountedUnitPriceGrossAmount:  "order_lines.undiscounted_unit_price_gross_amount",
	UndiscountedUnitPriceNetAmount:    "order_lines.undiscounted_unit_price_net_amount",
	UndiscountedTotalPriceGrossAmount: "order_lines.undiscounted_total_price_gross_amount",
	UndiscountedTotalPriceNetAmount:   "order_lines.undiscounted_total_price_net_amount",
	TaxRate:                           "order_lines.tax_rate",
}

// Generated where

var OrderLineWhere = struct {
	ID                                whereHelperstring
	CreatedAt                         whereHelperint64
	OrderID                           whereHelperstring
	VariantID                         whereHelpermodel_types_NullString
	ProductName                       whereHelperstring
	VariantName                       whereHelperstring
	TranslatedProductName             whereHelperstring
	TranslatedVariantName             whereHelperstring
	ProductSku                        whereHelpermodel_types_NullString
	ProductVariantID                  whereHelpermodel_types_NullString
	IsShippingRequired                whereHelperbool
	IsGiftcard                        whereHelperbool
	Quantity                          whereHelperint
	QuantityFulfilled                 whereHelperint
	Currency                          whereHelperCurrency
	UnitDiscountAmount                whereHelperdecimal_Decimal
	UnitDiscountType                  whereHelperDiscountValueType
	UnitDiscountReason                whereHelpermodel_types_NullString
	UnitPriceNetAmount                whereHelperdecimal_Decimal
	UnitDiscountValue                 whereHelperdecimal_Decimal
	UnitPriceGrossAmount              whereHelperdecimal_Decimal
	TotalPriceNetAmount               whereHelpermodel_types_NullDecimal
	TotalPriceGrossAmount             whereHelpermodel_types_NullDecimal
	UndiscountedUnitPriceGrossAmount  whereHelperdecimal_Decimal
	UndiscountedUnitPriceNetAmount    whereHelperdecimal_Decimal
	UndiscountedTotalPriceGrossAmount whereHelperdecimal_Decimal
	UndiscountedTotalPriceNetAmount   whereHelperdecimal_Decimal
	TaxRate                           whereHelpermodel_types_NullDecimal
}{
	ID:                                whereHelperstring{field: "\"order_lines\".\"id\""},
	CreatedAt:                         whereHelperint64{field: "\"order_lines\".\"created_at\""},
	OrderID:                           whereHelperstring{field: "\"order_lines\".\"order_id\""},
	VariantID:                         whereHelpermodel_types_NullString{field: "\"order_lines\".\"variant_id\""},
	ProductName:                       whereHelperstring{field: "\"order_lines\".\"product_name\""},
	VariantName:                       whereHelperstring{field: "\"order_lines\".\"variant_name\""},
	TranslatedProductName:             whereHelperstring{field: "\"order_lines\".\"translated_product_name\""},
	TranslatedVariantName:             whereHelperstring{field: "\"order_lines\".\"translated_variant_name\""},
	ProductSku:                        whereHelpermodel_types_NullString{field: "\"order_lines\".\"product_sku\""},
	ProductVariantID:                  whereHelpermodel_types_NullString{field: "\"order_lines\".\"product_variant_id\""},
	IsShippingRequired:                whereHelperbool{field: "\"order_lines\".\"is_shipping_required\""},
	IsGiftcard:                        whereHelperbool{field: "\"order_lines\".\"is_giftcard\""},
	Quantity:                          whereHelperint{field: "\"order_lines\".\"quantity\""},
	QuantityFulfilled:                 whereHelperint{field: "\"order_lines\".\"quantity_fulfilled\""},
	Currency:                          whereHelperCurrency{field: "\"order_lines\".\"currency\""},
	UnitDiscountAmount:                whereHelperdecimal_Decimal{field: "\"order_lines\".\"unit_discount_amount\""},
	UnitDiscountType:                  whereHelperDiscountValueType{field: "\"order_lines\".\"unit_discount_type\""},
	UnitDiscountReason:                whereHelpermodel_types_NullString{field: "\"order_lines\".\"unit_discount_reason\""},
	UnitPriceNetAmount:                whereHelperdecimal_Decimal{field: "\"order_lines\".\"unit_price_net_amount\""},
	UnitDiscountValue:                 whereHelperdecimal_Decimal{field: "\"order_lines\".\"unit_discount_value\""},
	UnitPriceGrossAmount:              whereHelperdecimal_Decimal{field: "\"order_lines\".\"unit_price_gross_amount\""},
	TotalPriceNetAmount:               whereHelpermodel_types_NullDecimal{field: "\"order_lines\".\"total_price_net_amount\""},
	TotalPriceGrossAmount:             whereHelpermodel_types_NullDecimal{field: "\"order_lines\".\"total_price_gross_amount\""},
	UndiscountedUnitPriceGrossAmount:  whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_unit_price_gross_amount\""},
	UndiscountedUnitPriceNetAmount:    whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_unit_price_net_amount\""},
	UndiscountedTotalPriceGrossAmount: whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_total_price_gross_amount\""},
	UndiscountedTotalPriceNetAmount:   whereHelperdecimal_Decimal{field: "\"order_lines\".\"undiscounted_total_price_net_amount\""},
	TaxRate:                           whereHelpermodel_types_NullDecimal{field: "\"order_lines\".\"tax_rate\""},
}

// OrderLineRels is where relationship names are stored.
var OrderLineRels = struct {
	Allocations string
}{
	Allocations: "Allocations",
}

// orderLineR is where relationships are stored.
type orderLineR struct {
	Allocations AllocationSlice `boil:"Allocations" json:"Allocations" toml:"Allocations" yaml:"Allocations"`
}

// NewStruct creates a new relationship struct
func (*orderLineR) NewStruct() *orderLineR {
	return &orderLineR{}
}

func (r *orderLineR) GetAllocations() AllocationSlice {
	if r == nil {
		return nil
	}
	return r.Allocations
}

// orderLineL is where Load methods for each relationship are stored.
type orderLineL struct{}

var (
	orderLineAllColumns            = []string{"id", "created_at", "order_id", "variant_id", "product_name", "variant_name", "translated_product_name", "translated_variant_name", "product_sku", "product_variant_id", "is_shipping_required", "is_giftcard", "quantity", "quantity_fulfilled", "currency", "unit_discount_amount", "unit_discount_type", "unit_discount_reason", "unit_price_net_amount", "unit_discount_value", "unit_price_gross_amount", "total_price_net_amount", "total_price_gross_amount", "undiscounted_unit_price_gross_amount", "undiscounted_unit_price_net_amount", "undiscounted_total_price_gross_amount", "undiscounted_total_price_net_amount", "tax_rate"}
	orderLineColumnsWithoutDefault = []string{"created_at", "order_id", "product_name", "variant_name", "translated_product_name", "translated_variant_name", "is_shipping_required", "is_giftcard", "quantity", "quantity_fulfilled", "currency", "unit_discount_type"}
	orderLineColumnsWithDefault    = []string{"id", "variant_id", "product_sku", "product_variant_id", "unit_discount_amount", "unit_discount_reason", "unit_price_net_amount", "unit_discount_value", "unit_price_gross_amount", "total_price_net_amount", "total_price_gross_amount", "undiscounted_unit_price_gross_amount", "undiscounted_unit_price_net_amount", "undiscounted_total_price_gross_amount", "undiscounted_total_price_net_amount", "tax_rate"}
	orderLinePrimaryKeyColumns     = []string{"id"}
	orderLineGeneratedColumns      = []string{}
)

type (
	// OrderLineSlice is an alias for a slice of pointers to OrderLine.
	// This should almost always be used instead of []OrderLine.
	OrderLineSlice []*OrderLine

	orderLineQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	orderLineType                 = reflect.TypeOf(&OrderLine{})
	orderLineMapping              = queries.MakeStructMapping(orderLineType)
	orderLinePrimaryKeyMapping, _ = queries.BindMapping(orderLineType, orderLineMapping, orderLinePrimaryKeyColumns)
	orderLineInsertCacheMut       sync.RWMutex
	orderLineInsertCache          = make(map[string]insertCache)
	orderLineUpdateCacheMut       sync.RWMutex
	orderLineUpdateCache          = make(map[string]updateCache)
	orderLineUpsertCacheMut       sync.RWMutex
	orderLineUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single orderLine record from the query.
func (q orderLineQuery) One(exec boil.Executor) (*OrderLine, error) {
	o := &OrderLine{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for order_lines")
	}

	return o, nil
}

// All returns all OrderLine records from the query.
func (q orderLineQuery) All(exec boil.Executor) (OrderLineSlice, error) {
	var o []*OrderLine

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to OrderLine slice")
	}

	return o, nil
}

// Count returns the count of all OrderLine records in the query.
func (q orderLineQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count order_lines rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q orderLineQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if order_lines exists")
	}

	return count > 0, nil
}

// Allocations retrieves all the allocation's Allocations with an executor.
func (o *OrderLine) Allocations(mods ...qm.QueryMod) allocationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"allocations\".\"order_line_id\"=?", o.ID),
	)

	return Allocations(queryMods...)
}

// LoadAllocations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orderLineL) LoadAllocations(e boil.Executor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`allocations`),
		qm.WhereIn(`allocations.order_line_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load allocations")
	}

	var resultSlice []*Allocation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice allocations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on allocations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for allocations")
	}

	if singular {
		object.R.Allocations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &allocationR{}
			}
			foreign.R.OrderLine = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OrderLineID {
				local.R.Allocations = append(local.R.Allocations, foreign)
				if foreign.R == nil {
					foreign.R = &allocationR{}
				}
				foreign.R.OrderLine = local
				break
			}
		}
	}

	return nil
}

// AddAllocations adds the given related objects to the existing relationships
// of the order_line, optionally inserting them as new records.
// Appends related to o.R.Allocations.
// Sets related.R.OrderLine appropriately.
func (o *OrderLine) AddAllocations(exec boil.Executor, insert bool, related ...*Allocation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderLineID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"allocations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"order_line_id"}),
				strmangle.WhereClause("\"", "\"", 2, allocationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderLineID = o.ID
		}
	}

	if o.R == nil {
		o.R = &orderLineR{
			Allocations: related,
		}
	} else {
		o.R.Allocations = append(o.R.Allocations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &allocationR{
				OrderLine: o,
			}
		} else {
			rel.R.OrderLine = o
		}
	}
	return nil
}

// OrderLines retrieves all the records using an executor.
func OrderLines(mods ...qm.QueryMod) orderLineQuery {
	mods = append(mods, qm.From("\"order_lines\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"order_lines\".*"})
	}

	return orderLineQuery{q}
}

// FindOrderLine retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindOrderLine(exec boil.Executor, iD string, selectCols ...string) (*OrderLine, error) {
	orderLineObj := &OrderLine{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"order_lines\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, orderLineObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from order_lines")
	}

	return orderLineObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *OrderLine) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no order_lines provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(orderLineColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	orderLineInsertCacheMut.RLock()
	cache, cached := orderLineInsertCache[key]
	orderLineInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			orderLineAllColumns,
			orderLineColumnsWithDefault,
			orderLineColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(orderLineType, orderLineMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"order_lines\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"order_lines\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into order_lines")
	}

	if !cached {
		orderLineInsertCacheMut.Lock()
		orderLineInsertCache[key] = cache
		orderLineInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the OrderLine.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *OrderLine) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	orderLineUpdateCacheMut.RLock()
	cache, cached := orderLineUpdateCache[key]
	orderLineUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			orderLineAllColumns,
			orderLinePrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update order_lines, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"order_lines\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, orderLinePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, append(wl, orderLinePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update order_lines row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for order_lines")
	}

	if !cached {
		orderLineUpdateCacheMut.Lock()
		orderLineUpdateCache[key] = cache
		orderLineUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q orderLineQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for order_lines")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o OrderLineSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"order_lines\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, orderLinePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in orderLine slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all orderLine")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *OrderLine) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("model: no order_lines provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(orderLineColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	orderLineUpsertCacheMut.RLock()
	cache, cached := orderLineUpsertCache[key]
	orderLineUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			orderLineAllColumns,
			orderLineColumnsWithDefault,
			orderLineColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			orderLineAllColumns,
			orderLinePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("model: unable to upsert order_lines, could not build update column list")
		}

		ret := strmangle.SetComplement(orderLineAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(orderLinePrimaryKeyColumns) == 0 {
				return errors.New("model: unable to upsert order_lines, could not build conflict column list")
			}

			conflict = make([]string, len(orderLinePrimaryKeyColumns))
			copy(conflict, orderLinePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"order_lines\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(orderLineType, orderLineMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "model: unable to upsert order_lines")
	}

	if !cached {
		orderLineUpsertCacheMut.Lock()
		orderLineUpsertCache[key] = cache
		orderLineUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single OrderLine record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *OrderLine) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no OrderLine provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), orderLinePrimaryKeyMapping)
	sql := "DELETE FROM \"order_lines\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for order_lines")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q orderLineQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no orderLineQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for order_lines")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o OrderLineSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"order_lines\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orderLinePrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from orderLine slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for order_lines")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *OrderLine) Reload(exec boil.Executor) error {
	ret, err := FindOrderLine(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *OrderLineSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := OrderLineSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"order_lines\".* FROM \"order_lines\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orderLinePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in OrderLineSlice")
	}

	*o = slice

	return nil
}

// OrderLineExists checks if the OrderLine row exists.
func OrderLineExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"order_lines\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if order_lines exists")
	}

	return exists, nil
}

// Exists checks if the OrderLine row exists.
func (o *OrderLine) Exists(exec boil.Executor) (bool, error) {
	return OrderLineExists(exec, o.ID)
}
