// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/sitename/sitename/modules/model_types"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// User is an object representing the database table.
type User struct {
	ID                       string                 `boil:"id" json:"id" toml:"id" yaml:"id"`
	Email                    string                 `boil:"email" json:"email" toml:"email" yaml:"email"`
	Username                 string                 `boil:"username" json:"username" toml:"username" yaml:"username"`
	FirstName                string                 `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	LastName                 string                 `boil:"last_name" json:"last_name" toml:"last_name" yaml:"last_name"`
	DefaultShippingAddressID model_types.NullString `boil:"default_shipping_address_id" json:"default_shipping_address_id,omitempty" toml:"default_shipping_address_id" yaml:"default_shipping_address_id,omitempty"`
	DefaultBillingAddressID  model_types.NullString `boil:"default_billing_address_id" json:"default_billing_address_id,omitempty" toml:"default_billing_address_id" yaml:"default_billing_address_id,omitempty"`
	Password                 string                 `boil:"password" json:"password" toml:"password" yaml:"password"`
	AuthData                 model_types.NullString `boil:"auth_data" json:"auth_data,omitempty" toml:"auth_data" yaml:"auth_data,omitempty"`
	AuthService              string                 `boil:"auth_service" json:"auth_service" toml:"auth_service" yaml:"auth_service"`
	EmailVerified            bool                   `boil:"email_verified" json:"email_verified" toml:"email_verified" yaml:"email_verified"`
	Nickname                 string                 `boil:"nickname" json:"nickname" toml:"nickname" yaml:"nickname"`
	Roles                    string                 `boil:"roles" json:"roles" toml:"roles" yaml:"roles"`
	Props                    model_types.JSONString `boil:"props" json:"props,omitempty" toml:"props" yaml:"props,omitempty"`
	NotifyProps              model_types.JSONString `boil:"notify_props" json:"notify_props,omitempty" toml:"notify_props" yaml:"notify_props,omitempty"`
	LastPasswordUpdate       int64                  `boil:"last_password_update" json:"last_password_update" toml:"last_password_update" yaml:"last_password_update"`
	LastPictureUpdate        int64                  `boil:"last_picture_update" json:"last_picture_update" toml:"last_picture_update" yaml:"last_picture_update"`
	FailedAttempts           int                    `boil:"failed_attempts" json:"failed_attempts" toml:"failed_attempts" yaml:"failed_attempts"`
	Locale                   LanguageCode           `boil:"locale" json:"locale" toml:"locale" yaml:"locale"`
	Timezone                 model_types.JSONString `boil:"timezone" json:"timezone,omitempty" toml:"timezone" yaml:"timezone,omitempty"`
	MfaActive                bool                   `boil:"mfa_active" json:"mfa_active" toml:"mfa_active" yaml:"mfa_active"`
	MfaSecret                string                 `boil:"mfa_secret" json:"mfa_secret" toml:"mfa_secret" yaml:"mfa_secret"`
	CreatedAt                int64                  `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                int64                  `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeleteAt                 int64                  `boil:"delete_at" json:"delete_at" toml:"delete_at" yaml:"delete_at"`
	IsActive                 bool                   `boil:"is_active" json:"is_active" toml:"is_active" yaml:"is_active"`
	Note                     model_types.NullString `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	JWTTokenKey              string                 `boil:"jwt_token_key" json:"jwt_token_key" toml:"jwt_token_key" yaml:"jwt_token_key"`
	LastActivityAt           int64                  `boil:"last_activity_at" json:"last_activity_at" toml:"last_activity_at" yaml:"last_activity_at"`
	TermsOfServiceID         string                 `boil:"terms_of_service_id" json:"terms_of_service_id" toml:"terms_of_service_id" yaml:"terms_of_service_id"`
	TermsOfServiceCreatedAt  int64                  `boil:"terms_of_service_created_at" json:"terms_of_service_created_at" toml:"terms_of_service_created_at" yaml:"terms_of_service_created_at"`
	DisableWelcomeEmail      bool                   `boil:"disable_welcome_email" json:"disable_welcome_email" toml:"disable_welcome_email" yaml:"disable_welcome_email"`
	Metadata                 model_types.JSONString `boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	PrivateMetadata          model_types.JSONString `boil:"private_metadata" json:"private_metadata,omitempty" toml:"private_metadata" yaml:"private_metadata,omitempty"`

	R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ID                       string
	Email                    string
	Username                 string
	FirstName                string
	LastName                 string
	DefaultShippingAddressID string
	DefaultBillingAddressID  string
	Password                 string
	AuthData                 string
	AuthService              string
	EmailVerified            string
	Nickname                 string
	Roles                    string
	Props                    string
	NotifyProps              string
	LastPasswordUpdate       string
	LastPictureUpdate        string
	FailedAttempts           string
	Locale                   string
	Timezone                 string
	MfaActive                string
	MfaSecret                string
	CreatedAt                string
	UpdatedAt                string
	DeleteAt                 string
	IsActive                 string
	Note                     string
	JWTTokenKey              string
	LastActivityAt           string
	TermsOfServiceID         string
	TermsOfServiceCreatedAt  string
	DisableWelcomeEmail      string
	Metadata                 string
	PrivateMetadata          string
}{
	ID:                       "id",
	Email:                    "email",
	Username:                 "username",
	FirstName:                "first_name",
	LastName:                 "last_name",
	DefaultShippingAddressID: "default_shipping_address_id",
	DefaultBillingAddressID:  "default_billing_address_id",
	Password:                 "password",
	AuthData:                 "auth_data",
	AuthService:              "auth_service",
	EmailVerified:            "email_verified",
	Nickname:                 "nickname",
	Roles:                    "roles",
	Props:                    "props",
	NotifyProps:              "notify_props",
	LastPasswordUpdate:       "last_password_update",
	LastPictureUpdate:        "last_picture_update",
	FailedAttempts:           "failed_attempts",
	Locale:                   "locale",
	Timezone:                 "timezone",
	MfaActive:                "mfa_active",
	MfaSecret:                "mfa_secret",
	CreatedAt:                "created_at",
	UpdatedAt:                "updated_at",
	DeleteAt:                 "delete_at",
	IsActive:                 "is_active",
	Note:                     "note",
	JWTTokenKey:              "jwt_token_key",
	LastActivityAt:           "last_activity_at",
	TermsOfServiceID:         "terms_of_service_id",
	TermsOfServiceCreatedAt:  "terms_of_service_created_at",
	DisableWelcomeEmail:      "disable_welcome_email",
	Metadata:                 "metadata",
	PrivateMetadata:          "private_metadata",
}

var UserTableColumns = struct {
	ID                       string
	Email                    string
	Username                 string
	FirstName                string
	LastName                 string
	DefaultShippingAddressID string
	DefaultBillingAddressID  string
	Password                 string
	AuthData                 string
	AuthService              string
	EmailVerified            string
	Nickname                 string
	Roles                    string
	Props                    string
	NotifyProps              string
	LastPasswordUpdate       string
	LastPictureUpdate        string
	FailedAttempts           string
	Locale                   string
	Timezone                 string
	MfaActive                string
	MfaSecret                string
	CreatedAt                string
	UpdatedAt                string
	DeleteAt                 string
	IsActive                 string
	Note                     string
	JWTTokenKey              string
	LastActivityAt           string
	TermsOfServiceID         string
	TermsOfServiceCreatedAt  string
	DisableWelcomeEmail      string
	Metadata                 string
	PrivateMetadata          string
}{
	ID:                       "users.id",
	Email:                    "users.email",
	Username:                 "users.username",
	FirstName:                "users.first_name",
	LastName:                 "users.last_name",
	DefaultShippingAddressID: "users.default_shipping_address_id",
	DefaultBillingAddressID:  "users.default_billing_address_id",
	Password:                 "users.password",
	AuthData:                 "users.auth_data",
	AuthService:              "users.auth_service",
	EmailVerified:            "users.email_verified",
	Nickname:                 "users.nickname",
	Roles:                    "users.roles",
	Props:                    "users.props",
	NotifyProps:              "users.notify_props",
	LastPasswordUpdate:       "users.last_password_update",
	LastPictureUpdate:        "users.last_picture_update",
	FailedAttempts:           "users.failed_attempts",
	Locale:                   "users.locale",
	Timezone:                 "users.timezone",
	MfaActive:                "users.mfa_active",
	MfaSecret:                "users.mfa_secret",
	CreatedAt:                "users.created_at",
	UpdatedAt:                "users.updated_at",
	DeleteAt:                 "users.delete_at",
	IsActive:                 "users.is_active",
	Note:                     "users.note",
	JWTTokenKey:              "users.jwt_token_key",
	LastActivityAt:           "users.last_activity_at",
	TermsOfServiceID:         "users.terms_of_service_id",
	TermsOfServiceCreatedAt:  "users.terms_of_service_created_at",
	DisableWelcomeEmail:      "users.disable_welcome_email",
	Metadata:                 "users.metadata",
	PrivateMetadata:          "users.private_metadata",
}

// Generated where

var UserWhere = struct {
	ID                       whereHelperstring
	Email                    whereHelperstring
	Username                 whereHelperstring
	FirstName                whereHelperstring
	LastName                 whereHelperstring
	DefaultShippingAddressID whereHelpermodel_types_NullString
	DefaultBillingAddressID  whereHelpermodel_types_NullString
	Password                 whereHelperstring
	AuthData                 whereHelpermodel_types_NullString
	AuthService              whereHelperstring
	EmailVerified            whereHelperbool
	Nickname                 whereHelperstring
	Roles                    whereHelperstring
	Props                    whereHelpermodel_types_JSONString
	NotifyProps              whereHelpermodel_types_JSONString
	LastPasswordUpdate       whereHelperint64
	LastPictureUpdate        whereHelperint64
	FailedAttempts           whereHelperint
	Locale                   whereHelperLanguageCode
	Timezone                 whereHelpermodel_types_JSONString
	MfaActive                whereHelperbool
	MfaSecret                whereHelperstring
	CreatedAt                whereHelperint64
	UpdatedAt                whereHelperint64
	DeleteAt                 whereHelperint64
	IsActive                 whereHelperbool
	Note                     whereHelpermodel_types_NullString
	JWTTokenKey              whereHelperstring
	LastActivityAt           whereHelperint64
	TermsOfServiceID         whereHelperstring
	TermsOfServiceCreatedAt  whereHelperint64
	DisableWelcomeEmail      whereHelperbool
	Metadata                 whereHelpermodel_types_JSONString
	PrivateMetadata          whereHelpermodel_types_JSONString
}{
	ID:                       whereHelperstring{field: "\"users\".\"id\""},
	Email:                    whereHelperstring{field: "\"users\".\"email\""},
	Username:                 whereHelperstring{field: "\"users\".\"username\""},
	FirstName:                whereHelperstring{field: "\"users\".\"first_name\""},
	LastName:                 whereHelperstring{field: "\"users\".\"last_name\""},
	DefaultShippingAddressID: whereHelpermodel_types_NullString{field: "\"users\".\"default_shipping_address_id\""},
	DefaultBillingAddressID:  whereHelpermodel_types_NullString{field: "\"users\".\"default_billing_address_id\""},
	Password:                 whereHelperstring{field: "\"users\".\"password\""},
	AuthData:                 whereHelpermodel_types_NullString{field: "\"users\".\"auth_data\""},
	AuthService:              whereHelperstring{field: "\"users\".\"auth_service\""},
	EmailVerified:            whereHelperbool{field: "\"users\".\"email_verified\""},
	Nickname:                 whereHelperstring{field: "\"users\".\"nickname\""},
	Roles:                    whereHelperstring{field: "\"users\".\"roles\""},
	Props:                    whereHelpermodel_types_JSONString{field: "\"users\".\"props\""},
	NotifyProps:              whereHelpermodel_types_JSONString{field: "\"users\".\"notify_props\""},
	LastPasswordUpdate:       whereHelperint64{field: "\"users\".\"last_password_update\""},
	LastPictureUpdate:        whereHelperint64{field: "\"users\".\"last_picture_update\""},
	FailedAttempts:           whereHelperint{field: "\"users\".\"failed_attempts\""},
	Locale:                   whereHelperLanguageCode{field: "\"users\".\"locale\""},
	Timezone:                 whereHelpermodel_types_JSONString{field: "\"users\".\"timezone\""},
	MfaActive:                whereHelperbool{field: "\"users\".\"mfa_active\""},
	MfaSecret:                whereHelperstring{field: "\"users\".\"mfa_secret\""},
	CreatedAt:                whereHelperint64{field: "\"users\".\"created_at\""},
	UpdatedAt:                whereHelperint64{field: "\"users\".\"updated_at\""},
	DeleteAt:                 whereHelperint64{field: "\"users\".\"delete_at\""},
	IsActive:                 whereHelperbool{field: "\"users\".\"is_active\""},
	Note:                     whereHelpermodel_types_NullString{field: "\"users\".\"note\""},
	JWTTokenKey:              whereHelperstring{field: "\"users\".\"jwt_token_key\""},
	LastActivityAt:           whereHelperint64{field: "\"users\".\"last_activity_at\""},
	TermsOfServiceID:         whereHelperstring{field: "\"users\".\"terms_of_service_id\""},
	TermsOfServiceCreatedAt:  whereHelperint64{field: "\"users\".\"terms_of_service_created_at\""},
	DisableWelcomeEmail:      whereHelperbool{field: "\"users\".\"disable_welcome_email\""},
	Metadata:                 whereHelpermodel_types_JSONString{field: "\"users\".\"metadata\""},
	PrivateMetadata:          whereHelpermodel_types_JSONString{field: "\"users\".\"private_metadata\""},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	DefaultBillingAddress       string
	DefaultShippingAddress      string
	StaffShopStaff              string
	Wishlist                    string
	Addresses                   string
	Checkouts                   string
	Compliances                 string
	CustomerEvents              string
	CustomerCustomerNotes       string
	CustomerNotes               string
	ExportEvents                string
	ExportFiles                 string
	UsedByGiftcards             string
	CreatedByGiftcards          string
	InvoiceEvents               string
	OrderEvents                 string
	Orders                      string
	StaffNotificationRecipients string
	UserAccessTokens            string
}{
	DefaultBillingAddress:       "DefaultBillingAddress",
	DefaultShippingAddress:      "DefaultShippingAddress",
	StaffShopStaff:              "StaffShopStaff",
	Wishlist:                    "Wishlist",
	Addresses:                   "Addresses",
	Checkouts:                   "Checkouts",
	Compliances:                 "Compliances",
	CustomerEvents:              "CustomerEvents",
	CustomerCustomerNotes:       "CustomerCustomerNotes",
	CustomerNotes:               "CustomerNotes",
	ExportEvents:                "ExportEvents",
	ExportFiles:                 "ExportFiles",
	UsedByGiftcards:             "UsedByGiftcards",
	CreatedByGiftcards:          "CreatedByGiftcards",
	InvoiceEvents:               "InvoiceEvents",
	OrderEvents:                 "OrderEvents",
	Orders:                      "Orders",
	StaffNotificationRecipients: "StaffNotificationRecipients",
	UserAccessTokens:            "UserAccessTokens",
}

// userR is where relationships are stored.
type userR struct {
	DefaultBillingAddress       *Address                        `boil:"DefaultBillingAddress" json:"DefaultBillingAddress" toml:"DefaultBillingAddress" yaml:"DefaultBillingAddress"`
	DefaultShippingAddress      *Address                        `boil:"DefaultShippingAddress" json:"DefaultShippingAddress" toml:"DefaultShippingAddress" yaml:"DefaultShippingAddress"`
	StaffShopStaff              *ShopStaff                      `boil:"StaffShopStaff" json:"StaffShopStaff" toml:"StaffShopStaff" yaml:"StaffShopStaff"`
	Wishlist                    *Wishlist                       `boil:"Wishlist" json:"Wishlist" toml:"Wishlist" yaml:"Wishlist"`
	Addresses                   AddressSlice                    `boil:"Addresses" json:"Addresses" toml:"Addresses" yaml:"Addresses"`
	Checkouts                   CheckoutSlice                   `boil:"Checkouts" json:"Checkouts" toml:"Checkouts" yaml:"Checkouts"`
	Compliances                 ComplianceSlice                 `boil:"Compliances" json:"Compliances" toml:"Compliances" yaml:"Compliances"`
	CustomerEvents              CustomerEventSlice              `boil:"CustomerEvents" json:"CustomerEvents" toml:"CustomerEvents" yaml:"CustomerEvents"`
	CustomerCustomerNotes       CustomerNoteSlice               `boil:"CustomerCustomerNotes" json:"CustomerCustomerNotes" toml:"CustomerCustomerNotes" yaml:"CustomerCustomerNotes"`
	CustomerNotes               CustomerNoteSlice               `boil:"CustomerNotes" json:"CustomerNotes" toml:"CustomerNotes" yaml:"CustomerNotes"`
	ExportEvents                ExportEventSlice                `boil:"ExportEvents" json:"ExportEvents" toml:"ExportEvents" yaml:"ExportEvents"`
	ExportFiles                 ExportFileSlice                 `boil:"ExportFiles" json:"ExportFiles" toml:"ExportFiles" yaml:"ExportFiles"`
	UsedByGiftcards             GiftcardSlice                   `boil:"UsedByGiftcards" json:"UsedByGiftcards" toml:"UsedByGiftcards" yaml:"UsedByGiftcards"`
	CreatedByGiftcards          GiftcardSlice                   `boil:"CreatedByGiftcards" json:"CreatedByGiftcards" toml:"CreatedByGiftcards" yaml:"CreatedByGiftcards"`
	InvoiceEvents               InvoiceEventSlice               `boil:"InvoiceEvents" json:"InvoiceEvents" toml:"InvoiceEvents" yaml:"InvoiceEvents"`
	OrderEvents                 OrderEventSlice                 `boil:"OrderEvents" json:"OrderEvents" toml:"OrderEvents" yaml:"OrderEvents"`
	Orders                      OrderSlice                      `boil:"Orders" json:"Orders" toml:"Orders" yaml:"Orders"`
	StaffNotificationRecipients StaffNotificationRecipientSlice `boil:"StaffNotificationRecipients" json:"StaffNotificationRecipients" toml:"StaffNotificationRecipients" yaml:"StaffNotificationRecipients"`
	UserAccessTokens            UserAccessTokenSlice            `boil:"UserAccessTokens" json:"UserAccessTokens" toml:"UserAccessTokens" yaml:"UserAccessTokens"`
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

func (r *userR) GetDefaultBillingAddress() *Address {
	if r == nil {
		return nil
	}
	return r.DefaultBillingAddress
}

func (r *userR) GetDefaultShippingAddress() *Address {
	if r == nil {
		return nil
	}
	return r.DefaultShippingAddress
}

func (r *userR) GetStaffShopStaff() *ShopStaff {
	if r == nil {
		return nil
	}
	return r.StaffShopStaff
}

func (r *userR) GetWishlist() *Wishlist {
	if r == nil {
		return nil
	}
	return r.Wishlist
}

func (r *userR) GetAddresses() AddressSlice {
	if r == nil {
		return nil
	}
	return r.Addresses
}

func (r *userR) GetCheckouts() CheckoutSlice {
	if r == nil {
		return nil
	}
	return r.Checkouts
}

func (r *userR) GetCompliances() ComplianceSlice {
	if r == nil {
		return nil
	}
	return r.Compliances
}

func (r *userR) GetCustomerEvents() CustomerEventSlice {
	if r == nil {
		return nil
	}
	return r.CustomerEvents
}

func (r *userR) GetCustomerCustomerNotes() CustomerNoteSlice {
	if r == nil {
		return nil
	}
	return r.CustomerCustomerNotes
}

func (r *userR) GetCustomerNotes() CustomerNoteSlice {
	if r == nil {
		return nil
	}
	return r.CustomerNotes
}

func (r *userR) GetExportEvents() ExportEventSlice {
	if r == nil {
		return nil
	}
	return r.ExportEvents
}

func (r *userR) GetExportFiles() ExportFileSlice {
	if r == nil {
		return nil
	}
	return r.ExportFiles
}

func (r *userR) GetUsedByGiftcards() GiftcardSlice {
	if r == nil {
		return nil
	}
	return r.UsedByGiftcards
}

func (r *userR) GetCreatedByGiftcards() GiftcardSlice {
	if r == nil {
		return nil
	}
	return r.CreatedByGiftcards
}

func (r *userR) GetInvoiceEvents() InvoiceEventSlice {
	if r == nil {
		return nil
	}
	return r.InvoiceEvents
}

func (r *userR) GetOrderEvents() OrderEventSlice {
	if r == nil {
		return nil
	}
	return r.OrderEvents
}

func (r *userR) GetOrders() OrderSlice {
	if r == nil {
		return nil
	}
	return r.Orders
}

func (r *userR) GetStaffNotificationRecipients() StaffNotificationRecipientSlice {
	if r == nil {
		return nil
	}
	return r.StaffNotificationRecipients
}

func (r *userR) GetUserAccessTokens() UserAccessTokenSlice {
	if r == nil {
		return nil
	}
	return r.UserAccessTokens
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"id", "email", "username", "first_name", "last_name", "default_shipping_address_id", "default_billing_address_id", "password", "auth_data", "auth_service", "email_verified", "nickname", "roles", "props", "notify_props", "last_password_update", "last_picture_update", "failed_attempts", "locale", "timezone", "mfa_active", "mfa_secret", "created_at", "updated_at", "delete_at", "is_active", "note", "jwt_token_key", "last_activity_at", "terms_of_service_id", "terms_of_service_created_at", "disable_welcome_email", "metadata", "private_metadata"}
	userColumnsWithoutDefault = []string{"id", "email", "username", "first_name", "last_name", "password", "auth_service", "email_verified", "nickname", "roles", "last_password_update", "last_picture_update", "failed_attempts", "locale", "mfa_active", "mfa_secret", "created_at", "updated_at", "delete_at", "is_active", "jwt_token_key", "last_activity_at", "terms_of_service_id", "terms_of_service_created_at", "disable_welcome_email"}
	userColumnsWithDefault    = []string{"default_shipping_address_id", "default_billing_address_id", "auth_data", "props", "notify_props", "timezone", "note", "metadata", "private_metadata"}
	userPrimaryKeyColumns     = []string{"id"}
	userGeneratedColumns      = []string{}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should almost always be used instead of []User.
	UserSlice []*User

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single user record from the query.
func (q userQuery) One(exec boil.Executor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for users")
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(exec boil.Executor) (UserSlice, error) {
	var o []*User

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to User slice")
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count users rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if users exists")
	}

	return count > 0, nil
}

// DefaultBillingAddress pointed to by the foreign key.
func (o *User) DefaultBillingAddress(mods ...qm.QueryMod) addressQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DefaultBillingAddressID),
	}

	queryMods = append(queryMods, mods...)

	return Addresses(queryMods...)
}

// DefaultShippingAddress pointed to by the foreign key.
func (o *User) DefaultShippingAddress(mods ...qm.QueryMod) addressQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.DefaultShippingAddressID),
	}

	queryMods = append(queryMods, mods...)

	return Addresses(queryMods...)
}

// StaffShopStaff pointed to by the foreign key.
func (o *User) StaffShopStaff(mods ...qm.QueryMod) shopStaffQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"staff_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return ShopStaffs(queryMods...)
}

// Wishlist pointed to by the foreign key.
func (o *User) Wishlist(mods ...qm.QueryMod) wishlistQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"user_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return Wishlists(queryMods...)
}

// Addresses retrieves all the address's Addresses with an executor.
func (o *User) Addresses(mods ...qm.QueryMod) addressQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"addresses\".\"user_id\"=?", o.ID),
	)

	return Addresses(queryMods...)
}

// Checkouts retrieves all the checkout's Checkouts with an executor.
func (o *User) Checkouts(mods ...qm.QueryMod) checkoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"checkouts\".\"user_id\"=?", o.ID),
	)

	return Checkouts(queryMods...)
}

// Compliances retrieves all the compliance's Compliances with an executor.
func (o *User) Compliances(mods ...qm.QueryMod) complianceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"compliances\".\"user_id\"=?", o.ID),
	)

	return Compliances(queryMods...)
}

// CustomerEvents retrieves all the customer_event's CustomerEvents with an executor.
func (o *User) CustomerEvents(mods ...qm.QueryMod) customerEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"customer_events\".\"user_id\"=?", o.ID),
	)

	return CustomerEvents(queryMods...)
}

// CustomerCustomerNotes retrieves all the customer_note's CustomerNotes with an executor via customer_id column.
func (o *User) CustomerCustomerNotes(mods ...qm.QueryMod) customerNoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"customer_notes\".\"customer_id\"=?", o.ID),
	)

	return CustomerNotes(queryMods...)
}

// CustomerNotes retrieves all the customer_note's CustomerNotes with an executor.
func (o *User) CustomerNotes(mods ...qm.QueryMod) customerNoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"customer_notes\".\"user_id\"=?", o.ID),
	)

	return CustomerNotes(queryMods...)
}

// ExportEvents retrieves all the export_event's ExportEvents with an executor.
func (o *User) ExportEvents(mods ...qm.QueryMod) exportEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"export_events\".\"user_id\"=?", o.ID),
	)

	return ExportEvents(queryMods...)
}

// ExportFiles retrieves all the export_file's ExportFiles with an executor.
func (o *User) ExportFiles(mods ...qm.QueryMod) exportFileQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"export_files\".\"user_id\"=?", o.ID),
	)

	return ExportFiles(queryMods...)
}

// UsedByGiftcards retrieves all the giftcard's Giftcards with an executor via used_by_id column.
func (o *User) UsedByGiftcards(mods ...qm.QueryMod) giftcardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"giftcards\".\"used_by_id\"=?", o.ID),
	)

	return Giftcards(queryMods...)
}

// CreatedByGiftcards retrieves all the giftcard's Giftcards with an executor via created_by_id column.
func (o *User) CreatedByGiftcards(mods ...qm.QueryMod) giftcardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"giftcards\".\"created_by_id\"=?", o.ID),
	)

	return Giftcards(queryMods...)
}

// InvoiceEvents retrieves all the invoice_event's InvoiceEvents with an executor.
func (o *User) InvoiceEvents(mods ...qm.QueryMod) invoiceEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"invoice_events\".\"user_id\"=?", o.ID),
	)

	return InvoiceEvents(queryMods...)
}

// OrderEvents retrieves all the order_event's OrderEvents with an executor.
func (o *User) OrderEvents(mods ...qm.QueryMod) orderEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"order_events\".\"user_id\"=?", o.ID),
	)

	return OrderEvents(queryMods...)
}

// Orders retrieves all the order's Orders with an executor.
func (o *User) Orders(mods ...qm.QueryMod) orderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"orders\".\"user_id\"=?", o.ID),
	)

	return Orders(queryMods...)
}

// StaffNotificationRecipients retrieves all the staff_notification_recipient's StaffNotificationRecipients with an executor.
func (o *User) StaffNotificationRecipients(mods ...qm.QueryMod) staffNotificationRecipientQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"staff_notification_recipients\".\"user_id\"=?", o.ID),
	)

	return StaffNotificationRecipients(queryMods...)
}

// UserAccessTokens retrieves all the user_access_token's UserAccessTokens with an executor.
func (o *User) UserAccessTokens(mods ...qm.QueryMod) userAccessTokenQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_access_tokens\".\"user_id\"=?", o.ID),
	)

	return UserAccessTokens(queryMods...)
}

// LoadDefaultBillingAddress allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadDefaultBillingAddress(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.DefaultBillingAddressID) {
			args[object.DefaultBillingAddressID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			if !queries.IsNil(obj.DefaultBillingAddressID) {
				args[obj.DefaultBillingAddressID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`addresses`),
		qm.WhereIn(`addresses.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Address")
	}

	var resultSlice []*Address
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Address")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for addresses")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for addresses")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DefaultBillingAddress = foreign
		if foreign.R == nil {
			foreign.R = &addressR{}
		}
		foreign.R.DefaultBillingAddressUsers = append(foreign.R.DefaultBillingAddressUsers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DefaultBillingAddressID, foreign.ID) {
				local.R.DefaultBillingAddress = foreign
				if foreign.R == nil {
					foreign.R = &addressR{}
				}
				foreign.R.DefaultBillingAddressUsers = append(foreign.R.DefaultBillingAddressUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadDefaultShippingAddress allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadDefaultShippingAddress(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.DefaultShippingAddressID) {
			args[object.DefaultShippingAddressID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			if !queries.IsNil(obj.DefaultShippingAddressID) {
				args[obj.DefaultShippingAddressID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`addresses`),
		qm.WhereIn(`addresses.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Address")
	}

	var resultSlice []*Address
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Address")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for addresses")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for addresses")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DefaultShippingAddress = foreign
		if foreign.R == nil {
			foreign.R = &addressR{}
		}
		foreign.R.DefaultShippingAddressUsers = append(foreign.R.DefaultShippingAddressUsers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DefaultShippingAddressID, foreign.ID) {
				local.R.DefaultShippingAddress = foreign
				if foreign.R == nil {
					foreign.R = &addressR{}
				}
				foreign.R.DefaultShippingAddressUsers = append(foreign.R.DefaultShippingAddressUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadStaffShopStaff allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadStaffShopStaff(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`shop_staffs`),
		qm.WhereIn(`shop_staffs.staff_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ShopStaff")
	}

	var resultSlice []*ShopStaff
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ShopStaff")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for shop_staffs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for shop_staffs")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.StaffShopStaff = foreign
		if foreign.R == nil {
			foreign.R = &shopStaffR{}
		}
		foreign.R.Staff = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.StaffID {
				local.R.StaffShopStaff = foreign
				if foreign.R == nil {
					foreign.R = &shopStaffR{}
				}
				foreign.R.Staff = local
				break
			}
		}
	}

	return nil
}

// LoadWishlist allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadWishlist(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`wishlists`),
		qm.WhereIn(`wishlists.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Wishlist")
	}

	var resultSlice []*Wishlist
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Wishlist")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for wishlists")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wishlists")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Wishlist = foreign
		if foreign.R == nil {
			foreign.R = &wishlistR{}
		}
		foreign.R.User = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.UserID {
				local.R.Wishlist = foreign
				if foreign.R == nil {
					foreign.R = &wishlistR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadAddresses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadAddresses(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`addresses`),
		qm.WhereIn(`addresses.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load addresses")
	}

	var resultSlice []*Address
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice addresses")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on addresses")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for addresses")
	}

	if singular {
		object.R.Addresses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &addressR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Addresses = append(local.R.Addresses, foreign)
				if foreign.R == nil {
					foreign.R = &addressR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCheckouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCheckouts(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`checkouts`),
		qm.WhereIn(`checkouts.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load checkouts")
	}

	var resultSlice []*Checkout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice checkouts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on checkouts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for checkouts")
	}

	if singular {
		object.R.Checkouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &checkoutR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.Checkouts = append(local.R.Checkouts, foreign)
				if foreign.R == nil {
					foreign.R = &checkoutR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCompliances allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCompliances(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`compliances`),
		qm.WhereIn(`compliances.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load compliances")
	}

	var resultSlice []*Compliance
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice compliances")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on compliances")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for compliances")
	}

	if singular {
		object.R.Compliances = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &complianceR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Compliances = append(local.R.Compliances, foreign)
				if foreign.R == nil {
					foreign.R = &complianceR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCustomerEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCustomerEvents(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`customer_events`),
		qm.WhereIn(`customer_events.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_events")
	}

	var resultSlice []*CustomerEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_events")
	}

	if singular {
		object.R.CustomerEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerEventR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.CustomerEvents = append(local.R.CustomerEvents, foreign)
				if foreign.R == nil {
					foreign.R = &customerEventR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCustomerCustomerNotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCustomerCustomerNotes(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`customer_notes`),
		qm.WhereIn(`customer_notes.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_notes")
	}

	var resultSlice []*CustomerNote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_notes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_notes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_notes")
	}

	if singular {
		object.R.CustomerCustomerNotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerNoteR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.CustomerCustomerNotes = append(local.R.CustomerCustomerNotes, foreign)
				if foreign.R == nil {
					foreign.R = &customerNoteR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadCustomerNotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCustomerNotes(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`customer_notes`),
		qm.WhereIn(`customer_notes.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_notes")
	}

	var resultSlice []*CustomerNote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_notes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_notes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_notes")
	}

	if singular {
		object.R.CustomerNotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerNoteR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.CustomerNotes = append(local.R.CustomerNotes, foreign)
				if foreign.R == nil {
					foreign.R = &customerNoteR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadExportEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadExportEvents(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`export_events`),
		qm.WhereIn(`export_events.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load export_events")
	}

	var resultSlice []*ExportEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice export_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on export_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for export_events")
	}

	if singular {
		object.R.ExportEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &exportEventR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.ExportEvents = append(local.R.ExportEvents, foreign)
				if foreign.R == nil {
					foreign.R = &exportEventR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadExportFiles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadExportFiles(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`export_files`),
		qm.WhereIn(`export_files.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load export_files")
	}

	var resultSlice []*ExportFile
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice export_files")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on export_files")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for export_files")
	}

	if singular {
		object.R.ExportFiles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &exportFileR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.ExportFiles = append(local.R.ExportFiles, foreign)
				if foreign.R == nil {
					foreign.R = &exportFileR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUsedByGiftcards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUsedByGiftcards(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`giftcards`),
		qm.WhereIn(`giftcards.used_by_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load giftcards")
	}

	var resultSlice []*Giftcard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice giftcards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on giftcards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for giftcards")
	}

	if singular {
		object.R.UsedByGiftcards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &giftcardR{}
			}
			foreign.R.UsedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UsedByID) {
				local.R.UsedByGiftcards = append(local.R.UsedByGiftcards, foreign)
				if foreign.R == nil {
					foreign.R = &giftcardR{}
				}
				foreign.R.UsedBy = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByGiftcards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByGiftcards(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`giftcards`),
		qm.WhereIn(`giftcards.created_by_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load giftcards")
	}

	var resultSlice []*Giftcard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice giftcards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on giftcards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for giftcards")
	}

	if singular {
		object.R.CreatedByGiftcards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &giftcardR{}
			}
			foreign.R.CreatedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatedByID) {
				local.R.CreatedByGiftcards = append(local.R.CreatedByGiftcards, foreign)
				if foreign.R == nil {
					foreign.R = &giftcardR{}
				}
				foreign.R.CreatedBy = local
				break
			}
		}
	}

	return nil
}

// LoadInvoiceEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadInvoiceEvents(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`invoice_events`),
		qm.WhereIn(`invoice_events.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load invoice_events")
	}

	var resultSlice []*InvoiceEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice invoice_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on invoice_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for invoice_events")
	}

	if singular {
		object.R.InvoiceEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &invoiceEventR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.InvoiceEvents = append(local.R.InvoiceEvents, foreign)
				if foreign.R == nil {
					foreign.R = &invoiceEventR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadOrderEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadOrderEvents(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`order_events`),
		qm.WhereIn(`order_events.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load order_events")
	}

	var resultSlice []*OrderEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice order_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on order_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for order_events")
	}

	if singular {
		object.R.OrderEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderEventR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.OrderEvents = append(local.R.OrderEvents, foreign)
				if foreign.R == nil {
					foreign.R = &orderEventR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadOrders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadOrders(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`orders`),
		qm.WhereIn(`orders.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load orders")
	}

	var resultSlice []*Order
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice orders")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on orders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orders")
	}

	if singular {
		object.R.Orders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.Orders = append(local.R.Orders, foreign)
				if foreign.R == nil {
					foreign.R = &orderR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadStaffNotificationRecipients allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadStaffNotificationRecipients(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`staff_notification_recipients`),
		qm.WhereIn(`staff_notification_recipients.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load staff_notification_recipients")
	}

	var resultSlice []*StaffNotificationRecipient
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice staff_notification_recipients")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on staff_notification_recipients")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for staff_notification_recipients")
	}

	if singular {
		object.R.StaffNotificationRecipients = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &staffNotificationRecipientR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserID) {
				local.R.StaffNotificationRecipients = append(local.R.StaffNotificationRecipients, foreign)
				if foreign.R == nil {
					foreign.R = &staffNotificationRecipientR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserAccessTokens allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserAccessTokens(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_access_tokens`),
		qm.WhereIn(`user_access_tokens.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_access_tokens")
	}

	var resultSlice []*UserAccessToken
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_access_tokens")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_access_tokens")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_access_tokens")
	}

	if singular {
		object.R.UserAccessTokens = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAccessTokenR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserAccessTokens = append(local.R.UserAccessTokens, foreign)
				if foreign.R == nil {
					foreign.R = &userAccessTokenR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// SetDefaultBillingAddress of the user to the related item.
// Sets o.R.DefaultBillingAddress to related.
// Adds o to related.R.DefaultBillingAddressUsers.
func (o *User) SetDefaultBillingAddress(exec boil.Executor, insert bool, related *Address) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"default_billing_address_id"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DefaultBillingAddressID, related.ID)
	if o.R == nil {
		o.R = &userR{
			DefaultBillingAddress: related,
		}
	} else {
		o.R.DefaultBillingAddress = related
	}

	if related.R == nil {
		related.R = &addressR{
			DefaultBillingAddressUsers: UserSlice{o},
		}
	} else {
		related.R.DefaultBillingAddressUsers = append(related.R.DefaultBillingAddressUsers, o)
	}

	return nil
}

// RemoveDefaultBillingAddress relationship.
// Sets o.R.DefaultBillingAddress to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveDefaultBillingAddress(exec boil.Executor, related *Address) error {
	var err error

	queries.SetScanner(&o.DefaultBillingAddressID, nil)
	if _, err = o.Update(exec, boil.Whitelist("default_billing_address_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DefaultBillingAddress = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DefaultBillingAddressUsers {
		if queries.Equal(o.DefaultBillingAddressID, ri.DefaultBillingAddressID) {
			continue
		}

		ln := len(related.R.DefaultBillingAddressUsers)
		if ln > 1 && i < ln-1 {
			related.R.DefaultBillingAddressUsers[i] = related.R.DefaultBillingAddressUsers[ln-1]
		}
		related.R.DefaultBillingAddressUsers = related.R.DefaultBillingAddressUsers[:ln-1]
		break
	}
	return nil
}

// SetDefaultShippingAddress of the user to the related item.
// Sets o.R.DefaultShippingAddress to related.
// Adds o to related.R.DefaultShippingAddressUsers.
func (o *User) SetDefaultShippingAddress(exec boil.Executor, insert bool, related *Address) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"default_shipping_address_id"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DefaultShippingAddressID, related.ID)
	if o.R == nil {
		o.R = &userR{
			DefaultShippingAddress: related,
		}
	} else {
		o.R.DefaultShippingAddress = related
	}

	if related.R == nil {
		related.R = &addressR{
			DefaultShippingAddressUsers: UserSlice{o},
		}
	} else {
		related.R.DefaultShippingAddressUsers = append(related.R.DefaultShippingAddressUsers, o)
	}

	return nil
}

// RemoveDefaultShippingAddress relationship.
// Sets o.R.DefaultShippingAddress to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveDefaultShippingAddress(exec boil.Executor, related *Address) error {
	var err error

	queries.SetScanner(&o.DefaultShippingAddressID, nil)
	if _, err = o.Update(exec, boil.Whitelist("default_shipping_address_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DefaultShippingAddress = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DefaultShippingAddressUsers {
		if queries.Equal(o.DefaultShippingAddressID, ri.DefaultShippingAddressID) {
			continue
		}

		ln := len(related.R.DefaultShippingAddressUsers)
		if ln > 1 && i < ln-1 {
			related.R.DefaultShippingAddressUsers[i] = related.R.DefaultShippingAddressUsers[ln-1]
		}
		related.R.DefaultShippingAddressUsers = related.R.DefaultShippingAddressUsers[:ln-1]
		break
	}
	return nil
}

// SetStaffShopStaff of the user to the related item.
// Sets o.R.StaffShopStaff to related.
// Adds o to related.R.Staff.
func (o *User) SetStaffShopStaff(exec boil.Executor, insert bool, related *ShopStaff) error {
	var err error

	if insert {
		related.StaffID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"shop_staffs\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"staff_id"}),
			strmangle.WhereClause("\"", "\"", 2, shopStaffPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.StaffID = o.ID
	}

	if o.R == nil {
		o.R = &userR{
			StaffShopStaff: related,
		}
	} else {
		o.R.StaffShopStaff = related
	}

	if related.R == nil {
		related.R = &shopStaffR{
			Staff: o,
		}
	} else {
		related.R.Staff = o
	}
	return nil
}

// SetWishlist of the user to the related item.
// Sets o.R.Wishlist to related.
// Adds o to related.R.User.
func (o *User) SetWishlist(exec boil.Executor, insert bool, related *Wishlist) error {
	var err error

	if insert {
		related.UserID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"wishlists\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
			strmangle.WhereClause("\"", "\"", 2, wishlistPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.UserID = o.ID
	}

	if o.R == nil {
		o.R = &userR{
			Wishlist: related,
		}
	} else {
		o.R.Wishlist = related
	}

	if related.R == nil {
		related.R = &wishlistR{
			User: o,
		}
	} else {
		related.R.User = o
	}
	return nil
}

// AddAddresses adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Addresses.
// Sets related.R.User appropriately.
func (o *User) AddAddresses(exec boil.Executor, insert bool, related ...*Address) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"addresses\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, addressPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Addresses: related,
		}
	} else {
		o.R.Addresses = append(o.R.Addresses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &addressR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddCheckouts adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Checkouts.
// Sets related.R.User appropriately.
func (o *User) AddCheckouts(exec boil.Executor, insert bool, related ...*Checkout) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"checkouts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, checkoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.Token}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			Checkouts: related,
		}
	} else {
		o.R.Checkouts = append(o.R.Checkouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &checkoutR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetCheckouts removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's Checkouts accordingly.
// Replaces o.R.Checkouts with related.
// Sets related.R.User's Checkouts accordingly.
func (o *User) SetCheckouts(exec boil.Executor, insert bool, related ...*Checkout) error {
	query := "update \"checkouts\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Checkouts {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.Checkouts = nil
	}

	return o.AddCheckouts(exec, insert, related...)
}

// RemoveCheckouts relationships from objects passed in.
// Removes related items from R.Checkouts (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveCheckouts(exec boil.Executor, related ...*Checkout) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Checkouts {
			if rel != ri {
				continue
			}

			ln := len(o.R.Checkouts)
			if ln > 1 && i < ln-1 {
				o.R.Checkouts[i] = o.R.Checkouts[ln-1]
			}
			o.R.Checkouts = o.R.Checkouts[:ln-1]
			break
		}
	}

	return nil
}

// AddCompliances adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Compliances.
// Sets related.R.User appropriately.
func (o *User) AddCompliances(exec boil.Executor, insert bool, related ...*Compliance) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"compliances\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, compliancePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Compliances: related,
		}
	} else {
		o.R.Compliances = append(o.R.Compliances, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &complianceR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddCustomerEvents adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CustomerEvents.
// Sets related.R.User appropriately.
func (o *User) AddCustomerEvents(exec boil.Executor, insert bool, related ...*CustomerEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"customer_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, customerEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CustomerEvents: related,
		}
	} else {
		o.R.CustomerEvents = append(o.R.CustomerEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerEventR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetCustomerEvents removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's CustomerEvents accordingly.
// Replaces o.R.CustomerEvents with related.
// Sets related.R.User's CustomerEvents accordingly.
func (o *User) SetCustomerEvents(exec boil.Executor, insert bool, related ...*CustomerEvent) error {
	query := "update \"customer_events\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CustomerEvents {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.CustomerEvents = nil
	}

	return o.AddCustomerEvents(exec, insert, related...)
}

// RemoveCustomerEvents relationships from objects passed in.
// Removes related items from R.CustomerEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveCustomerEvents(exec boil.Executor, related ...*CustomerEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CustomerEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.CustomerEvents)
			if ln > 1 && i < ln-1 {
				o.R.CustomerEvents[i] = o.R.CustomerEvents[ln-1]
			}
			o.R.CustomerEvents = o.R.CustomerEvents[:ln-1]
			break
		}
	}

	return nil
}

// AddCustomerCustomerNotes adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CustomerCustomerNotes.
// Sets related.R.Customer appropriately.
func (o *User) AddCustomerCustomerNotes(exec boil.Executor, insert bool, related ...*CustomerNote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"customer_notes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, customerNotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			CustomerCustomerNotes: related,
		}
	} else {
		o.R.CustomerCustomerNotes = append(o.R.CustomerCustomerNotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerNoteR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// AddCustomerNotes adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CustomerNotes.
// Sets related.R.User appropriately.
func (o *User) AddCustomerNotes(exec boil.Executor, insert bool, related ...*CustomerNote) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"customer_notes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, customerNotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CustomerNotes: related,
		}
	} else {
		o.R.CustomerNotes = append(o.R.CustomerNotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerNoteR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetCustomerNotes removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's CustomerNotes accordingly.
// Replaces o.R.CustomerNotes with related.
// Sets related.R.User's CustomerNotes accordingly.
func (o *User) SetCustomerNotes(exec boil.Executor, insert bool, related ...*CustomerNote) error {
	query := "update \"customer_notes\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CustomerNotes {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.CustomerNotes = nil
	}

	return o.AddCustomerNotes(exec, insert, related...)
}

// RemoveCustomerNotes relationships from objects passed in.
// Removes related items from R.CustomerNotes (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveCustomerNotes(exec boil.Executor, related ...*CustomerNote) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CustomerNotes {
			if rel != ri {
				continue
			}

			ln := len(o.R.CustomerNotes)
			if ln > 1 && i < ln-1 {
				o.R.CustomerNotes[i] = o.R.CustomerNotes[ln-1]
			}
			o.R.CustomerNotes = o.R.CustomerNotes[:ln-1]
			break
		}
	}

	return nil
}

// AddExportEvents adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ExportEvents.
// Sets related.R.User appropriately.
func (o *User) AddExportEvents(exec boil.Executor, insert bool, related ...*ExportEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"export_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, exportEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			ExportEvents: related,
		}
	} else {
		o.R.ExportEvents = append(o.R.ExportEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &exportEventR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetExportEvents removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's ExportEvents accordingly.
// Replaces o.R.ExportEvents with related.
// Sets related.R.User's ExportEvents accordingly.
func (o *User) SetExportEvents(exec boil.Executor, insert bool, related ...*ExportEvent) error {
	query := "update \"export_events\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ExportEvents {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.ExportEvents = nil
	}

	return o.AddExportEvents(exec, insert, related...)
}

// RemoveExportEvents relationships from objects passed in.
// Removes related items from R.ExportEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveExportEvents(exec boil.Executor, related ...*ExportEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ExportEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.ExportEvents)
			if ln > 1 && i < ln-1 {
				o.R.ExportEvents[i] = o.R.ExportEvents[ln-1]
			}
			o.R.ExportEvents = o.R.ExportEvents[:ln-1]
			break
		}
	}

	return nil
}

// AddExportFiles adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ExportFiles.
// Sets related.R.User appropriately.
func (o *User) AddExportFiles(exec boil.Executor, insert bool, related ...*ExportFile) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"export_files\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, exportFilePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			ExportFiles: related,
		}
	} else {
		o.R.ExportFiles = append(o.R.ExportFiles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &exportFileR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetExportFiles removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's ExportFiles accordingly.
// Replaces o.R.ExportFiles with related.
// Sets related.R.User's ExportFiles accordingly.
func (o *User) SetExportFiles(exec boil.Executor, insert bool, related ...*ExportFile) error {
	query := "update \"export_files\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ExportFiles {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.ExportFiles = nil
	}

	return o.AddExportFiles(exec, insert, related...)
}

// RemoveExportFiles relationships from objects passed in.
// Removes related items from R.ExportFiles (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveExportFiles(exec boil.Executor, related ...*ExportFile) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ExportFiles {
			if rel != ri {
				continue
			}

			ln := len(o.R.ExportFiles)
			if ln > 1 && i < ln-1 {
				o.R.ExportFiles[i] = o.R.ExportFiles[ln-1]
			}
			o.R.ExportFiles = o.R.ExportFiles[:ln-1]
			break
		}
	}

	return nil
}

// AddUsedByGiftcards adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UsedByGiftcards.
// Sets related.R.UsedBy appropriately.
func (o *User) AddUsedByGiftcards(exec boil.Executor, insert bool, related ...*Giftcard) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UsedByID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"giftcards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"used_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, giftcardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UsedByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UsedByGiftcards: related,
		}
	} else {
		o.R.UsedByGiftcards = append(o.R.UsedByGiftcards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &giftcardR{
				UsedBy: o,
			}
		} else {
			rel.R.UsedBy = o
		}
	}
	return nil
}

// SetUsedByGiftcards removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UsedBy's UsedByGiftcards accordingly.
// Replaces o.R.UsedByGiftcards with related.
// Sets related.R.UsedBy's UsedByGiftcards accordingly.
func (o *User) SetUsedByGiftcards(exec boil.Executor, insert bool, related ...*Giftcard) error {
	query := "update \"giftcards\" set \"used_by_id\" = null where \"used_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UsedByGiftcards {
			queries.SetScanner(&rel.UsedByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UsedBy = nil
		}
		o.R.UsedByGiftcards = nil
	}

	return o.AddUsedByGiftcards(exec, insert, related...)
}

// RemoveUsedByGiftcards relationships from objects passed in.
// Removes related items from R.UsedByGiftcards (uses pointer comparison, removal does not keep order)
// Sets related.R.UsedBy.
func (o *User) RemoveUsedByGiftcards(exec boil.Executor, related ...*Giftcard) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UsedByID, nil)
		if rel.R != nil {
			rel.R.UsedBy = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("used_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UsedByGiftcards {
			if rel != ri {
				continue
			}

			ln := len(o.R.UsedByGiftcards)
			if ln > 1 && i < ln-1 {
				o.R.UsedByGiftcards[i] = o.R.UsedByGiftcards[ln-1]
			}
			o.R.UsedByGiftcards = o.R.UsedByGiftcards[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatedByGiftcards adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByGiftcards.
// Sets related.R.CreatedBy appropriately.
func (o *User) AddCreatedByGiftcards(exec boil.Executor, insert bool, related ...*Giftcard) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatedByID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"giftcards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, giftcardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatedByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByGiftcards: related,
		}
	} else {
		o.R.CreatedByGiftcards = append(o.R.CreatedByGiftcards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &giftcardR{
				CreatedBy: o,
			}
		} else {
			rel.R.CreatedBy = o
		}
	}
	return nil
}

// SetCreatedByGiftcards removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CreatedBy's CreatedByGiftcards accordingly.
// Replaces o.R.CreatedByGiftcards with related.
// Sets related.R.CreatedBy's CreatedByGiftcards accordingly.
func (o *User) SetCreatedByGiftcards(exec boil.Executor, insert bool, related ...*Giftcard) error {
	query := "update \"giftcards\" set \"created_by_id\" = null where \"created_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatedByGiftcards {
			queries.SetScanner(&rel.CreatedByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CreatedBy = nil
		}
		o.R.CreatedByGiftcards = nil
	}

	return o.AddCreatedByGiftcards(exec, insert, related...)
}

// RemoveCreatedByGiftcards relationships from objects passed in.
// Removes related items from R.CreatedByGiftcards (uses pointer comparison, removal does not keep order)
// Sets related.R.CreatedBy.
func (o *User) RemoveCreatedByGiftcards(exec boil.Executor, related ...*Giftcard) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatedByID, nil)
		if rel.R != nil {
			rel.R.CreatedBy = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("created_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatedByGiftcards {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatedByGiftcards)
			if ln > 1 && i < ln-1 {
				o.R.CreatedByGiftcards[i] = o.R.CreatedByGiftcards[ln-1]
			}
			o.R.CreatedByGiftcards = o.R.CreatedByGiftcards[:ln-1]
			break
		}
	}

	return nil
}

// AddInvoiceEvents adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.InvoiceEvents.
// Sets related.R.User appropriately.
func (o *User) AddInvoiceEvents(exec boil.Executor, insert bool, related ...*InvoiceEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"invoice_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, invoiceEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			InvoiceEvents: related,
		}
	} else {
		o.R.InvoiceEvents = append(o.R.InvoiceEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &invoiceEventR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetInvoiceEvents removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's InvoiceEvents accordingly.
// Replaces o.R.InvoiceEvents with related.
// Sets related.R.User's InvoiceEvents accordingly.
func (o *User) SetInvoiceEvents(exec boil.Executor, insert bool, related ...*InvoiceEvent) error {
	query := "update \"invoice_events\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.InvoiceEvents {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.InvoiceEvents = nil
	}

	return o.AddInvoiceEvents(exec, insert, related...)
}

// RemoveInvoiceEvents relationships from objects passed in.
// Removes related items from R.InvoiceEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveInvoiceEvents(exec boil.Executor, related ...*InvoiceEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.InvoiceEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.InvoiceEvents)
			if ln > 1 && i < ln-1 {
				o.R.InvoiceEvents[i] = o.R.InvoiceEvents[ln-1]
			}
			o.R.InvoiceEvents = o.R.InvoiceEvents[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderEvents adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.OrderEvents.
// Sets related.R.User appropriately.
func (o *User) AddOrderEvents(exec boil.Executor, insert bool, related ...*OrderEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"order_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, orderEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			OrderEvents: related,
		}
	} else {
		o.R.OrderEvents = append(o.R.OrderEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderEventR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetOrderEvents removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's OrderEvents accordingly.
// Replaces o.R.OrderEvents with related.
// Sets related.R.User's OrderEvents accordingly.
func (o *User) SetOrderEvents(exec boil.Executor, insert bool, related ...*OrderEvent) error {
	query := "update \"order_events\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OrderEvents {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.OrderEvents = nil
	}

	return o.AddOrderEvents(exec, insert, related...)
}

// RemoveOrderEvents relationships from objects passed in.
// Removes related items from R.OrderEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveOrderEvents(exec boil.Executor, related ...*OrderEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderEvents)
			if ln > 1 && i < ln-1 {
				o.R.OrderEvents[i] = o.R.OrderEvents[ln-1]
			}
			o.R.OrderEvents = o.R.OrderEvents[:ln-1]
			break
		}
	}

	return nil
}

// AddOrders adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Orders.
// Sets related.R.User appropriately.
func (o *User) AddOrders(exec boil.Executor, insert bool, related ...*Order) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"orders\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, orderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			Orders: related,
		}
	} else {
		o.R.Orders = append(o.R.Orders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetOrders removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's Orders accordingly.
// Replaces o.R.Orders with related.
// Sets related.R.User's Orders accordingly.
func (o *User) SetOrders(exec boil.Executor, insert bool, related ...*Order) error {
	query := "update \"orders\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Orders {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.Orders = nil
	}

	return o.AddOrders(exec, insert, related...)
}

// RemoveOrders relationships from objects passed in.
// Removes related items from R.Orders (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveOrders(exec boil.Executor, related ...*Order) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Orders {
			if rel != ri {
				continue
			}

			ln := len(o.R.Orders)
			if ln > 1 && i < ln-1 {
				o.R.Orders[i] = o.R.Orders[ln-1]
			}
			o.R.Orders = o.R.Orders[:ln-1]
			break
		}
	}

	return nil
}

// AddStaffNotificationRecipients adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.StaffNotificationRecipients.
// Sets related.R.User appropriately.
func (o *User) AddStaffNotificationRecipients(exec boil.Executor, insert bool, related ...*StaffNotificationRecipient) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"staff_notification_recipients\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, staffNotificationRecipientPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			StaffNotificationRecipients: related,
		}
	} else {
		o.R.StaffNotificationRecipients = append(o.R.StaffNotificationRecipients, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &staffNotificationRecipientR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// SetStaffNotificationRecipients removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.User's StaffNotificationRecipients accordingly.
// Replaces o.R.StaffNotificationRecipients with related.
// Sets related.R.User's StaffNotificationRecipients accordingly.
func (o *User) SetStaffNotificationRecipients(exec boil.Executor, insert bool, related ...*StaffNotificationRecipient) error {
	query := "update \"staff_notification_recipients\" set \"user_id\" = null where \"user_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.StaffNotificationRecipients {
			queries.SetScanner(&rel.UserID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.User = nil
		}
		o.R.StaffNotificationRecipients = nil
	}

	return o.AddStaffNotificationRecipients(exec, insert, related...)
}

// RemoveStaffNotificationRecipients relationships from objects passed in.
// Removes related items from R.StaffNotificationRecipients (uses pointer comparison, removal does not keep order)
// Sets related.R.User.
func (o *User) RemoveStaffNotificationRecipients(exec boil.Executor, related ...*StaffNotificationRecipient) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserID, nil)
		if rel.R != nil {
			rel.R.User = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("user_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.StaffNotificationRecipients {
			if rel != ri {
				continue
			}

			ln := len(o.R.StaffNotificationRecipients)
			if ln > 1 && i < ln-1 {
				o.R.StaffNotificationRecipients[i] = o.R.StaffNotificationRecipients[ln-1]
			}
			o.R.StaffNotificationRecipients = o.R.StaffNotificationRecipients[:ln-1]
			break
		}
	}

	return nil
}

// AddUserAccessTokens adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserAccessTokens.
// Sets related.R.User appropriately.
func (o *User) AddUserAccessTokens(exec boil.Executor, insert bool, related ...*UserAccessToken) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_access_tokens\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userAccessTokenPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserAccessTokens: related,
		}
	} else {
		o.R.UserAccessTokens = append(o.R.UserAccessTokens, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAccessTokenR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("\"users\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"users\".*"})
	}

	return userQuery{q}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(exec boil.Executor, iD string, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"users\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, userObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from users")
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no users provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"users\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"users\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into users")
	}

	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update users, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update users row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for users")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for users")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("model: no users provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("model: unable to upsert users, could not build update column list")
		}

		ret := strmangle.SetComplement(userAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(userPrimaryKeyColumns) == 0 {
				return errors.New("model: unable to upsert users, could not build conflict column list")
			}

			conflict = make([]string, len(userPrimaryKeyColumns))
			copy(conflict, userPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"users\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "model: unable to upsert users")
	}

	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no User provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
	sql := "DELETE FROM \"users\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for users")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no userQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for users")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for users")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(exec boil.Executor) error {
	ret, err := FindUser(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"users\".* FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"users\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if users exists")
	}

	return exists, nil
}

// Exists checks if the User row exists.
func (o *User) Exists(exec boil.Executor) (bool, error) {
	return UserExists(exec, o.ID)
}
