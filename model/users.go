// Code generated by SQLBoiler 4.16.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/sitename/sitename/modules/model_types"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// User is an object representing the database table.
type User struct {
	ID                       string                 `boil:"id" json:"id" toml:"id" yaml:"id"`
	Email                    string                 `boil:"email" json:"email" toml:"email" yaml:"email"`
	Username                 string                 `boil:"username" json:"username" toml:"username" yaml:"username"`
	FirstName                string                 `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	LastName                 string                 `boil:"last_name" json:"last_name" toml:"last_name" yaml:"last_name"`
	DefaultShippingAddressID model_types.NullString `boil:"default_shipping_address_id" json:"default_shipping_address_id,omitempty" toml:"default_shipping_address_id" yaml:"default_shipping_address_id,omitempty"`
	DefaultBillingAddressID  model_types.NullString `boil:"default_billing_address_id" json:"default_billing_address_id,omitempty" toml:"default_billing_address_id" yaml:"default_billing_address_id,omitempty"`
	Password                 string                 `boil:"password" json:"password" toml:"password" yaml:"password"`
	AuthData                 model_types.NullString `boil:"auth_data" json:"auth_data,omitempty" toml:"auth_data" yaml:"auth_data,omitempty"`
	AuthService              string                 `boil:"auth_service" json:"auth_service" toml:"auth_service" yaml:"auth_service"`
	EmailVerified            bool                   `boil:"email_verified" json:"email_verified" toml:"email_verified" yaml:"email_verified"`
	Nickname                 string                 `boil:"nickname" json:"nickname" toml:"nickname" yaml:"nickname"`
	Roles                    string                 `boil:"roles" json:"roles" toml:"roles" yaml:"roles"`
	Props                    model_types.JsonMap    `boil:"props" json:"props,omitempty" toml:"props" yaml:"props,omitempty"`
	NotifyProps              model_types.JsonMap    `boil:"notify_props" json:"notify_props,omitempty" toml:"notify_props" yaml:"notify_props,omitempty"`
	LastPasswordUpdate       int64                  `boil:"last_password_update" json:"last_password_update" toml:"last_password_update" yaml:"last_password_update"`
	LastPictureUpdate        int64                  `boil:"last_picture_update" json:"last_picture_update" toml:"last_picture_update" yaml:"last_picture_update"`
	FailedAttempts           int                    `boil:"failed_attempts" json:"failed_attempts" toml:"failed_attempts" yaml:"failed_attempts"`
	Locale                   string                 `boil:"locale" json:"locale" toml:"locale" yaml:"locale"`
	Timezone                 model_types.JsonMap    `boil:"timezone" json:"timezone,omitempty" toml:"timezone" yaml:"timezone,omitempty"`
	MfaActive                bool                   `boil:"mfa_active" json:"mfa_active" toml:"mfa_active" yaml:"mfa_active"`
	MfaSecret                string                 `boil:"mfa_secret" json:"mfa_secret" toml:"mfa_secret" yaml:"mfa_secret"`
	CreatedAt                int64                  `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                int64                  `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeleteAt                 int64                  `boil:"delete_at" json:"delete_at" toml:"delete_at" yaml:"delete_at"`
	IsActive                 bool                   `boil:"is_active" json:"is_active" toml:"is_active" yaml:"is_active"`
	Note                     model_types.NullString `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	JWTTokenKey              string                 `boil:"jwt_token_key" json:"jwt_token_key" toml:"jwt_token_key" yaml:"jwt_token_key"`
	LastActivityAt           int64                  `boil:"last_activity_at" json:"last_activity_at" toml:"last_activity_at" yaml:"last_activity_at"`
	TermsOfServiceID         string                 `boil:"terms_of_service_id" json:"terms_of_service_id" toml:"terms_of_service_id" yaml:"terms_of_service_id"`
	TermsOfServiceCreatedAt  int64                  `boil:"terms_of_service_created_at" json:"terms_of_service_created_at" toml:"terms_of_service_created_at" yaml:"terms_of_service_created_at"`
	DisableWelcomeEmail      bool                   `boil:"disable_welcome_email" json:"disable_welcome_email" toml:"disable_welcome_email" yaml:"disable_welcome_email"`
	Metadata                 model_types.JsonMap    `boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	PrivateMetadata          model_types.JsonMap    `boil:"private_metadata" json:"private_metadata,omitempty" toml:"private_metadata" yaml:"private_metadata,omitempty"`

	R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ID                       string
	Email                    string
	Username                 string
	FirstName                string
	LastName                 string
	DefaultShippingAddressID string
	DefaultBillingAddressID  string
	Password                 string
	AuthData                 string
	AuthService              string
	EmailVerified            string
	Nickname                 string
	Roles                    string
	Props                    string
	NotifyProps              string
	LastPasswordUpdate       string
	LastPictureUpdate        string
	FailedAttempts           string
	Locale                   string
	Timezone                 string
	MfaActive                string
	MfaSecret                string
	CreatedAt                string
	UpdatedAt                string
	DeleteAt                 string
	IsActive                 string
	Note                     string
	JWTTokenKey              string
	LastActivityAt           string
	TermsOfServiceID         string
	TermsOfServiceCreatedAt  string
	DisableWelcomeEmail      string
	Metadata                 string
	PrivateMetadata          string
}{
	ID:                       "id",
	Email:                    "email",
	Username:                 "username",
	FirstName:                "first_name",
	LastName:                 "last_name",
	DefaultShippingAddressID: "default_shipping_address_id",
	DefaultBillingAddressID:  "default_billing_address_id",
	Password:                 "password",
	AuthData:                 "auth_data",
	AuthService:              "auth_service",
	EmailVerified:            "email_verified",
	Nickname:                 "nickname",
	Roles:                    "roles",
	Props:                    "props",
	NotifyProps:              "notify_props",
	LastPasswordUpdate:       "last_password_update",
	LastPictureUpdate:        "last_picture_update",
	FailedAttempts:           "failed_attempts",
	Locale:                   "locale",
	Timezone:                 "timezone",
	MfaActive:                "mfa_active",
	MfaSecret:                "mfa_secret",
	CreatedAt:                "created_at",
	UpdatedAt:                "updated_at",
	DeleteAt:                 "delete_at",
	IsActive:                 "is_active",
	Note:                     "note",
	JWTTokenKey:              "jwt_token_key",
	LastActivityAt:           "last_activity_at",
	TermsOfServiceID:         "terms_of_service_id",
	TermsOfServiceCreatedAt:  "terms_of_service_created_at",
	DisableWelcomeEmail:      "disable_welcome_email",
	Metadata:                 "metadata",
	PrivateMetadata:          "private_metadata",
}

var UserTableColumns = struct {
	ID                       string
	Email                    string
	Username                 string
	FirstName                string
	LastName                 string
	DefaultShippingAddressID string
	DefaultBillingAddressID  string
	Password                 string
	AuthData                 string
	AuthService              string
	EmailVerified            string
	Nickname                 string
	Roles                    string
	Props                    string
	NotifyProps              string
	LastPasswordUpdate       string
	LastPictureUpdate        string
	FailedAttempts           string
	Locale                   string
	Timezone                 string
	MfaActive                string
	MfaSecret                string
	CreatedAt                string
	UpdatedAt                string
	DeleteAt                 string
	IsActive                 string
	Note                     string
	JWTTokenKey              string
	LastActivityAt           string
	TermsOfServiceID         string
	TermsOfServiceCreatedAt  string
	DisableWelcomeEmail      string
	Metadata                 string
	PrivateMetadata          string
}{
	ID:                       "users.id",
	Email:                    "users.email",
	Username:                 "users.username",
	FirstName:                "users.first_name",
	LastName:                 "users.last_name",
	DefaultShippingAddressID: "users.default_shipping_address_id",
	DefaultBillingAddressID:  "users.default_billing_address_id",
	Password:                 "users.password",
	AuthData:                 "users.auth_data",
	AuthService:              "users.auth_service",
	EmailVerified:            "users.email_verified",
	Nickname:                 "users.nickname",
	Roles:                    "users.roles",
	Props:                    "users.props",
	NotifyProps:              "users.notify_props",
	LastPasswordUpdate:       "users.last_password_update",
	LastPictureUpdate:        "users.last_picture_update",
	FailedAttempts:           "users.failed_attempts",
	Locale:                   "users.locale",
	Timezone:                 "users.timezone",
	MfaActive:                "users.mfa_active",
	MfaSecret:                "users.mfa_secret",
	CreatedAt:                "users.created_at",
	UpdatedAt:                "users.updated_at",
	DeleteAt:                 "users.delete_at",
	IsActive:                 "users.is_active",
	Note:                     "users.note",
	JWTTokenKey:              "users.jwt_token_key",
	LastActivityAt:           "users.last_activity_at",
	TermsOfServiceID:         "users.terms_of_service_id",
	TermsOfServiceCreatedAt:  "users.terms_of_service_created_at",
	DisableWelcomeEmail:      "users.disable_welcome_email",
	Metadata:                 "users.metadata",
	PrivateMetadata:          "users.private_metadata",
}

// Generated where

var UserWhere = struct {
	ID                       whereHelperstring
	Email                    whereHelperstring
	Username                 whereHelperstring
	FirstName                whereHelperstring
	LastName                 whereHelperstring
	DefaultShippingAddressID whereHelpermodel_types_NullString
	DefaultBillingAddressID  whereHelpermodel_types_NullString
	Password                 whereHelperstring
	AuthData                 whereHelpermodel_types_NullString
	AuthService              whereHelperstring
	EmailVerified            whereHelperbool
	Nickname                 whereHelperstring
	Roles                    whereHelperstring
	Props                    whereHelpermodel_types_JsonMap
	NotifyProps              whereHelpermodel_types_JsonMap
	LastPasswordUpdate       whereHelperint64
	LastPictureUpdate        whereHelperint64
	FailedAttempts           whereHelperint
	Locale                   whereHelperstring
	Timezone                 whereHelpermodel_types_JsonMap
	MfaActive                whereHelperbool
	MfaSecret                whereHelperstring
	CreatedAt                whereHelperint64
	UpdatedAt                whereHelperint64
	DeleteAt                 whereHelperint64
	IsActive                 whereHelperbool
	Note                     whereHelpermodel_types_NullString
	JWTTokenKey              whereHelperstring
	LastActivityAt           whereHelperint64
	TermsOfServiceID         whereHelperstring
	TermsOfServiceCreatedAt  whereHelperint64
	DisableWelcomeEmail      whereHelperbool
	Metadata                 whereHelpermodel_types_JsonMap
	PrivateMetadata          whereHelpermodel_types_JsonMap
}{
	ID:                       whereHelperstring{field: "\"users\".\"id\""},
	Email:                    whereHelperstring{field: "\"users\".\"email\""},
	Username:                 whereHelperstring{field: "\"users\".\"username\""},
	FirstName:                whereHelperstring{field: "\"users\".\"first_name\""},
	LastName:                 whereHelperstring{field: "\"users\".\"last_name\""},
	DefaultShippingAddressID: whereHelpermodel_types_NullString{field: "\"users\".\"default_shipping_address_id\""},
	DefaultBillingAddressID:  whereHelpermodel_types_NullString{field: "\"users\".\"default_billing_address_id\""},
	Password:                 whereHelperstring{field: "\"users\".\"password\""},
	AuthData:                 whereHelpermodel_types_NullString{field: "\"users\".\"auth_data\""},
	AuthService:              whereHelperstring{field: "\"users\".\"auth_service\""},
	EmailVerified:            whereHelperbool{field: "\"users\".\"email_verified\""},
	Nickname:                 whereHelperstring{field: "\"users\".\"nickname\""},
	Roles:                    whereHelperstring{field: "\"users\".\"roles\""},
	Props:                    whereHelpermodel_types_JsonMap{field: "\"users\".\"props\""},
	NotifyProps:              whereHelpermodel_types_JsonMap{field: "\"users\".\"notify_props\""},
	LastPasswordUpdate:       whereHelperint64{field: "\"users\".\"last_password_update\""},
	LastPictureUpdate:        whereHelperint64{field: "\"users\".\"last_picture_update\""},
	FailedAttempts:           whereHelperint{field: "\"users\".\"failed_attempts\""},
	Locale:                   whereHelperstring{field: "\"users\".\"locale\""},
	Timezone:                 whereHelpermodel_types_JsonMap{field: "\"users\".\"timezone\""},
	MfaActive:                whereHelperbool{field: "\"users\".\"mfa_active\""},
	MfaSecret:                whereHelperstring{field: "\"users\".\"mfa_secret\""},
	CreatedAt:                whereHelperint64{field: "\"users\".\"created_at\""},
	UpdatedAt:                whereHelperint64{field: "\"users\".\"updated_at\""},
	DeleteAt:                 whereHelperint64{field: "\"users\".\"delete_at\""},
	IsActive:                 whereHelperbool{field: "\"users\".\"is_active\""},
	Note:                     whereHelpermodel_types_NullString{field: "\"users\".\"note\""},
	JWTTokenKey:              whereHelperstring{field: "\"users\".\"jwt_token_key\""},
	LastActivityAt:           whereHelperint64{field: "\"users\".\"last_activity_at\""},
	TermsOfServiceID:         whereHelperstring{field: "\"users\".\"terms_of_service_id\""},
	TermsOfServiceCreatedAt:  whereHelperint64{field: "\"users\".\"terms_of_service_created_at\""},
	DisableWelcomeEmail:      whereHelperbool{field: "\"users\".\"disable_welcome_email\""},
	Metadata:                 whereHelpermodel_types_JsonMap{field: "\"users\".\"metadata\""},
	PrivateMetadata:          whereHelpermodel_types_JsonMap{field: "\"users\".\"private_metadata\""},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	Compliances      string
	UserAccessTokens string
}{
	Compliances:      "Compliances",
	UserAccessTokens: "UserAccessTokens",
}

// userR is where relationships are stored.
type userR struct {
	Compliances      ComplianceSlice      `boil:"Compliances" json:"Compliances" toml:"Compliances" yaml:"Compliances"`
	UserAccessTokens UserAccessTokenSlice `boil:"UserAccessTokens" json:"UserAccessTokens" toml:"UserAccessTokens" yaml:"UserAccessTokens"`
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

func (r *userR) GetCompliances() ComplianceSlice {
	if r == nil {
		return nil
	}
	return r.Compliances
}

func (r *userR) GetUserAccessTokens() UserAccessTokenSlice {
	if r == nil {
		return nil
	}
	return r.UserAccessTokens
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"id", "email", "username", "first_name", "last_name", "default_shipping_address_id", "default_billing_address_id", "password", "auth_data", "auth_service", "email_verified", "nickname", "roles", "props", "notify_props", "last_password_update", "last_picture_update", "failed_attempts", "locale", "timezone", "mfa_active", "mfa_secret", "created_at", "updated_at", "delete_at", "is_active", "note", "jwt_token_key", "last_activity_at", "terms_of_service_id", "terms_of_service_created_at", "disable_welcome_email", "metadata", "private_metadata"}
	userColumnsWithoutDefault = []string{"email", "username", "first_name", "last_name", "password", "auth_service", "email_verified", "nickname", "roles", "last_password_update", "last_picture_update", "failed_attempts", "locale", "mfa_active", "mfa_secret", "created_at", "updated_at", "delete_at", "is_active", "jwt_token_key", "last_activity_at", "terms_of_service_id", "terms_of_service_created_at", "disable_welcome_email"}
	userColumnsWithDefault    = []string{"id", "default_shipping_address_id", "default_billing_address_id", "auth_data", "props", "notify_props", "timezone", "note", "metadata", "private_metadata"}
	userPrimaryKeyColumns     = []string{"id"}
	userGeneratedColumns      = []string{}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should almost always be used instead of []User.
	UserSlice []*User

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single user record from the query.
func (q userQuery) One(exec boil.Executor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for users")
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(exec boil.Executor) (UserSlice, error) {
	var o []*User

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to User slice")
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count users rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if users exists")
	}

	return count > 0, nil
}

// Compliances retrieves all the compliance's Compliances with an executor.
func (o *User) Compliances(mods ...qm.QueryMod) complianceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"compliances\".\"user_id\"=?", o.ID),
	)

	return Compliances(queryMods...)
}

// UserAccessTokens retrieves all the user_access_token's UserAccessTokens with an executor.
func (o *User) UserAccessTokens(mods ...qm.QueryMod) userAccessTokenQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_access_tokens\".\"user_id\"=?", o.ID),
	)

	return UserAccessTokens(queryMods...)
}

// LoadCompliances allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCompliances(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`compliances`),
		qm.WhereIn(`compliances.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load compliances")
	}

	var resultSlice []*Compliance
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice compliances")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on compliances")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for compliances")
	}

	if singular {
		object.R.Compliances = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &complianceR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.Compliances = append(local.R.Compliances, foreign)
				if foreign.R == nil {
					foreign.R = &complianceR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserAccessTokens allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserAccessTokens(e boil.Executor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_access_tokens`),
		qm.WhereIn(`user_access_tokens.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_access_tokens")
	}

	var resultSlice []*UserAccessToken
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_access_tokens")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_access_tokens")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_access_tokens")
	}

	if singular {
		object.R.UserAccessTokens = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAccessTokenR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserAccessTokens = append(local.R.UserAccessTokens, foreign)
				if foreign.R == nil {
					foreign.R = &userAccessTokenR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// AddCompliances adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.Compliances.
// Sets related.R.User appropriately.
func (o *User) AddCompliances(exec boil.Executor, insert bool, related ...*Compliance) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"compliances\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, compliancePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			Compliances: related,
		}
	} else {
		o.R.Compliances = append(o.R.Compliances, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &complianceR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserAccessTokens adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserAccessTokens.
// Sets related.R.User appropriately.
func (o *User) AddUserAccessTokens(exec boil.Executor, insert bool, related ...*UserAccessToken) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_access_tokens\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userAccessTokenPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserAccessTokens: related,
		}
	} else {
		o.R.UserAccessTokens = append(o.R.UserAccessTokens, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAccessTokenR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("\"users\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"users\".*"})
	}

	return userQuery{q}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(exec boil.Executor, iD string, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"users\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, userObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from users")
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no users provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"users\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"users\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into users")
	}

	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update users, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update users row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for users")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for users")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("model: no users provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("model: unable to upsert users, could not build update column list")
		}

		ret := strmangle.SetComplement(userAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(userPrimaryKeyColumns) == 0 {
				return errors.New("model: unable to upsert users, could not build conflict column list")
			}

			conflict = make([]string, len(userPrimaryKeyColumns))
			copy(conflict, userPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"users\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "model: unable to upsert users")
	}

	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no User provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
	sql := "DELETE FROM \"users\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for users")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no userQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for users")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for users")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(exec boil.Executor) error {
	ret, err := FindUser(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"users\".* FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"users\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if users exists")
	}

	return exists, nil
}

// Exists checks if the User row exists.
func (o *User) Exists(exec boil.Executor) (bool, error) {
	return UserExists(exec, o.ID)
}
