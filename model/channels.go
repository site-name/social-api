// Code generated by SQLBoiler 4.17.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/sitename/sitename/modules/model_types"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Channel is an object representing the database table.
type Channel struct {
	ID                                       string                  `boil:"id" json:"id" toml:"id" yaml:"id"`
	Name                                     string                  `boil:"name" json:"name" toml:"name" yaml:"name"`
	IsActive                                 bool                    `boil:"is_active" json:"is_active" toml:"is_active" yaml:"is_active"`
	Slug                                     string                  `boil:"slug" json:"slug" toml:"slug" yaml:"slug"`
	Currency                                 Currency                `boil:"currency" json:"currency" toml:"currency" yaml:"currency"`
	DefaultCountry                           CountryCode             `boil:"default_country" json:"default_country" toml:"default_country" yaml:"default_country"`
	AllocationStrategy                       AllocationStrategy      `boil:"allocation_strategy" json:"allocation_strategy" toml:"allocation_strategy" yaml:"allocation_strategy"`
	OrderMarkAsPaidStrategy                  MarkAsPaidStrategy      `boil:"order_mark_as_paid_strategy" json:"order_mark_as_paid_strategy" toml:"order_mark_as_paid_strategy" yaml:"order_mark_as_paid_strategy"`
	DefaultTransactionFlowStrategy           TransactionFlowStrategy `boil:"default_transaction_flow_strategy" json:"default_transaction_flow_strategy" toml:"default_transaction_flow_strategy" yaml:"default_transaction_flow_strategy"`
	AutomaticallyConfirmAllNewOrders         model_types.NullBool    `boil:"automatically_confirm_all_new_orders" json:"automatically_confirm_all_new_orders,omitempty" toml:"automatically_confirm_all_new_orders" yaml:"automatically_confirm_all_new_orders,omitempty"`
	AllowUnpaidOrders                        bool                    `boil:"allow_unpaid_orders" json:"allow_unpaid_orders" toml:"allow_unpaid_orders" yaml:"allow_unpaid_orders"`
	AutomaticallyFulfillNonShippableGiftCard model_types.NullBool    `boil:"automatically_fulfill_non_shippable_gift_card" json:"automatically_fulfill_non_shippable_gift_card,omitempty" toml:"automatically_fulfill_non_shippable_gift_card" yaml:"automatically_fulfill_non_shippable_gift_card,omitempty"`
	ExpireOrdersAfter                        model_types.NullInt     `boil:"expire_orders_after" json:"expire_orders_after,omitempty" toml:"expire_orders_after" yaml:"expire_orders_after,omitempty"`
	DeleteExpiredOrdersAfter                 model_types.NullInt     `boil:"delete_expired_orders_after" json:"delete_expired_orders_after,omitempty" toml:"delete_expired_orders_after" yaml:"delete_expired_orders_after,omitempty"`
	IncludeDarftOrderIsVoucherUsage          bool                    `boil:"include_darft_order_is_voucher_usage" json:"include_darft_order_is_voucher_usage" toml:"include_darft_order_is_voucher_usage" yaml:"include_darft_order_is_voucher_usage"`
	AutomaticallyCompleteFullyPaidCheckouts  bool                    `boil:"automatically_complete_fully_paid_checkouts" json:"automatically_complete_fully_paid_checkouts" toml:"automatically_complete_fully_paid_checkouts" yaml:"automatically_complete_fully_paid_checkouts"`
	Annotations                              model_types.JSONString  `boil:"annotations" json:"-" toml:"-" yaml:"-"`

	R *channelR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L channelL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ChannelColumns = struct {
	ID                                       string
	Name                                     string
	IsActive                                 string
	Slug                                     string
	Currency                                 string
	DefaultCountry                           string
	AllocationStrategy                       string
	OrderMarkAsPaidStrategy                  string
	DefaultTransactionFlowStrategy           string
	AutomaticallyConfirmAllNewOrders         string
	AllowUnpaidOrders                        string
	AutomaticallyFulfillNonShippableGiftCard string
	ExpireOrdersAfter                        string
	DeleteExpiredOrdersAfter                 string
	IncludeDarftOrderIsVoucherUsage          string
	AutomaticallyCompleteFullyPaidCheckouts  string
	Annotations                              string
}{
	ID:                                       "id",
	Name:                                     "name",
	IsActive:                                 "is_active",
	Slug:                                     "slug",
	Currency:                                 "currency",
	DefaultCountry:                           "default_country",
	AllocationStrategy:                       "allocation_strategy",
	OrderMarkAsPaidStrategy:                  "order_mark_as_paid_strategy",
	DefaultTransactionFlowStrategy:           "default_transaction_flow_strategy",
	AutomaticallyConfirmAllNewOrders:         "automatically_confirm_all_new_orders",
	AllowUnpaidOrders:                        "allow_unpaid_orders",
	AutomaticallyFulfillNonShippableGiftCard: "automatically_fulfill_non_shippable_gift_card",
	ExpireOrdersAfter:                        "expire_orders_after",
	DeleteExpiredOrdersAfter:                 "delete_expired_orders_after",
	IncludeDarftOrderIsVoucherUsage:          "include_darft_order_is_voucher_usage",
	AutomaticallyCompleteFullyPaidCheckouts:  "automatically_complete_fully_paid_checkouts",
	Annotations:                              "annotations",
}

var ChannelTableColumns = struct {
	ID                                       string
	Name                                     string
	IsActive                                 string
	Slug                                     string
	Currency                                 string
	DefaultCountry                           string
	AllocationStrategy                       string
	OrderMarkAsPaidStrategy                  string
	DefaultTransactionFlowStrategy           string
	AutomaticallyConfirmAllNewOrders         string
	AllowUnpaidOrders                        string
	AutomaticallyFulfillNonShippableGiftCard string
	ExpireOrdersAfter                        string
	DeleteExpiredOrdersAfter                 string
	IncludeDarftOrderIsVoucherUsage          string
	AutomaticallyCompleteFullyPaidCheckouts  string
	Annotations                              string
}{
	ID:                                       "channels.id",
	Name:                                     "channels.name",
	IsActive:                                 "channels.is_active",
	Slug:                                     "channels.slug",
	Currency:                                 "channels.currency",
	DefaultCountry:                           "channels.default_country",
	AllocationStrategy:                       "channels.allocation_strategy",
	OrderMarkAsPaidStrategy:                  "channels.order_mark_as_paid_strategy",
	DefaultTransactionFlowStrategy:           "channels.default_transaction_flow_strategy",
	AutomaticallyConfirmAllNewOrders:         "channels.automatically_confirm_all_new_orders",
	AllowUnpaidOrders:                        "channels.allow_unpaid_orders",
	AutomaticallyFulfillNonShippableGiftCard: "channels.automatically_fulfill_non_shippable_gift_card",
	ExpireOrdersAfter:                        "channels.expire_orders_after",
	DeleteExpiredOrdersAfter:                 "channels.delete_expired_orders_after",
	IncludeDarftOrderIsVoucherUsage:          "channels.include_darft_order_is_voucher_usage",
	AutomaticallyCompleteFullyPaidCheckouts:  "channels.automatically_complete_fully_paid_checkouts",
	Annotations:                              "channels.annotations",
}

// Generated where

type whereHelperCurrency struct{ field string }

func (w whereHelperCurrency) EQ(x Currency) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelperCurrency) NEQ(x Currency) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperCurrency) LT(x Currency) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelperCurrency) LTE(x Currency) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperCurrency) GT(x Currency) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelperCurrency) GTE(x Currency) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperCurrency) IN(slice []Currency) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperCurrency) NIN(slice []Currency) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperAllocationStrategy struct{ field string }

func (w whereHelperAllocationStrategy) EQ(x AllocationStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelperAllocationStrategy) NEQ(x AllocationStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperAllocationStrategy) LT(x AllocationStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelperAllocationStrategy) LTE(x AllocationStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperAllocationStrategy) GT(x AllocationStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelperAllocationStrategy) GTE(x AllocationStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperAllocationStrategy) IN(slice []AllocationStrategy) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperAllocationStrategy) NIN(slice []AllocationStrategy) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperMarkAsPaidStrategy struct{ field string }

func (w whereHelperMarkAsPaidStrategy) EQ(x MarkAsPaidStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelperMarkAsPaidStrategy) NEQ(x MarkAsPaidStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperMarkAsPaidStrategy) LT(x MarkAsPaidStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelperMarkAsPaidStrategy) LTE(x MarkAsPaidStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperMarkAsPaidStrategy) GT(x MarkAsPaidStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelperMarkAsPaidStrategy) GTE(x MarkAsPaidStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperMarkAsPaidStrategy) IN(slice []MarkAsPaidStrategy) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperMarkAsPaidStrategy) NIN(slice []MarkAsPaidStrategy) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperTransactionFlowStrategy struct{ field string }

func (w whereHelperTransactionFlowStrategy) EQ(x TransactionFlowStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelperTransactionFlowStrategy) NEQ(x TransactionFlowStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperTransactionFlowStrategy) LT(x TransactionFlowStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelperTransactionFlowStrategy) LTE(x TransactionFlowStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperTransactionFlowStrategy) GT(x TransactionFlowStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelperTransactionFlowStrategy) GTE(x TransactionFlowStrategy) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperTransactionFlowStrategy) IN(slice []TransactionFlowStrategy) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperTransactionFlowStrategy) NIN(slice []TransactionFlowStrategy) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var ChannelWhere = struct {
	ID                                       whereHelperstring
	Name                                     whereHelperstring
	IsActive                                 whereHelperbool
	Slug                                     whereHelperstring
	Currency                                 whereHelperCurrency
	DefaultCountry                           whereHelperCountryCode
	AllocationStrategy                       whereHelperAllocationStrategy
	OrderMarkAsPaidStrategy                  whereHelperMarkAsPaidStrategy
	DefaultTransactionFlowStrategy           whereHelperTransactionFlowStrategy
	AutomaticallyConfirmAllNewOrders         whereHelpermodel_types_NullBool
	AllowUnpaidOrders                        whereHelperbool
	AutomaticallyFulfillNonShippableGiftCard whereHelpermodel_types_NullBool
	ExpireOrdersAfter                        whereHelpermodel_types_NullInt
	DeleteExpiredOrdersAfter                 whereHelpermodel_types_NullInt
	IncludeDarftOrderIsVoucherUsage          whereHelperbool
	AutomaticallyCompleteFullyPaidCheckouts  whereHelperbool
	Annotations                              whereHelpermodel_types_JSONString
}{
	ID:                                       whereHelperstring{field: "\"channels\".\"id\""},
	Name:                                     whereHelperstring{field: "\"channels\".\"name\""},
	IsActive:                                 whereHelperbool{field: "\"channels\".\"is_active\""},
	Slug:                                     whereHelperstring{field: "\"channels\".\"slug\""},
	Currency:                                 whereHelperCurrency{field: "\"channels\".\"currency\""},
	DefaultCountry:                           whereHelperCountryCode{field: "\"channels\".\"default_country\""},
	AllocationStrategy:                       whereHelperAllocationStrategy{field: "\"channels\".\"allocation_strategy\""},
	OrderMarkAsPaidStrategy:                  whereHelperMarkAsPaidStrategy{field: "\"channels\".\"order_mark_as_paid_strategy\""},
	DefaultTransactionFlowStrategy:           whereHelperTransactionFlowStrategy{field: "\"channels\".\"default_transaction_flow_strategy\""},
	AutomaticallyConfirmAllNewOrders:         whereHelpermodel_types_NullBool{field: "\"channels\".\"automatically_confirm_all_new_orders\""},
	AllowUnpaidOrders:                        whereHelperbool{field: "\"channels\".\"allow_unpaid_orders\""},
	AutomaticallyFulfillNonShippableGiftCard: whereHelpermodel_types_NullBool{field: "\"channels\".\"automatically_fulfill_non_shippable_gift_card\""},
	ExpireOrdersAfter:                        whereHelpermodel_types_NullInt{field: "\"channels\".\"expire_orders_after\""},
	DeleteExpiredOrdersAfter:                 whereHelpermodel_types_NullInt{field: "\"channels\".\"delete_expired_orders_after\""},
	IncludeDarftOrderIsVoucherUsage:          whereHelperbool{field: "\"channels\".\"include_darft_order_is_voucher_usage\""},
	AutomaticallyCompleteFullyPaidCheckouts:  whereHelperbool{field: "\"channels\".\"automatically_complete_fully_paid_checkouts\""},
	Annotations:                              whereHelpermodel_types_JSONString{field: "\"channels\".\"annotations\""},
}

// ChannelRels is where relationship names are stored.
var ChannelRels = struct {
	Checkouts                     string
	CollectionChannelListings     string
	Orders                        string
	PluginConfigurations          string
	ProductChannelListings        string
	ProductVariantChannelListings string
	PromotionRuleChannels         string
	SaleChannelListings           string
	ShippingMethodChannelListings string
	ShippingZoneChannels          string
	TaxConfigurations             string
	VoucherChannelListings        string
}{
	Checkouts:                     "Checkouts",
	CollectionChannelListings:     "CollectionChannelListings",
	Orders:                        "Orders",
	PluginConfigurations:          "PluginConfigurations",
	ProductChannelListings:        "ProductChannelListings",
	ProductVariantChannelListings: "ProductVariantChannelListings",
	PromotionRuleChannels:         "PromotionRuleChannels",
	SaleChannelListings:           "SaleChannelListings",
	ShippingMethodChannelListings: "ShippingMethodChannelListings",
	ShippingZoneChannels:          "ShippingZoneChannels",
	TaxConfigurations:             "TaxConfigurations",
	VoucherChannelListings:        "VoucherChannelListings",
}

// channelR is where relationships are stored.
type channelR struct {
	Checkouts                     CheckoutSlice                     `boil:"Checkouts" json:"Checkouts" toml:"Checkouts" yaml:"Checkouts"`
	CollectionChannelListings     CollectionChannelListingSlice     `boil:"CollectionChannelListings" json:"CollectionChannelListings" toml:"CollectionChannelListings" yaml:"CollectionChannelListings"`
	Orders                        OrderSlice                        `boil:"Orders" json:"Orders" toml:"Orders" yaml:"Orders"`
	PluginConfigurations          PluginConfigurationSlice          `boil:"PluginConfigurations" json:"PluginConfigurations" toml:"PluginConfigurations" yaml:"PluginConfigurations"`
	ProductChannelListings        ProductChannelListingSlice        `boil:"ProductChannelListings" json:"ProductChannelListings" toml:"ProductChannelListings" yaml:"ProductChannelListings"`
	ProductVariantChannelListings ProductVariantChannelListingSlice `boil:"ProductVariantChannelListings" json:"ProductVariantChannelListings" toml:"ProductVariantChannelListings" yaml:"ProductVariantChannelListings"`
	PromotionRuleChannels         PromotionRuleChannelSlice         `boil:"PromotionRuleChannels" json:"PromotionRuleChannels" toml:"PromotionRuleChannels" yaml:"PromotionRuleChannels"`
	SaleChannelListings           SaleChannelListingSlice           `boil:"SaleChannelListings" json:"SaleChannelListings" toml:"SaleChannelListings" yaml:"SaleChannelListings"`
	ShippingMethodChannelListings ShippingMethodChannelListingSlice `boil:"ShippingMethodChannelListings" json:"ShippingMethodChannelListings" toml:"ShippingMethodChannelListings" yaml:"ShippingMethodChannelListings"`
	ShippingZoneChannels          ShippingZoneChannelSlice          `boil:"ShippingZoneChannels" json:"ShippingZoneChannels" toml:"ShippingZoneChannels" yaml:"ShippingZoneChannels"`
	TaxConfigurations             TaxConfigurationSlice             `boil:"TaxConfigurations" json:"TaxConfigurations" toml:"TaxConfigurations" yaml:"TaxConfigurations"`
	VoucherChannelListings        VoucherChannelListingSlice        `boil:"VoucherChannelListings" json:"VoucherChannelListings" toml:"VoucherChannelListings" yaml:"VoucherChannelListings"`
}

// NewStruct creates a new relationship struct
func (*channelR) NewStruct() *channelR {
	return &channelR{}
}

func (r *channelR) GetCheckouts() CheckoutSlice {
	if r == nil {
		return nil
	}
	return r.Checkouts
}

func (r *channelR) GetCollectionChannelListings() CollectionChannelListingSlice {
	if r == nil {
		return nil
	}
	return r.CollectionChannelListings
}

func (r *channelR) GetOrders() OrderSlice {
	if r == nil {
		return nil
	}
	return r.Orders
}

func (r *channelR) GetPluginConfigurations() PluginConfigurationSlice {
	if r == nil {
		return nil
	}
	return r.PluginConfigurations
}

func (r *channelR) GetProductChannelListings() ProductChannelListingSlice {
	if r == nil {
		return nil
	}
	return r.ProductChannelListings
}

func (r *channelR) GetProductVariantChannelListings() ProductVariantChannelListingSlice {
	if r == nil {
		return nil
	}
	return r.ProductVariantChannelListings
}

func (r *channelR) GetPromotionRuleChannels() PromotionRuleChannelSlice {
	if r == nil {
		return nil
	}
	return r.PromotionRuleChannels
}

func (r *channelR) GetSaleChannelListings() SaleChannelListingSlice {
	if r == nil {
		return nil
	}
	return r.SaleChannelListings
}

func (r *channelR) GetShippingMethodChannelListings() ShippingMethodChannelListingSlice {
	if r == nil {
		return nil
	}
	return r.ShippingMethodChannelListings
}

func (r *channelR) GetShippingZoneChannels() ShippingZoneChannelSlice {
	if r == nil {
		return nil
	}
	return r.ShippingZoneChannels
}

func (r *channelR) GetTaxConfigurations() TaxConfigurationSlice {
	if r == nil {
		return nil
	}
	return r.TaxConfigurations
}

func (r *channelR) GetVoucherChannelListings() VoucherChannelListingSlice {
	if r == nil {
		return nil
	}
	return r.VoucherChannelListings
}

// channelL is where Load methods for each relationship are stored.
type channelL struct{}

var (
	channelAllColumns            = []string{"id", "name", "is_active", "slug", "currency", "default_country", "allocation_strategy", "order_mark_as_paid_strategy", "default_transaction_flow_strategy", "automatically_confirm_all_new_orders", "allow_unpaid_orders", "automatically_fulfill_non_shippable_gift_card", "expire_orders_after", "delete_expired_orders_after", "include_darft_order_is_voucher_usage", "automatically_complete_fully_paid_checkouts", "annotations"}
	channelColumnsWithoutDefault = []string{"id", "name", "is_active", "slug", "currency", "default_country"}
	channelColumnsWithDefault    = []string{"allocation_strategy", "order_mark_as_paid_strategy", "default_transaction_flow_strategy", "automatically_confirm_all_new_orders", "allow_unpaid_orders", "automatically_fulfill_non_shippable_gift_card", "expire_orders_after", "delete_expired_orders_after", "include_darft_order_is_voucher_usage", "automatically_complete_fully_paid_checkouts", "annotations"}
	channelPrimaryKeyColumns     = []string{"id"}
	channelGeneratedColumns      = []string{}
)

type (
	// ChannelSlice is an alias for a slice of pointers to Channel.
	// This should almost always be used instead of []Channel.
	ChannelSlice []*Channel

	channelQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	channelType                 = reflect.TypeOf(&Channel{})
	channelMapping              = queries.MakeStructMapping(channelType)
	channelPrimaryKeyMapping, _ = queries.BindMapping(channelType, channelMapping, channelPrimaryKeyColumns)
	channelInsertCacheMut       sync.RWMutex
	channelInsertCache          = make(map[string]insertCache)
	channelUpdateCacheMut       sync.RWMutex
	channelUpdateCache          = make(map[string]updateCache)
	channelUpsertCacheMut       sync.RWMutex
	channelUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single channel record from the query.
func (q channelQuery) One(exec boil.Executor) (*Channel, error) {
	o := &Channel{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for channels")
	}

	return o, nil
}

// All returns all Channel records from the query.
func (q channelQuery) All(exec boil.Executor) (ChannelSlice, error) {
	var o []*Channel

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to Channel slice")
	}

	return o, nil
}

// Count returns the count of all Channel records in the query.
func (q channelQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count channels rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q channelQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if channels exists")
	}

	return count > 0, nil
}

// Checkouts retrieves all the checkout's Checkouts with an executor.
func (o *Channel) Checkouts(mods ...qm.QueryMod) checkoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"checkouts\".\"channel_id\"=?", o.ID),
	)

	return Checkouts(queryMods...)
}

// CollectionChannelListings retrieves all the collection_channel_listing's CollectionChannelListings with an executor.
func (o *Channel) CollectionChannelListings(mods ...qm.QueryMod) collectionChannelListingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"collection_channel_listings\".\"channel_id\"=?", o.ID),
	)

	return CollectionChannelListings(queryMods...)
}

// Orders retrieves all the order's Orders with an executor.
func (o *Channel) Orders(mods ...qm.QueryMod) orderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"orders\".\"channel_id\"=?", o.ID),
	)

	return Orders(queryMods...)
}

// PluginConfigurations retrieves all the plugin_configuration's PluginConfigurations with an executor.
func (o *Channel) PluginConfigurations(mods ...qm.QueryMod) pluginConfigurationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"plugin_configurations\".\"channel_id\"=?", o.ID),
	)

	return PluginConfigurations(queryMods...)
}

// ProductChannelListings retrieves all the product_channel_listing's ProductChannelListings with an executor.
func (o *Channel) ProductChannelListings(mods ...qm.QueryMod) productChannelListingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"product_channel_listings\".\"channel_id\"=?", o.ID),
	)

	return ProductChannelListings(queryMods...)
}

// ProductVariantChannelListings retrieves all the product_variant_channel_listing's ProductVariantChannelListings with an executor.
func (o *Channel) ProductVariantChannelListings(mods ...qm.QueryMod) productVariantChannelListingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"product_variant_channel_listings\".\"channel_id\"=?", o.ID),
	)

	return ProductVariantChannelListings(queryMods...)
}

// PromotionRuleChannels retrieves all the promotion_rule_channel's PromotionRuleChannels with an executor.
func (o *Channel) PromotionRuleChannels(mods ...qm.QueryMod) promotionRuleChannelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"promotion_rule_channels\".\"channel_id\"=?", o.ID),
	)

	return PromotionRuleChannels(queryMods...)
}

// SaleChannelListings retrieves all the sale_channel_listing's SaleChannelListings with an executor.
func (o *Channel) SaleChannelListings(mods ...qm.QueryMod) saleChannelListingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"sale_channel_listings\".\"channel_id\"=?", o.ID),
	)

	return SaleChannelListings(queryMods...)
}

// ShippingMethodChannelListings retrieves all the shipping_method_channel_listing's ShippingMethodChannelListings with an executor.
func (o *Channel) ShippingMethodChannelListings(mods ...qm.QueryMod) shippingMethodChannelListingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"shipping_method_channel_listings\".\"channel_id\"=?", o.ID),
	)

	return ShippingMethodChannelListings(queryMods...)
}

// ShippingZoneChannels retrieves all the shipping_zone_channel's ShippingZoneChannels with an executor.
func (o *Channel) ShippingZoneChannels(mods ...qm.QueryMod) shippingZoneChannelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"shipping_zone_channels\".\"channel_id\"=?", o.ID),
	)

	return ShippingZoneChannels(queryMods...)
}

// TaxConfigurations retrieves all the tax_configuration's TaxConfigurations with an executor.
func (o *Channel) TaxConfigurations(mods ...qm.QueryMod) taxConfigurationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"tax_configurations\".\"channel_id\"=?", o.ID),
	)

	return TaxConfigurations(queryMods...)
}

// VoucherChannelListings retrieves all the voucher_channel_listing's VoucherChannelListings with an executor.
func (o *Channel) VoucherChannelListings(mods ...qm.QueryMod) voucherChannelListingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"voucher_channel_listings\".\"channel_id\"=?", o.ID),
	)

	return VoucherChannelListings(queryMods...)
}

// LoadCheckouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadCheckouts(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`checkouts`),
		qm.WhereIn(`checkouts.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load checkouts")
	}

	var resultSlice []*Checkout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice checkouts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on checkouts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for checkouts")
	}

	if singular {
		object.R.Checkouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &checkoutR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Checkouts = append(local.R.Checkouts, foreign)
				if foreign.R == nil {
					foreign.R = &checkoutR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadCollectionChannelListings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadCollectionChannelListings(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`collection_channel_listings`),
		qm.WhereIn(`collection_channel_listings.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load collection_channel_listings")
	}

	var resultSlice []*CollectionChannelListing
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice collection_channel_listings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on collection_channel_listings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for collection_channel_listings")
	}

	if singular {
		object.R.CollectionChannelListings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &collectionChannelListingR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ChannelID) {
				local.R.CollectionChannelListings = append(local.R.CollectionChannelListings, foreign)
				if foreign.R == nil {
					foreign.R = &collectionChannelListingR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadOrders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadOrders(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`orders`),
		qm.WhereIn(`orders.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load orders")
	}

	var resultSlice []*Order
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice orders")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on orders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orders")
	}

	if singular {
		object.R.Orders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.Orders = append(local.R.Orders, foreign)
				if foreign.R == nil {
					foreign.R = &orderR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadPluginConfigurations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadPluginConfigurations(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`plugin_configurations`),
		qm.WhereIn(`plugin_configurations.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load plugin_configurations")
	}

	var resultSlice []*PluginConfiguration
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice plugin_configurations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on plugin_configurations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for plugin_configurations")
	}

	if singular {
		object.R.PluginConfigurations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pluginConfigurationR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.PluginConfigurations = append(local.R.PluginConfigurations, foreign)
				if foreign.R == nil {
					foreign.R = &pluginConfigurationR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadProductChannelListings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadProductChannelListings(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`product_channel_listings`),
		qm.WhereIn(`product_channel_listings.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load product_channel_listings")
	}

	var resultSlice []*ProductChannelListing
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice product_channel_listings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on product_channel_listings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_channel_listings")
	}

	if singular {
		object.R.ProductChannelListings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &productChannelListingR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.ProductChannelListings = append(local.R.ProductChannelListings, foreign)
				if foreign.R == nil {
					foreign.R = &productChannelListingR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadProductVariantChannelListings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadProductVariantChannelListings(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`product_variant_channel_listings`),
		qm.WhereIn(`product_variant_channel_listings.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load product_variant_channel_listings")
	}

	var resultSlice []*ProductVariantChannelListing
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice product_variant_channel_listings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on product_variant_channel_listings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_variant_channel_listings")
	}

	if singular {
		object.R.ProductVariantChannelListings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &productVariantChannelListingR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.ProductVariantChannelListings = append(local.R.ProductVariantChannelListings, foreign)
				if foreign.R == nil {
					foreign.R = &productVariantChannelListingR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadPromotionRuleChannels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadPromotionRuleChannels(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`promotion_rule_channels`),
		qm.WhereIn(`promotion_rule_channels.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load promotion_rule_channels")
	}

	var resultSlice []*PromotionRuleChannel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice promotion_rule_channels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on promotion_rule_channels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for promotion_rule_channels")
	}

	if singular {
		object.R.PromotionRuleChannels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &promotionRuleChannelR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.PromotionRuleChannels = append(local.R.PromotionRuleChannels, foreign)
				if foreign.R == nil {
					foreign.R = &promotionRuleChannelR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadSaleChannelListings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadSaleChannelListings(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`sale_channel_listings`),
		qm.WhereIn(`sale_channel_listings.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load sale_channel_listings")
	}

	var resultSlice []*SaleChannelListing
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice sale_channel_listings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on sale_channel_listings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sale_channel_listings")
	}

	if singular {
		object.R.SaleChannelListings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &saleChannelListingR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.SaleChannelListings = append(local.R.SaleChannelListings, foreign)
				if foreign.R == nil {
					foreign.R = &saleChannelListingR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadShippingMethodChannelListings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadShippingMethodChannelListings(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`shipping_method_channel_listings`),
		qm.WhereIn(`shipping_method_channel_listings.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load shipping_method_channel_listings")
	}

	var resultSlice []*ShippingMethodChannelListing
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice shipping_method_channel_listings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on shipping_method_channel_listings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for shipping_method_channel_listings")
	}

	if singular {
		object.R.ShippingMethodChannelListings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &shippingMethodChannelListingR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.ShippingMethodChannelListings = append(local.R.ShippingMethodChannelListings, foreign)
				if foreign.R == nil {
					foreign.R = &shippingMethodChannelListingR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadShippingZoneChannels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadShippingZoneChannels(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`shipping_zone_channels`),
		qm.WhereIn(`shipping_zone_channels.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load shipping_zone_channels")
	}

	var resultSlice []*ShippingZoneChannel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice shipping_zone_channels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on shipping_zone_channels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for shipping_zone_channels")
	}

	if singular {
		object.R.ShippingZoneChannels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &shippingZoneChannelR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.ShippingZoneChannels = append(local.R.ShippingZoneChannels, foreign)
				if foreign.R == nil {
					foreign.R = &shippingZoneChannelR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadTaxConfigurations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadTaxConfigurations(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`tax_configurations`),
		qm.WhereIn(`tax_configurations.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load tax_configurations")
	}

	var resultSlice []*TaxConfiguration
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice tax_configurations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on tax_configurations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tax_configurations")
	}

	if singular {
		object.R.TaxConfigurations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &taxConfigurationR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.TaxConfigurations = append(local.R.TaxConfigurations, foreign)
				if foreign.R == nil {
					foreign.R = &taxConfigurationR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// LoadVoucherChannelListings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (channelL) LoadVoucherChannelListings(e boil.Executor, singular bool, maybeChannel interface{}, mods queries.Applicator) error {
	var slice []*Channel
	var object *Channel

	if singular {
		var ok bool
		object, ok = maybeChannel.(*Channel)
		if !ok {
			object = new(Channel)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeChannel))
			}
		}
	} else {
		s, ok := maybeChannel.(*[]*Channel)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeChannel)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeChannel))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &channelR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &channelR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`voucher_channel_listings`),
		qm.WhereIn(`voucher_channel_listings.channel_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load voucher_channel_listings")
	}

	var resultSlice []*VoucherChannelListing
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice voucher_channel_listings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on voucher_channel_listings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for voucher_channel_listings")
	}

	if singular {
		object.R.VoucherChannelListings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &voucherChannelListingR{}
			}
			foreign.R.Channel = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ChannelID {
				local.R.VoucherChannelListings = append(local.R.VoucherChannelListings, foreign)
				if foreign.R == nil {
					foreign.R = &voucherChannelListingR{}
				}
				foreign.R.Channel = local
				break
			}
		}
	}

	return nil
}

// AddCheckouts adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Checkouts.
// Sets related.R.Channel appropriately.
func (o *Channel) AddCheckouts(exec boil.Executor, insert bool, related ...*Checkout) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"checkouts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, checkoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.Token}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Checkouts: related,
		}
	} else {
		o.R.Checkouts = append(o.R.Checkouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &checkoutR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddCollectionChannelListings adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.CollectionChannelListings.
// Sets related.R.Channel appropriately.
func (o *Channel) AddCollectionChannelListings(exec boil.Executor, insert bool, related ...*CollectionChannelListing) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ChannelID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"collection_channel_listings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, collectionChannelListingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ChannelID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &channelR{
			CollectionChannelListings: related,
		}
	} else {
		o.R.CollectionChannelListings = append(o.R.CollectionChannelListings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &collectionChannelListingR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// SetCollectionChannelListings removes all previously related items of the
// channel replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Channel's CollectionChannelListings accordingly.
// Replaces o.R.CollectionChannelListings with related.
// Sets related.R.Channel's CollectionChannelListings accordingly.
func (o *Channel) SetCollectionChannelListings(exec boil.Executor, insert bool, related ...*CollectionChannelListing) error {
	query := "update \"collection_channel_listings\" set \"channel_id\" = null where \"channel_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CollectionChannelListings {
			queries.SetScanner(&rel.ChannelID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Channel = nil
		}
		o.R.CollectionChannelListings = nil
	}

	return o.AddCollectionChannelListings(exec, insert, related...)
}

// RemoveCollectionChannelListings relationships from objects passed in.
// Removes related items from R.CollectionChannelListings (uses pointer comparison, removal does not keep order)
// Sets related.R.Channel.
func (o *Channel) RemoveCollectionChannelListings(exec boil.Executor, related ...*CollectionChannelListing) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ChannelID, nil)
		if rel.R != nil {
			rel.R.Channel = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("channel_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CollectionChannelListings {
			if rel != ri {
				continue
			}

			ln := len(o.R.CollectionChannelListings)
			if ln > 1 && i < ln-1 {
				o.R.CollectionChannelListings[i] = o.R.CollectionChannelListings[ln-1]
			}
			o.R.CollectionChannelListings = o.R.CollectionChannelListings[:ln-1]
			break
		}
	}

	return nil
}

// AddOrders adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.Orders.
// Sets related.R.Channel appropriately.
func (o *Channel) AddOrders(exec boil.Executor, insert bool, related ...*Order) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"orders\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, orderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			Orders: related,
		}
	} else {
		o.R.Orders = append(o.R.Orders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddPluginConfigurations adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.PluginConfigurations.
// Sets related.R.Channel appropriately.
func (o *Channel) AddPluginConfigurations(exec boil.Executor, insert bool, related ...*PluginConfiguration) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"plugin_configurations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, pluginConfigurationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			PluginConfigurations: related,
		}
	} else {
		o.R.PluginConfigurations = append(o.R.PluginConfigurations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pluginConfigurationR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddProductChannelListings adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.ProductChannelListings.
// Sets related.R.Channel appropriately.
func (o *Channel) AddProductChannelListings(exec boil.Executor, insert bool, related ...*ProductChannelListing) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"product_channel_listings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, productChannelListingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			ProductChannelListings: related,
		}
	} else {
		o.R.ProductChannelListings = append(o.R.ProductChannelListings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &productChannelListingR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddProductVariantChannelListings adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.ProductVariantChannelListings.
// Sets related.R.Channel appropriately.
func (o *Channel) AddProductVariantChannelListings(exec boil.Executor, insert bool, related ...*ProductVariantChannelListing) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"product_variant_channel_listings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, productVariantChannelListingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			ProductVariantChannelListings: related,
		}
	} else {
		o.R.ProductVariantChannelListings = append(o.R.ProductVariantChannelListings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &productVariantChannelListingR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddPromotionRuleChannels adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.PromotionRuleChannels.
// Sets related.R.Channel appropriately.
func (o *Channel) AddPromotionRuleChannels(exec boil.Executor, insert bool, related ...*PromotionRuleChannel) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"promotion_rule_channels\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, promotionRuleChannelPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			PromotionRuleChannels: related,
		}
	} else {
		o.R.PromotionRuleChannels = append(o.R.PromotionRuleChannels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &promotionRuleChannelR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddSaleChannelListings adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.SaleChannelListings.
// Sets related.R.Channel appropriately.
func (o *Channel) AddSaleChannelListings(exec boil.Executor, insert bool, related ...*SaleChannelListing) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"sale_channel_listings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, saleChannelListingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			SaleChannelListings: related,
		}
	} else {
		o.R.SaleChannelListings = append(o.R.SaleChannelListings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &saleChannelListingR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddShippingMethodChannelListings adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.ShippingMethodChannelListings.
// Sets related.R.Channel appropriately.
func (o *Channel) AddShippingMethodChannelListings(exec boil.Executor, insert bool, related ...*ShippingMethodChannelListing) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"shipping_method_channel_listings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, shippingMethodChannelListingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			ShippingMethodChannelListings: related,
		}
	} else {
		o.R.ShippingMethodChannelListings = append(o.R.ShippingMethodChannelListings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &shippingMethodChannelListingR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddShippingZoneChannels adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.ShippingZoneChannels.
// Sets related.R.Channel appropriately.
func (o *Channel) AddShippingZoneChannels(exec boil.Executor, insert bool, related ...*ShippingZoneChannel) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"shipping_zone_channels\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, shippingZoneChannelPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			ShippingZoneChannels: related,
		}
	} else {
		o.R.ShippingZoneChannels = append(o.R.ShippingZoneChannels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &shippingZoneChannelR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddTaxConfigurations adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.TaxConfigurations.
// Sets related.R.Channel appropriately.
func (o *Channel) AddTaxConfigurations(exec boil.Executor, insert bool, related ...*TaxConfiguration) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"tax_configurations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, taxConfigurationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			TaxConfigurations: related,
		}
	} else {
		o.R.TaxConfigurations = append(o.R.TaxConfigurations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &taxConfigurationR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// AddVoucherChannelListings adds the given related objects to the existing relationships
// of the channel, optionally inserting them as new records.
// Appends related to o.R.VoucherChannelListings.
// Sets related.R.Channel appropriately.
func (o *Channel) AddVoucherChannelListings(exec boil.Executor, insert bool, related ...*VoucherChannelListing) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ChannelID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"voucher_channel_listings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"channel_id"}),
				strmangle.WhereClause("\"", "\"", 2, voucherChannelListingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ChannelID = o.ID
		}
	}

	if o.R == nil {
		o.R = &channelR{
			VoucherChannelListings: related,
		}
	} else {
		o.R.VoucherChannelListings = append(o.R.VoucherChannelListings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &voucherChannelListingR{
				Channel: o,
			}
		} else {
			rel.R.Channel = o
		}
	}
	return nil
}

// Channels retrieves all the records using an executor.
func Channels(mods ...qm.QueryMod) channelQuery {
	mods = append(mods, qm.From("\"channels\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"channels\".*"})
	}

	return channelQuery{q}
}

// FindChannel retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindChannel(exec boil.Executor, iD string, selectCols ...string) (*Channel, error) {
	channelObj := &Channel{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"channels\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, channelObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from channels")
	}

	return channelObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Channel) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no channels provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(channelColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	channelInsertCacheMut.RLock()
	cache, cached := channelInsertCache[key]
	channelInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			channelAllColumns,
			channelColumnsWithDefault,
			channelColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(channelType, channelMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"channels\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"channels\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into channels")
	}

	if !cached {
		channelInsertCacheMut.Lock()
		channelInsertCache[key] = cache
		channelInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Channel.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Channel) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	channelUpdateCacheMut.RLock()
	cache, cached := channelUpdateCache[key]
	channelUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			channelAllColumns,
			channelPrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("model: unable to update channels, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"channels\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, channelPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, append(wl, channelPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update channels row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by update for channels")
	}

	if !cached {
		channelUpdateCacheMut.Lock()
		channelUpdateCache[key] = cache
		channelUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q channelQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all for channels")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected for channels")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ChannelSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"channels\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, channelPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to update all in channel slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to retrieve rows affected all in update all channel")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Channel) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("model: no channels provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(channelColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	channelUpsertCacheMut.RLock()
	cache, cached := channelUpsertCache[key]
	channelUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			channelAllColumns,
			channelColumnsWithDefault,
			channelColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			channelAllColumns,
			channelPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("model: unable to upsert channels, could not build update column list")
		}

		ret := strmangle.SetComplement(channelAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(channelPrimaryKeyColumns) == 0 {
				return errors.New("model: unable to upsert channels, could not build conflict column list")
			}

			conflict = make([]string, len(channelPrimaryKeyColumns))
			copy(conflict, channelPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"channels\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(channelType, channelMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(channelType, channelMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "model: unable to upsert channels")
	}

	if !cached {
		channelUpsertCacheMut.Lock()
		channelUpsertCache[key] = cache
		channelUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Channel record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Channel) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("model: no Channel provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), channelPrimaryKeyMapping)
	sql := "DELETE FROM \"channels\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete from channels")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by delete for channels")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q channelQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("model: no channelQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from channels")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for channels")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ChannelSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"channels\" WHERE " +
		strmangle.WhereInClause(string(dialect.LQ), string(dialect.RQ), 1, channelPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "model: unable to delete all from channel slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to get rows affected by deleteall for channels")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Channel) Reload(exec boil.Executor) error {
	ret, err := FindChannel(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ChannelSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ChannelSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), channelPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"channels\".* FROM \"channels\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, channelPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in ChannelSlice")
	}

	*o = slice

	return nil
}

// ChannelExists checks if the Channel row exists.
func ChannelExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"channels\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if channels exists")
	}

	return exists, nil
}

// Exists checks if the Channel row exists.
func (o *Channel) Exists(exec boil.Executor) (bool, error) {
	return ChannelExists(exec, o.ID)
}
