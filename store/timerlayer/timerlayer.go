// Code generated by "make store-layers"
// DO NOT EDIT

package timerlayer

import (
	"context"
	timemodule "time"

	"github.com/site-name/decimal"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/einterfaces"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/model/account"
	"github.com/sitename/sitename/model/app"
	"github.com/sitename/sitename/model/attribute"
	"github.com/sitename/sitename/model/audit"
	"github.com/sitename/sitename/model/channel"
	"github.com/sitename/sitename/model/checkout"
	"github.com/sitename/sitename/model/cluster"
	"github.com/sitename/sitename/model/compliance"
	"github.com/sitename/sitename/model/csv"
	"github.com/sitename/sitename/model/file"
	"github.com/sitename/sitename/model/giftcard"
	"github.com/sitename/sitename/model/menu"
	"github.com/sitename/sitename/model/order"
	"github.com/sitename/sitename/model/payment"
	"github.com/sitename/sitename/model/plugins"
	"github.com/sitename/sitename/model/product_and_discount"
	"github.com/sitename/sitename/model/shipping"
	"github.com/sitename/sitename/model/shop"
	"github.com/sitename/sitename/model/warehouse"
	"github.com/sitename/sitename/model/wishlist"
	"github.com/sitename/sitename/modules/measurement"
	"github.com/sitename/sitename/store"
)

type TimerLayer struct {
	store.Store
	Metrics                            einterfaces.MetricsInterface
	AddressStore                       store.AddressStore
	AllocationStore                    store.AllocationStore
	AppStore                           store.AppStore
	AppTokenStore                      store.AppTokenStore
	AssignedPageAttributeStore         store.AssignedPageAttributeStore
	AssignedPageAttributeValueStore    store.AssignedPageAttributeValueStore
	AssignedProductAttributeStore      store.AssignedProductAttributeStore
	AssignedProductAttributeValueStore store.AssignedProductAttributeValueStore
	AssignedVariantAttributeStore      store.AssignedVariantAttributeStore
	AssignedVariantAttributeValueStore store.AssignedVariantAttributeValueStore
	AttributeStore                     store.AttributeStore
	AttributePageStore                 store.AttributePageStore
	AttributeProductStore              store.AttributeProductStore
	AttributeTranslationStore          store.AttributeTranslationStore
	AttributeValueStore                store.AttributeValueStore
	AttributeValueTranslationStore     store.AttributeValueTranslationStore
	AttributeVariantStore              store.AttributeVariantStore
	AuditStore                         store.AuditStore
	CategoryStore                      store.CategoryStore
	CategoryTranslationStore           store.CategoryTranslationStore
	ChannelStore                       store.ChannelStore
	CheckoutStore                      store.CheckoutStore
	CheckoutLineStore                  store.CheckoutLineStore
	ClusterDiscoveryStore              store.ClusterDiscoveryStore
	CollectionStore                    store.CollectionStore
	CollectionChannelListingStore      store.CollectionChannelListingStore
	CollectionProductStore             store.CollectionProductStore
	CollectionTranslationStore         store.CollectionTranslationStore
	ComplianceStore                    store.ComplianceStore
	CsvExportEventStore                store.CsvExportEventStore
	CsvExportFileStore                 store.CsvExportFileStore
	CustomerEventStore                 store.CustomerEventStore
	CustomerNoteStore                  store.CustomerNoteStore
	DigitalContentStore                store.DigitalContentStore
	DigitalContentUrlStore             store.DigitalContentUrlStore
	DiscountSaleStore                  store.DiscountSaleStore
	DiscountSaleChannelListingStore    store.DiscountSaleChannelListingStore
	DiscountSaleTranslationStore       store.DiscountSaleTranslationStore
	DiscountVoucherStore               store.DiscountVoucherStore
	FileInfoStore                      store.FileInfoStore
	FulfillmentStore                   store.FulfillmentStore
	FulfillmentLineStore               store.FulfillmentLineStore
	GiftCardStore                      store.GiftCardStore
	GiftCardCheckoutStore              store.GiftCardCheckoutStore
	GiftCardOrderStore                 store.GiftCardOrderStore
	InvoiceEventStore                  store.InvoiceEventStore
	JobStore                           store.JobStore
	MenuStore                          store.MenuStore
	MenuItemStore                      store.MenuItemStore
	MenuItemTranslationStore           store.MenuItemTranslationStore
	OrderStore                         store.OrderStore
	OrderDiscountStore                 store.OrderDiscountStore
	OrderEventStore                    store.OrderEventStore
	OrderLineStore                     store.OrderLineStore
	PageStore                          store.PageStore
	PageTranslationStore               store.PageTranslationStore
	PageTypeStore                      store.PageTypeStore
	PaymentStore                       store.PaymentStore
	PaymentTransactionStore            store.PaymentTransactionStore
	PluginStore                        store.PluginStore
	PluginConfigurationStore           store.PluginConfigurationStore
	PreferenceStore                    store.PreferenceStore
	ProductStore                       store.ProductStore
	ProductChannelListingStore         store.ProductChannelListingStore
	ProductMediaStore                  store.ProductMediaStore
	ProductTranslationStore            store.ProductTranslationStore
	ProductTypeStore                   store.ProductTypeStore
	ProductVariantStore                store.ProductVariantStore
	ProductVariantChannelListingStore  store.ProductVariantChannelListingStore
	ProductVariantTranslationStore     store.ProductVariantTranslationStore
	RoleStore                          store.RoleStore
	SessionStore                       store.SessionStore
	ShippingMethodStore                store.ShippingMethodStore
	ShippingMethodChannelListingStore  store.ShippingMethodChannelListingStore
	ShippingMethodExcludedProductStore store.ShippingMethodExcludedProductStore
	ShippingMethodPostalCodeRuleStore  store.ShippingMethodPostalCodeRuleStore
	ShippingMethodTranslationStore     store.ShippingMethodTranslationStore
	ShippingZoneStore                  store.ShippingZoneStore
	ShippingZoneChannelStore           store.ShippingZoneChannelStore
	ShopStore                          store.ShopStore
	ShopStaffStore                     store.ShopStaffStore
	ShopTranslationStore               store.ShopTranslationStore
	StaffNotificationRecipientStore    store.StaffNotificationRecipientStore
	StatusStore                        store.StatusStore
	StockStore                         store.StockStore
	SystemStore                        store.SystemStore
	TermsOfServiceStore                store.TermsOfServiceStore
	TokenStore                         store.TokenStore
	UploadSessionStore                 store.UploadSessionStore
	UserStore                          store.UserStore
	UserAccessTokenStore               store.UserAccessTokenStore
	UserAddressStore                   store.UserAddressStore
	UserTermOfServiceStore             store.UserTermOfServiceStore
	VariantMediaStore                  store.VariantMediaStore
	VoucherCategoryStore               store.VoucherCategoryStore
	VoucherChannelListingStore         store.VoucherChannelListingStore
	VoucherCollectionStore             store.VoucherCollectionStore
	VoucherCustomerStore               store.VoucherCustomerStore
	VoucherProductStore                store.VoucherProductStore
	VoucherTranslationStore            store.VoucherTranslationStore
	WarehouseStore                     store.WarehouseStore
	WarehouseShippingZoneStore         store.WarehouseShippingZoneStore
	WishlistStore                      store.WishlistStore
	WishlistItemStore                  store.WishlistItemStore
	WishlistProductVariantStore        store.WishlistProductVariantStore
}

func (s *TimerLayer) Address() store.AddressStore {
	return s.AddressStore
}

func (s *TimerLayer) Allocation() store.AllocationStore {
	return s.AllocationStore
}

func (s *TimerLayer) App() store.AppStore {
	return s.AppStore
}

func (s *TimerLayer) AppToken() store.AppTokenStore {
	return s.AppTokenStore
}

func (s *TimerLayer) AssignedPageAttribute() store.AssignedPageAttributeStore {
	return s.AssignedPageAttributeStore
}

func (s *TimerLayer) AssignedPageAttributeValue() store.AssignedPageAttributeValueStore {
	return s.AssignedPageAttributeValueStore
}

func (s *TimerLayer) AssignedProductAttribute() store.AssignedProductAttributeStore {
	return s.AssignedProductAttributeStore
}

func (s *TimerLayer) AssignedProductAttributeValue() store.AssignedProductAttributeValueStore {
	return s.AssignedProductAttributeValueStore
}

func (s *TimerLayer) AssignedVariantAttribute() store.AssignedVariantAttributeStore {
	return s.AssignedVariantAttributeStore
}

func (s *TimerLayer) AssignedVariantAttributeValue() store.AssignedVariantAttributeValueStore {
	return s.AssignedVariantAttributeValueStore
}

func (s *TimerLayer) Attribute() store.AttributeStore {
	return s.AttributeStore
}

func (s *TimerLayer) AttributePage() store.AttributePageStore {
	return s.AttributePageStore
}

func (s *TimerLayer) AttributeProduct() store.AttributeProductStore {
	return s.AttributeProductStore
}

func (s *TimerLayer) AttributeTranslation() store.AttributeTranslationStore {
	return s.AttributeTranslationStore
}

func (s *TimerLayer) AttributeValue() store.AttributeValueStore {
	return s.AttributeValueStore
}

func (s *TimerLayer) AttributeValueTranslation() store.AttributeValueTranslationStore {
	return s.AttributeValueTranslationStore
}

func (s *TimerLayer) AttributeVariant() store.AttributeVariantStore {
	return s.AttributeVariantStore
}

func (s *TimerLayer) Audit() store.AuditStore {
	return s.AuditStore
}

func (s *TimerLayer) Category() store.CategoryStore {
	return s.CategoryStore
}

func (s *TimerLayer) CategoryTranslation() store.CategoryTranslationStore {
	return s.CategoryTranslationStore
}

func (s *TimerLayer) Channel() store.ChannelStore {
	return s.ChannelStore
}

func (s *TimerLayer) Checkout() store.CheckoutStore {
	return s.CheckoutStore
}

func (s *TimerLayer) CheckoutLine() store.CheckoutLineStore {
	return s.CheckoutLineStore
}

func (s *TimerLayer) ClusterDiscovery() store.ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *TimerLayer) Collection() store.CollectionStore {
	return s.CollectionStore
}

func (s *TimerLayer) CollectionChannelListing() store.CollectionChannelListingStore {
	return s.CollectionChannelListingStore
}

func (s *TimerLayer) CollectionProduct() store.CollectionProductStore {
	return s.CollectionProductStore
}

func (s *TimerLayer) CollectionTranslation() store.CollectionTranslationStore {
	return s.CollectionTranslationStore
}

func (s *TimerLayer) Compliance() store.ComplianceStore {
	return s.ComplianceStore
}

func (s *TimerLayer) CsvExportEvent() store.CsvExportEventStore {
	return s.CsvExportEventStore
}

func (s *TimerLayer) CsvExportFile() store.CsvExportFileStore {
	return s.CsvExportFileStore
}

func (s *TimerLayer) CustomerEvent() store.CustomerEventStore {
	return s.CustomerEventStore
}

func (s *TimerLayer) CustomerNote() store.CustomerNoteStore {
	return s.CustomerNoteStore
}

func (s *TimerLayer) DigitalContent() store.DigitalContentStore {
	return s.DigitalContentStore
}

func (s *TimerLayer) DigitalContentUrl() store.DigitalContentUrlStore {
	return s.DigitalContentUrlStore
}

func (s *TimerLayer) DiscountSale() store.DiscountSaleStore {
	return s.DiscountSaleStore
}

func (s *TimerLayer) DiscountSaleChannelListing() store.DiscountSaleChannelListingStore {
	return s.DiscountSaleChannelListingStore
}

func (s *TimerLayer) DiscountSaleTranslation() store.DiscountSaleTranslationStore {
	return s.DiscountSaleTranslationStore
}

func (s *TimerLayer) DiscountVoucher() store.DiscountVoucherStore {
	return s.DiscountVoucherStore
}

func (s *TimerLayer) FileInfo() store.FileInfoStore {
	return s.FileInfoStore
}

func (s *TimerLayer) Fulfillment() store.FulfillmentStore {
	return s.FulfillmentStore
}

func (s *TimerLayer) FulfillmentLine() store.FulfillmentLineStore {
	return s.FulfillmentLineStore
}

func (s *TimerLayer) GiftCard() store.GiftCardStore {
	return s.GiftCardStore
}

func (s *TimerLayer) GiftCardCheckout() store.GiftCardCheckoutStore {
	return s.GiftCardCheckoutStore
}

func (s *TimerLayer) GiftCardOrder() store.GiftCardOrderStore {
	return s.GiftCardOrderStore
}

func (s *TimerLayer) InvoiceEvent() store.InvoiceEventStore {
	return s.InvoiceEventStore
}

func (s *TimerLayer) Job() store.JobStore {
	return s.JobStore
}

func (s *TimerLayer) Menu() store.MenuStore {
	return s.MenuStore
}

func (s *TimerLayer) MenuItem() store.MenuItemStore {
	return s.MenuItemStore
}

func (s *TimerLayer) MenuItemTranslation() store.MenuItemTranslationStore {
	return s.MenuItemTranslationStore
}

func (s *TimerLayer) Order() store.OrderStore {
	return s.OrderStore
}

func (s *TimerLayer) OrderDiscount() store.OrderDiscountStore {
	return s.OrderDiscountStore
}

func (s *TimerLayer) OrderEvent() store.OrderEventStore {
	return s.OrderEventStore
}

func (s *TimerLayer) OrderLine() store.OrderLineStore {
	return s.OrderLineStore
}

func (s *TimerLayer) Page() store.PageStore {
	return s.PageStore
}

func (s *TimerLayer) PageTranslation() store.PageTranslationStore {
	return s.PageTranslationStore
}

func (s *TimerLayer) PageType() store.PageTypeStore {
	return s.PageTypeStore
}

func (s *TimerLayer) Payment() store.PaymentStore {
	return s.PaymentStore
}

func (s *TimerLayer) PaymentTransaction() store.PaymentTransactionStore {
	return s.PaymentTransactionStore
}

func (s *TimerLayer) Plugin() store.PluginStore {
	return s.PluginStore
}

func (s *TimerLayer) PluginConfiguration() store.PluginConfigurationStore {
	return s.PluginConfigurationStore
}

func (s *TimerLayer) Preference() store.PreferenceStore {
	return s.PreferenceStore
}

func (s *TimerLayer) Product() store.ProductStore {
	return s.ProductStore
}

func (s *TimerLayer) ProductChannelListing() store.ProductChannelListingStore {
	return s.ProductChannelListingStore
}

func (s *TimerLayer) ProductMedia() store.ProductMediaStore {
	return s.ProductMediaStore
}

func (s *TimerLayer) ProductTranslation() store.ProductTranslationStore {
	return s.ProductTranslationStore
}

func (s *TimerLayer) ProductType() store.ProductTypeStore {
	return s.ProductTypeStore
}

func (s *TimerLayer) ProductVariant() store.ProductVariantStore {
	return s.ProductVariantStore
}

func (s *TimerLayer) ProductVariantChannelListing() store.ProductVariantChannelListingStore {
	return s.ProductVariantChannelListingStore
}

func (s *TimerLayer) ProductVariantTranslation() store.ProductVariantTranslationStore {
	return s.ProductVariantTranslationStore
}

func (s *TimerLayer) Role() store.RoleStore {
	return s.RoleStore
}

func (s *TimerLayer) Session() store.SessionStore {
	return s.SessionStore
}

func (s *TimerLayer) ShippingMethod() store.ShippingMethodStore {
	return s.ShippingMethodStore
}

func (s *TimerLayer) ShippingMethodChannelListing() store.ShippingMethodChannelListingStore {
	return s.ShippingMethodChannelListingStore
}

func (s *TimerLayer) ShippingMethodExcludedProduct() store.ShippingMethodExcludedProductStore {
	return s.ShippingMethodExcludedProductStore
}

func (s *TimerLayer) ShippingMethodPostalCodeRule() store.ShippingMethodPostalCodeRuleStore {
	return s.ShippingMethodPostalCodeRuleStore
}

func (s *TimerLayer) ShippingMethodTranslation() store.ShippingMethodTranslationStore {
	return s.ShippingMethodTranslationStore
}

func (s *TimerLayer) ShippingZone() store.ShippingZoneStore {
	return s.ShippingZoneStore
}

func (s *TimerLayer) ShippingZoneChannel() store.ShippingZoneChannelStore {
	return s.ShippingZoneChannelStore
}

func (s *TimerLayer) Shop() store.ShopStore {
	return s.ShopStore
}

func (s *TimerLayer) ShopStaff() store.ShopStaffStore {
	return s.ShopStaffStore
}

func (s *TimerLayer) ShopTranslation() store.ShopTranslationStore {
	return s.ShopTranslationStore
}

func (s *TimerLayer) StaffNotificationRecipient() store.StaffNotificationRecipientStore {
	return s.StaffNotificationRecipientStore
}

func (s *TimerLayer) Status() store.StatusStore {
	return s.StatusStore
}

func (s *TimerLayer) Stock() store.StockStore {
	return s.StockStore
}

func (s *TimerLayer) System() store.SystemStore {
	return s.SystemStore
}

func (s *TimerLayer) TermsOfService() store.TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *TimerLayer) Token() store.TokenStore {
	return s.TokenStore
}

func (s *TimerLayer) UploadSession() store.UploadSessionStore {
	return s.UploadSessionStore
}

func (s *TimerLayer) User() store.UserStore {
	return s.UserStore
}

func (s *TimerLayer) UserAccessToken() store.UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *TimerLayer) UserAddress() store.UserAddressStore {
	return s.UserAddressStore
}

func (s *TimerLayer) UserTermOfService() store.UserTermOfServiceStore {
	return s.UserTermOfServiceStore
}

func (s *TimerLayer) VariantMedia() store.VariantMediaStore {
	return s.VariantMediaStore
}

func (s *TimerLayer) VoucherCategory() store.VoucherCategoryStore {
	return s.VoucherCategoryStore
}

func (s *TimerLayer) VoucherChannelListing() store.VoucherChannelListingStore {
	return s.VoucherChannelListingStore
}

func (s *TimerLayer) VoucherCollection() store.VoucherCollectionStore {
	return s.VoucherCollectionStore
}

func (s *TimerLayer) VoucherCustomer() store.VoucherCustomerStore {
	return s.VoucherCustomerStore
}

func (s *TimerLayer) VoucherProduct() store.VoucherProductStore {
	return s.VoucherProductStore
}

func (s *TimerLayer) VoucherTranslation() store.VoucherTranslationStore {
	return s.VoucherTranslationStore
}

func (s *TimerLayer) Warehouse() store.WarehouseStore {
	return s.WarehouseStore
}

func (s *TimerLayer) WarehouseShippingZone() store.WarehouseShippingZoneStore {
	return s.WarehouseShippingZoneStore
}

func (s *TimerLayer) Wishlist() store.WishlistStore {
	return s.WishlistStore
}

func (s *TimerLayer) WishlistItem() store.WishlistItemStore {
	return s.WishlistItemStore
}

func (s *TimerLayer) WishlistProductVariant() store.WishlistProductVariantStore {
	return s.WishlistProductVariantStore
}

type TimerLayerAddressStore struct {
	store.AddressStore
	Root *TimerLayer
}

type TimerLayerAllocationStore struct {
	store.AllocationStore
	Root *TimerLayer
}

type TimerLayerAppStore struct {
	store.AppStore
	Root *TimerLayer
}

type TimerLayerAppTokenStore struct {
	store.AppTokenStore
	Root *TimerLayer
}

type TimerLayerAssignedPageAttributeStore struct {
	store.AssignedPageAttributeStore
	Root *TimerLayer
}

type TimerLayerAssignedPageAttributeValueStore struct {
	store.AssignedPageAttributeValueStore
	Root *TimerLayer
}

type TimerLayerAssignedProductAttributeStore struct {
	store.AssignedProductAttributeStore
	Root *TimerLayer
}

type TimerLayerAssignedProductAttributeValueStore struct {
	store.AssignedProductAttributeValueStore
	Root *TimerLayer
}

type TimerLayerAssignedVariantAttributeStore struct {
	store.AssignedVariantAttributeStore
	Root *TimerLayer
}

type TimerLayerAssignedVariantAttributeValueStore struct {
	store.AssignedVariantAttributeValueStore
	Root *TimerLayer
}

type TimerLayerAttributeStore struct {
	store.AttributeStore
	Root *TimerLayer
}

type TimerLayerAttributePageStore struct {
	store.AttributePageStore
	Root *TimerLayer
}

type TimerLayerAttributeProductStore struct {
	store.AttributeProductStore
	Root *TimerLayer
}

type TimerLayerAttributeTranslationStore struct {
	store.AttributeTranslationStore
	Root *TimerLayer
}

type TimerLayerAttributeValueStore struct {
	store.AttributeValueStore
	Root *TimerLayer
}

type TimerLayerAttributeValueTranslationStore struct {
	store.AttributeValueTranslationStore
	Root *TimerLayer
}

type TimerLayerAttributeVariantStore struct {
	store.AttributeVariantStore
	Root *TimerLayer
}

type TimerLayerAuditStore struct {
	store.AuditStore
	Root *TimerLayer
}

type TimerLayerCategoryStore struct {
	store.CategoryStore
	Root *TimerLayer
}

type TimerLayerCategoryTranslationStore struct {
	store.CategoryTranslationStore
	Root *TimerLayer
}

type TimerLayerChannelStore struct {
	store.ChannelStore
	Root *TimerLayer
}

type TimerLayerCheckoutStore struct {
	store.CheckoutStore
	Root *TimerLayer
}

type TimerLayerCheckoutLineStore struct {
	store.CheckoutLineStore
	Root *TimerLayer
}

type TimerLayerClusterDiscoveryStore struct {
	store.ClusterDiscoveryStore
	Root *TimerLayer
}

type TimerLayerCollectionStore struct {
	store.CollectionStore
	Root *TimerLayer
}

type TimerLayerCollectionChannelListingStore struct {
	store.CollectionChannelListingStore
	Root *TimerLayer
}

type TimerLayerCollectionProductStore struct {
	store.CollectionProductStore
	Root *TimerLayer
}

type TimerLayerCollectionTranslationStore struct {
	store.CollectionTranslationStore
	Root *TimerLayer
}

type TimerLayerComplianceStore struct {
	store.ComplianceStore
	Root *TimerLayer
}

type TimerLayerCsvExportEventStore struct {
	store.CsvExportEventStore
	Root *TimerLayer
}

type TimerLayerCsvExportFileStore struct {
	store.CsvExportFileStore
	Root *TimerLayer
}

type TimerLayerCustomerEventStore struct {
	store.CustomerEventStore
	Root *TimerLayer
}

type TimerLayerCustomerNoteStore struct {
	store.CustomerNoteStore
	Root *TimerLayer
}

type TimerLayerDigitalContentStore struct {
	store.DigitalContentStore
	Root *TimerLayer
}

type TimerLayerDigitalContentUrlStore struct {
	store.DigitalContentUrlStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleStore struct {
	store.DiscountSaleStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleChannelListingStore struct {
	store.DiscountSaleChannelListingStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleTranslationStore struct {
	store.DiscountSaleTranslationStore
	Root *TimerLayer
}

type TimerLayerDiscountVoucherStore struct {
	store.DiscountVoucherStore
	Root *TimerLayer
}

type TimerLayerFileInfoStore struct {
	store.FileInfoStore
	Root *TimerLayer
}

type TimerLayerFulfillmentStore struct {
	store.FulfillmentStore
	Root *TimerLayer
}

type TimerLayerFulfillmentLineStore struct {
	store.FulfillmentLineStore
	Root *TimerLayer
}

type TimerLayerGiftCardStore struct {
	store.GiftCardStore
	Root *TimerLayer
}

type TimerLayerGiftCardCheckoutStore struct {
	store.GiftCardCheckoutStore
	Root *TimerLayer
}

type TimerLayerGiftCardOrderStore struct {
	store.GiftCardOrderStore
	Root *TimerLayer
}

type TimerLayerInvoiceEventStore struct {
	store.InvoiceEventStore
	Root *TimerLayer
}

type TimerLayerJobStore struct {
	store.JobStore
	Root *TimerLayer
}

type TimerLayerMenuStore struct {
	store.MenuStore
	Root *TimerLayer
}

type TimerLayerMenuItemStore struct {
	store.MenuItemStore
	Root *TimerLayer
}

type TimerLayerMenuItemTranslationStore struct {
	store.MenuItemTranslationStore
	Root *TimerLayer
}

type TimerLayerOrderStore struct {
	store.OrderStore
	Root *TimerLayer
}

type TimerLayerOrderDiscountStore struct {
	store.OrderDiscountStore
	Root *TimerLayer
}

type TimerLayerOrderEventStore struct {
	store.OrderEventStore
	Root *TimerLayer
}

type TimerLayerOrderLineStore struct {
	store.OrderLineStore
	Root *TimerLayer
}

type TimerLayerPageStore struct {
	store.PageStore
	Root *TimerLayer
}

type TimerLayerPageTranslationStore struct {
	store.PageTranslationStore
	Root *TimerLayer
}

type TimerLayerPageTypeStore struct {
	store.PageTypeStore
	Root *TimerLayer
}

type TimerLayerPaymentStore struct {
	store.PaymentStore
	Root *TimerLayer
}

type TimerLayerPaymentTransactionStore struct {
	store.PaymentTransactionStore
	Root *TimerLayer
}

type TimerLayerPluginStore struct {
	store.PluginStore
	Root *TimerLayer
}

type TimerLayerPluginConfigurationStore struct {
	store.PluginConfigurationStore
	Root *TimerLayer
}

type TimerLayerPreferenceStore struct {
	store.PreferenceStore
	Root *TimerLayer
}

type TimerLayerProductStore struct {
	store.ProductStore
	Root *TimerLayer
}

type TimerLayerProductChannelListingStore struct {
	store.ProductChannelListingStore
	Root *TimerLayer
}

type TimerLayerProductMediaStore struct {
	store.ProductMediaStore
	Root *TimerLayer
}

type TimerLayerProductTranslationStore struct {
	store.ProductTranslationStore
	Root *TimerLayer
}

type TimerLayerProductTypeStore struct {
	store.ProductTypeStore
	Root *TimerLayer
}

type TimerLayerProductVariantStore struct {
	store.ProductVariantStore
	Root *TimerLayer
}

type TimerLayerProductVariantChannelListingStore struct {
	store.ProductVariantChannelListingStore
	Root *TimerLayer
}

type TimerLayerProductVariantTranslationStore struct {
	store.ProductVariantTranslationStore
	Root *TimerLayer
}

type TimerLayerRoleStore struct {
	store.RoleStore
	Root *TimerLayer
}

type TimerLayerSessionStore struct {
	store.SessionStore
	Root *TimerLayer
}

type TimerLayerShippingMethodStore struct {
	store.ShippingMethodStore
	Root *TimerLayer
}

type TimerLayerShippingMethodChannelListingStore struct {
	store.ShippingMethodChannelListingStore
	Root *TimerLayer
}

type TimerLayerShippingMethodExcludedProductStore struct {
	store.ShippingMethodExcludedProductStore
	Root *TimerLayer
}

type TimerLayerShippingMethodPostalCodeRuleStore struct {
	store.ShippingMethodPostalCodeRuleStore
	Root *TimerLayer
}

type TimerLayerShippingMethodTranslationStore struct {
	store.ShippingMethodTranslationStore
	Root *TimerLayer
}

type TimerLayerShippingZoneStore struct {
	store.ShippingZoneStore
	Root *TimerLayer
}

type TimerLayerShippingZoneChannelStore struct {
	store.ShippingZoneChannelStore
	Root *TimerLayer
}

type TimerLayerShopStore struct {
	store.ShopStore
	Root *TimerLayer
}

type TimerLayerShopStaffStore struct {
	store.ShopStaffStore
	Root *TimerLayer
}

type TimerLayerShopTranslationStore struct {
	store.ShopTranslationStore
	Root *TimerLayer
}

type TimerLayerStaffNotificationRecipientStore struct {
	store.StaffNotificationRecipientStore
	Root *TimerLayer
}

type TimerLayerStatusStore struct {
	store.StatusStore
	Root *TimerLayer
}

type TimerLayerStockStore struct {
	store.StockStore
	Root *TimerLayer
}

type TimerLayerSystemStore struct {
	store.SystemStore
	Root *TimerLayer
}

type TimerLayerTermsOfServiceStore struct {
	store.TermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerTokenStore struct {
	store.TokenStore
	Root *TimerLayer
}

type TimerLayerUploadSessionStore struct {
	store.UploadSessionStore
	Root *TimerLayer
}

type TimerLayerUserStore struct {
	store.UserStore
	Root *TimerLayer
}

type TimerLayerUserAccessTokenStore struct {
	store.UserAccessTokenStore
	Root *TimerLayer
}

type TimerLayerUserAddressStore struct {
	store.UserAddressStore
	Root *TimerLayer
}

type TimerLayerUserTermOfServiceStore struct {
	store.UserTermOfServiceStore
	Root *TimerLayer
}

type TimerLayerVariantMediaStore struct {
	store.VariantMediaStore
	Root *TimerLayer
}

type TimerLayerVoucherCategoryStore struct {
	store.VoucherCategoryStore
	Root *TimerLayer
}

type TimerLayerVoucherChannelListingStore struct {
	store.VoucherChannelListingStore
	Root *TimerLayer
}

type TimerLayerVoucherCollectionStore struct {
	store.VoucherCollectionStore
	Root *TimerLayer
}

type TimerLayerVoucherCustomerStore struct {
	store.VoucherCustomerStore
	Root *TimerLayer
}

type TimerLayerVoucherProductStore struct {
	store.VoucherProductStore
	Root *TimerLayer
}

type TimerLayerVoucherTranslationStore struct {
	store.VoucherTranslationStore
	Root *TimerLayer
}

type TimerLayerWarehouseStore struct {
	store.WarehouseStore
	Root *TimerLayer
}

type TimerLayerWarehouseShippingZoneStore struct {
	store.WarehouseShippingZoneStore
	Root *TimerLayer
}

type TimerLayerWishlistStore struct {
	store.WishlistStore
	Root *TimerLayer
}

type TimerLayerWishlistItemStore struct {
	store.WishlistItemStore
	Root *TimerLayer
}

type TimerLayerWishlistProductVariantStore struct {
	store.WishlistProductVariantStore
	Root *TimerLayer
}

func (s *TimerLayerAddressStore) DeleteAddresses(addressIDs []string) error {
	start := timemodule.Now()

	err := s.AddressStore.DeleteAddresses(addressIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.DeleteAddresses", success, elapsed)
	}
	return err
}

func (s *TimerLayerAddressStore) Get(addressID string) (*account.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.Get(addressID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAddressStore) GetAddressesByIDs(addressesIDs []string) ([]*account.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.GetAddressesByIDs(addressesIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.GetAddressesByIDs", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAddressStore) GetAddressesByUserID(userID string) ([]*account.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.GetAddressesByUserID(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.GetAddressesByUserID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAddressStore) Save(address *account.Address) (*account.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.Save(address)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAddressStore) Update(address *account.Address) (*account.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.Update(address)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) AllocationsByParentIDs(parentIDs []string, toWhich warehouse.AllocationsBy) ([]*warehouse.Allocation, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.AllocationsByParentIDs(parentIDs, toWhich)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.AllocationsByParentIDs", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) AllocationsByWhich(parentID string, toWhich warehouse.AllocationsBy) ([]*warehouse.Allocation, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.AllocationsByWhich(parentID, toWhich)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.AllocationsByWhich", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) Get(allocationID string) (*warehouse.Allocation, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.Get(allocationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) Save(allocation *warehouse.Allocation) (*warehouse.Allocation, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.Save(allocation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAppStore) Save(app *app.App) (*app.App, error) {
	start := timemodule.Now()

	result, err := s.AppStore.Save(app)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AppStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAppTokenStore) Save(appToken *app.AppToken) (*app.AppToken, error) {
	start := timemodule.Now()

	result, err := s.AppTokenStore.Save(appToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AppTokenStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) Get(id string) (*attribute.AssignedPageAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) GetByOption(option *attribute.AssignedPageAttributeFilterOption) (*attribute.AssignedPageAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) Save(assignedPageAttr *attribute.AssignedPageAttribute) (*attribute.AssignedPageAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.Save(assignedPageAttr)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) Get(assignedPageAttrValueID string) (*attribute.AssignedPageAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeValueStore.Get(assignedPageAttrValueID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) Save(assignedPageAttrValue *attribute.AssignedPageAttributeValue) (*attribute.AssignedPageAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeValueStore.Save(assignedPageAttrValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*attribute.AssignedPageAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.SaveInBulk", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) SelectForSort(assignmentID string) ([]*attribute.AssignedPageAttributeValue, []*attribute.AttributeValue, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.AssignedPageAttributeValueStore.SelectForSort(assignmentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.SelectForSort", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) UpdateInBulk(attributeValues []*attribute.AssignedPageAttributeValue) error {
	start := timemodule.Now()

	err := s.AssignedPageAttributeValueStore.UpdateInBulk(attributeValues)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.UpdateInBulk", success, elapsed)
	}
	return err
}

func (s *TimerLayerAssignedProductAttributeStore) Get(id string) (*attribute.AssignedProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeStore) GetWithOption(option *attribute.AssignedProductAttributeFilterOption) (*attribute.AssignedProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.GetWithOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.GetWithOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeStore) Save(assignedProductAttribute *attribute.AssignedProductAttribute) (*attribute.AssignedProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.Save(assignedProductAttribute)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) Get(assignedProductAttrValueID string) (*attribute.AssignedProductAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.Get(assignedProductAttrValueID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) Save(assignedProductAttrValue *attribute.AssignedProductAttributeValue) (*attribute.AssignedProductAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.Save(assignedProductAttrValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*attribute.AssignedProductAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.SaveInBulk", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) SelectForSort(assignmentID string) ([]*attribute.AssignedProductAttributeValue, []*attribute.AttributeValue, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.AssignedProductAttributeValueStore.SelectForSort(assignmentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.SelectForSort", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) UpdateInBulk(attributeValues []*attribute.AssignedProductAttributeValue) error {
	start := timemodule.Now()

	err := s.AssignedProductAttributeValueStore.UpdateInBulk(attributeValues)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.UpdateInBulk", success, elapsed)
	}
	return err
}

func (s *TimerLayerAssignedVariantAttributeStore) Get(id string) (*attribute.AssignedVariantAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeStore) GetWithOption(option *attribute.AssignedVariantAttributeFilterOption) (*attribute.AssignedVariantAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeStore.GetWithOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeStore.GetWithOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeStore) Save(assignedVariantAttribute *attribute.AssignedVariantAttribute) (*attribute.AssignedVariantAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeStore.Save(assignedVariantAttribute)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) Get(assignedVariantAttrValueID string) (*attribute.AssignedVariantAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeValueStore.Get(assignedVariantAttrValueID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) Save(assignedVariantAttrValue *attribute.AssignedVariantAttributeValue) (*attribute.AssignedVariantAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeValueStore.Save(assignedVariantAttrValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*attribute.AssignedVariantAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.SaveInBulk", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) SelectForSort(assignmentID string) ([]*attribute.AssignedVariantAttributeValue, []*attribute.AttributeValue, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.AssignedVariantAttributeValueStore.SelectForSort(assignmentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.SelectForSort", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) UpdateInBulk(attributeValues []*attribute.AssignedVariantAttributeValue) error {
	start := timemodule.Now()

	err := s.AssignedVariantAttributeValueStore.UpdateInBulk(attributeValues)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.UpdateInBulk", success, elapsed)
	}
	return err
}

func (s *TimerLayerAttributeStore) Get(id string) (*attribute.Attribute, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) GetAttributesByIds(ids []string) ([]*attribute.Attribute, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.GetAttributesByIds(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.GetAttributesByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) GetBySlug(slug string) (*attribute.Attribute, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.GetBySlug(slug)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.GetBySlug", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) GetProductAndVariantHeaders(ids []string) ([]string, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.GetProductAndVariantHeaders(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.GetProductAndVariantHeaders", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) Save(attr *attribute.Attribute) (*attribute.Attribute, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.Save(attr)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) Get(pageID string) (*attribute.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.Get(pageID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) GetByOption(option *attribute.AttributePageFilterOption) (*attribute.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) Save(page *attribute.AttributePage) (*attribute.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.Save(page)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeProductStore) Get(attributeProductID string) (*attribute.AttributeProduct, error) {
	start := timemodule.Now()

	result, err := s.AttributeProductStore.Get(attributeProductID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeProductStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeProductStore) GetByOption(option *attribute.AttributeProductGetOption) (*attribute.AttributeProduct, error) {
	start := timemodule.Now()

	result, err := s.AttributeProductStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeProductStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeProductStore) Save(attributeProduct *attribute.AttributeProduct) (*attribute.AttributeProduct, error) {
	start := timemodule.Now()

	result, err := s.AttributeProductStore.Save(attributeProduct)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeProductStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Get(attributeID string) (*attribute.AttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Get(attributeID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) GetAllByAttributeID(attributeID string) ([]*attribute.AttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.GetAllByAttributeID(attributeID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.GetAllByAttributeID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Save(attribute *attribute.AttributeValue) (*attribute.AttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Save(attribute)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeVariantStore) Get(attributeVariantID string) (*attribute.AttributeVariant, error) {
	start := timemodule.Now()

	result, err := s.AttributeVariantStore.Get(attributeVariantID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeVariantStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeVariantStore) GetByOption(option *attribute.AttributeVariantFilterOption) (*attribute.AttributeVariant, error) {
	start := timemodule.Now()

	result, err := s.AttributeVariantStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeVariantStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeVariantStore) Save(attributeVariant *attribute.AttributeVariant) (*attribute.AttributeVariant, error) {
	start := timemodule.Now()

	result, err := s.AttributeVariantStore.Save(attributeVariant)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeVariantStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAuditStore) Get(userID string, offset int, limit int) (audit.Audits, error) {
	start := timemodule.Now()

	result, err := s.AuditStore.Get(userID, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAuditStore) PermanentDeleteByUser(userID string) error {
	start := timemodule.Now()

	err := s.AuditStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerAuditStore) Save(audit *audit.Audit) error {
	start := timemodule.Now()

	err := s.AuditStore.Save(audit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) Get(id string) (*channel.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetBySlug(slug string) (*channel.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.GetBySlug(slug)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetBySlug", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetChannelsByIdsAndOrder(ids []string, order string) ([]*channel.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.GetChannelsByIdsAndOrder(ids, order)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetChannelsByIdsAndOrder", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetRandomActiveChannel() (*channel.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.GetRandomActiveChannel()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetRandomActiveChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) Save(ch *channel.Channel) (*channel.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.Save(ch)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) CheckoutsByUserID(userID string, channelActive bool) ([]*checkout.Checkout, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.CheckoutsByUserID(userID, channelActive)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.CheckoutsByUserID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) Get(token string) (*checkout.Checkout, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.Get(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) Upsert(ckout *checkout.Checkout) (*checkout.Checkout, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.Upsert(ckout)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) BulkCreate(checkoutLines []*checkout.CheckoutLine) ([]*checkout.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.BulkCreate(checkoutLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.BulkCreate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) BulkUpdate(checkoutLines []*checkout.CheckoutLine) error {
	start := timemodule.Now()

	err := s.CheckoutLineStore.BulkUpdate(checkoutLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.BulkUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerCheckoutLineStore) CheckoutLinesByCheckoutID(checkoutID string) ([]*checkout.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.CheckoutLinesByCheckoutID(checkoutID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.CheckoutLinesByCheckoutID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) CheckoutLinesByCheckoutWithPrefetch(checkoutID string) ([]*checkout.CheckoutLine, []*product_and_discount.ProductVariant, []*product_and_discount.Product, error) {
	start := timemodule.Now()

	result, resultVar1, resultVar2, err := s.CheckoutLineStore.CheckoutLinesByCheckoutWithPrefetch(checkoutID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.CheckoutLinesByCheckoutWithPrefetch", success, elapsed)
	}
	return result, resultVar1, resultVar2, err
}

func (s *TimerLayerCheckoutLineStore) DeleteLines(checkoutLineIDs []string) error {
	start := timemodule.Now()

	err := s.CheckoutLineStore.DeleteLines(checkoutLineIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.DeleteLines", success, elapsed)
	}
	return err
}

func (s *TimerLayerCheckoutLineStore) Get(id string) (*checkout.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) Upsert(checkoutLine *checkout.CheckoutLine) (*checkout.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.Upsert(checkoutLine)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Cleanup() error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Cleanup", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) Delete(discovery *cluster.ClusterDiscovery) (bool, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.Delete(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Exists(discovery *cluster.ClusterDiscovery) (bool, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.Exists(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Exists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*cluster.ClusterDiscovery, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Save(discovery *cluster.ClusterDiscovery) error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.Save(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) SetLastPingAt(discovery *cluster.ClusterDiscovery) error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.SetLastPingAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerComplianceStore) ComplianceExport(compliance *compliance.Compliance, cursor compliance.ComplianceExportCursor, limit int) ([]*compliance.CompliancePost, compliance.ComplianceExportCursor, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.ComplianceStore.ComplianceExport(compliance, cursor, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.ComplianceExport", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerComplianceStore) Get(id string) (*compliance.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) GetAll(offset int, limit int) (compliance.Compliances, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) MessageExport(cursor compliance.MessageExportCursor, limit int) ([]*compliance.MessageExport, compliance.MessageExportCursor, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.ComplianceStore.MessageExport(cursor, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.MessageExport", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerComplianceStore) Save(compliance *compliance.Compliance) (*compliance.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Save(compliance)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) Update(compliance *compliance.Compliance) (*compliance.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Update(compliance)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportEventStore) Save(event *csv.ExportEvent) (*csv.ExportEvent, error) {
	start := timemodule.Now()

	result, err := s.CsvExportEventStore.Save(event)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportEventStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportFileStore) Get(id string) (*csv.ExportFile, error) {
	start := timemodule.Now()

	result, err := s.CsvExportFileStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportFileStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportFileStore) Save(file *csv.ExportFile) (*csv.ExportFile, error) {
	start := timemodule.Now()

	result, err := s.CsvExportFileStore.Save(file)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportFileStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Count() (int64, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Count()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Get(id string) (*account.CustomerEvent, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) GetEventsByUserID(userID string) ([]*account.CustomerEvent, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.GetEventsByUserID(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.GetEventsByUserID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Save(customemrEvent *account.CustomerEvent) (*account.CustomerEvent, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Save(customemrEvent)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerNoteStore) Get(id string) (*account.CustomerNote, error) {
	start := timemodule.Now()

	result, err := s.CustomerNoteStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerNoteStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerNoteStore) Save(note *account.CustomerNote) (*account.CustomerNote, error) {
	start := timemodule.Now()

	result, err := s.CustomerNoteStore.Save(note)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerNoteStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) FilterSalesByOption(option *product_and_discount.SaleFilterOption) ([]*product_and_discount.Sale, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.FilterSalesByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.FilterSalesByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) Get(saleID string) (*product_and_discount.Sale, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.Get(saleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) Upsert(sale *product_and_discount.Sale) (*product_and_discount.Sale, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.Upsert(sale)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) FilterVouchersByOption(option *product_and_discount.VoucherFilterOption) ([]*product_and_discount.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.FilterVouchersByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.FilterVouchersByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) Get(voucherID string) (*product_and_discount.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.Get(voucherID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) Upsert(voucher *product_and_discount.Voucher) (*product_and_discount.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.Upsert(voucher)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) ClearCaches() {
	start := timemodule.Now()

	s.FileInfoStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) CountAll() (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.CountAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.CountAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Get(id string) (*file.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetByIds(ids []string) ([]*file.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetByIds(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetByPath(path string) (*file.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetByPath(path)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetByPath", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetForUser(userID string) ([]*file.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetFromMaster(id string) (*file.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetFromMaster(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetFromMaster", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetWithOptions(page int, perPage int, opt *file.GetFileInfosOptions) ([]*file.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetWithOptions(page, perPage, opt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) InvalidateFileInfosForPostCache(postID string, deleted bool) {
	start := timemodule.Now()

	s.FileInfoStore.InvalidateFileInfosForPostCache(postID, deleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.InvalidateFileInfosForPostCache", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) PermanentDelete(fileID string) error {
	start := timemodule.Now()

	err := s.FileInfoStore.PermanentDelete(fileID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteByUser(userID string) (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Save(info *file.FileInfo) (*file.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Save(info)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) SetContent(fileID string, content string) error {
	start := timemodule.Now()

	err := s.FileInfoStore.SetContent(fileID, content)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.SetContent", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) Upsert(info *file.FileInfo) (*file.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Upsert(info)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) FilterByExcludeStatuses(orderID string, excludeStatuses []string) (bool, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.FilterByExcludeStatuses(orderID, excludeStatuses)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.FilterByExcludeStatuses", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) Get(id string) (*order.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) Save(fulfillment *order.Fulfillment) (*order.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.Save(fulfillment)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) Get(id string) (*order.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) Save(fulfillmentLine *order.FulfillmentLine) (*order.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.Save(fulfillmentLine)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) FilterByOption(option *giftcard.GiftCardFilterOption) ([]*giftcard.GiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) GetAllByCheckout(checkoutID string) ([]*giftcard.GiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.GetAllByCheckout(checkoutID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.GetAllByCheckout", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) GetAllByUserId(userID string) ([]*giftcard.GiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.GetAllByUserId(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.GetAllByUserId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) GetById(id string) (*giftcard.GiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) Upsert(giftCard *giftcard.GiftCard) (*giftcard.GiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.Upsert(giftCard)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardCheckoutStore) Delete(giftcardID string, checkoutID string) error {
	start := timemodule.Now()

	err := s.GiftCardCheckoutStore.Delete(giftcardID, checkoutID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardCheckoutStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerGiftCardCheckoutStore) Get(id string) (*giftcard.GiftCardCheckout, error) {
	start := timemodule.Now()

	result, err := s.GiftCardCheckoutStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardCheckoutStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardCheckoutStore) Save(giftcardOrder *giftcard.GiftCardCheckout) (*giftcard.GiftCardCheckout, error) {
	start := timemodule.Now()

	result, err := s.GiftCardCheckoutStore.Save(giftcardOrder)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardCheckoutStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardOrderStore) Get(id string) (*giftcard.OrderGiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardOrderStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardOrderStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardOrderStore) Save(giftcardOrder *giftcard.OrderGiftCard) (*giftcard.OrderGiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardOrderStore.Save(giftcardOrder)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardOrderStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Delete(id string) (string, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Get(id string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByStatus(status string) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByStatus(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByType(jobType string) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByType(jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByTypePage(jobType, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypePage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypesPage(jobTypes []string, offset int, limit int) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByTypesPage(jobTypes, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypesPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllPage(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetCountByStatusAndType(status, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetCountByStatusAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetNewestJobByStatusAndType(status, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetNewestJobByStatusesAndType(statuses []string, jobType string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetNewestJobByStatusesAndType(statuses, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusesAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Save(job *model.Job) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Save(job)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateOptimistically(job, currentStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatus(id string, status string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateStatus(id, status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatusOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) GetById(id string) (*menu.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) GetByName(name string) (*menu.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) GetBySlug(slug string) (*menu.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.GetBySlug(slug)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.GetBySlug", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) Save(menu *menu.Menu) (*menu.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.Save(menu)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) GetById(id string) (*menu.MenuItem, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) GetByName(name string) (*menu.MenuItem, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) Save(menuItem *menu.MenuItem) (*menu.MenuItem, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.Save(menuItem)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) Get(id string) (*order.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) Save(order *order.Order) (*order.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.Save(order)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) Update(order *order.Order) (*order.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.Update(order)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) UpdateTotalPaid(orderId string, newTotalPaid *decimal.Decimal) error {
	start := timemodule.Now()

	err := s.OrderStore.UpdateTotalPaid(orderId, newTotalPaid)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.UpdateTotalPaid", success, elapsed)
	}
	return err
}

func (s *TimerLayerOrderLineStore) Get(id string) (*order.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) GetAllByOrderID(orderID string) ([]*order.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.GetAllByOrderID(orderID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.GetAllByOrderID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) OrderLinesByOrderWithPrefetch(orderID string) ([]*order.OrderLine, []*product_and_discount.ProductVariant, []*product_and_discount.Product, error) {
	start := timemodule.Now()

	result, resultVar1, resultVar2, err := s.OrderLineStore.OrderLinesByOrderWithPrefetch(orderID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.OrderLinesByOrderWithPrefetch", success, elapsed)
	}
	return result, resultVar1, resultVar2, err
}

func (s *TimerLayerOrderLineStore) Save(orderLine *order.OrderLine) (*order.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.Save(orderLine)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) Get(id string) (*payment.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) GetPaymentsByCheckoutID(checkoutID string) ([]*payment.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.GetPaymentsByCheckoutID(checkoutID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.GetPaymentsByCheckoutID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) GetPaymentsByOrderID(orderID string) ([]*payment.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.GetPaymentsByOrderID(orderID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.GetPaymentsByOrderID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) PaymentExistWithOptions(opts *payment.PaymentFilterOpts) (bool, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.PaymentExistWithOptions(opts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.PaymentExistWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) Save(payment *payment.Payment) (*payment.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.Save(payment)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) Update(payment *payment.Payment) (*payment.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.Update(payment)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Get(id string) (*payment.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) GetAllByPaymentID(paymentID string) ([]*payment.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.GetAllByPaymentID(paymentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.GetAllByPaymentID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Save(transaction *payment.PaymentTransaction) (*payment.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Save(transaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Update(transaction *payment.PaymentTransaction) (*payment.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Update(transaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndDelete(keyVal *plugins.PluginKeyValue, oldValue []byte) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.CompareAndDelete(keyVal, oldValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndDelete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndSet(keyVal *plugins.PluginKeyValue, oldValue []byte) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.CompareAndSet(keyVal, oldValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndSet", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) Delete(pluginID string, key string) error {
	start := timemodule.Now()

	err := s.PluginStore.Delete(pluginID, key)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllExpired() error {
	start := timemodule.Now()

	err := s.PluginStore.DeleteAllExpired()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllExpired", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllForPlugin(PluginID string) error {
	start := timemodule.Now()

	err := s.PluginStore.DeleteAllForPlugin(PluginID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllForPlugin", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) Get(pluginID string, key string) (*plugins.PluginKeyValue, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.Get(pluginID, key)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) List(pluginID string, page int, perPage int) ([]string, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.List(pluginID, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.List", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SaveOrUpdate(keyVal *plugins.PluginKeyValue) (*plugins.PluginKeyValue, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.SaveOrUpdate(keyVal)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SaveOrUpdate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SetWithOptions(pluginID string, key string, value []byte, options plugins.PluginKVSetOptions) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.SetWithOptions(pluginID, key, value, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.CleanupFlagsBatch(limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.CleanupFlagsBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) Delete(userID string, category string, name string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.Delete(userID, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategory(userID string, category string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.DeleteCategory(userID, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategory", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategoryAndName(category string, name string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.DeleteCategoryAndName(category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategoryAndName", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteUnusedFeatures() {
	start := timemodule.Now()

	s.PreferenceStore.DeleteUnusedFeatures()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteUnusedFeatures", success, elapsed)
	}
}

func (s *TimerLayerPreferenceStore) Get(userID string, category string, name string) (*model.Preference, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.Get(userID, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetAll(userID string) (model.Preferences, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.GetAll(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetCategory(userID string, category string) (model.Preferences, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.GetCategory(userID, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetCategory", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) PermanentDeleteByUser(userID string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) Save(preferences *model.Preferences) error {
	start := timemodule.Now()

	err := s.PreferenceStore.Save(preferences)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerProductStore) Get(id string) (*product_and_discount.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) GetProductsByIds(ids []string) ([]*product_and_discount.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.GetProductsByIds(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.GetProductsByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) Save(prd *product_and_discount.Product) (*product_and_discount.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.Save(prd)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductChannelListingStore) FilterByOption(option *product_and_discount.ProductChannelListingFilterOption) ([]*product_and_discount.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductChannelListingStore) Get(channelListingID string) (*product_and_discount.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.Get(channelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductChannelListingStore) Save(channelListing *product_and_discount.ProductChannelListing) (*product_and_discount.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.Save(channelListing)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) FilterProductTypesByCheckoutID(checkoutToken string) ([]*product_and_discount.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.FilterProductTypesByCheckoutID(checkoutToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.FilterProductTypesByCheckoutID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) Get(productTypeID string) (*product_and_discount.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.Get(productTypeID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) ProductTypesByProductIDs(productIDs []string) ([]*product_and_discount.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.ProductTypesByProductIDs(productIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.ProductTypesByProductIDs", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) Save(productType *product_and_discount.ProductType) (*product_and_discount.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.Save(productType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) Get(id string) (*product_and_discount.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) Save(variant *product_and_discount.ProductVariant) (*product_and_discount.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.Save(variant)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Delete(roleID string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Delete(roleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Get(roleID string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Get(roleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetAll() ([]*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByName(ctx context.Context, name string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetByName(ctx, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByNames(names []string) ([]*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetByNames(names)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByNames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) PermanentDeleteAll() error {
	start := timemodule.Now()

	err := s.RoleStore.PermanentDeleteAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.PermanentDeleteAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerRoleStore) Save(role *model.Role) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Save(role)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) AnalyticsSessionCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.AnalyticsSessionCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.AnalyticsSessionCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {
	start := timemodule.Now()

	s.SessionStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerSessionStore) Get(ctx context.Context, sessionIDOrToken string) (*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.Get(ctx, sessionIDOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessions(userID string) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessions(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsExpired", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsWithActiveDeviceIds(userID string) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessionsWithActiveDeviceIds(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsWithActiveDeviceIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) PermanentDeleteSessionsByUser(teamID string) error {
	start := timemodule.Now()

	err := s.SessionStore.PermanentDeleteSessionsByUser(teamID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.PermanentDeleteSessionsByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Remove(sessionIDOrToken string) error {
	start := timemodule.Now()

	err := s.SessionStore.Remove(sessionIDOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Remove", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) RemoveAllSessions() error {
	start := timemodule.Now()

	err := s.SessionStore.RemoveAllSessions()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.RemoveAllSessions", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Save(session *model.Session) (*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.Save(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateDeviceId(id string, deviceID string, expiresAt int64) (string, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.UpdateDeviceId(id, deviceID, expiresAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateDeviceId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateExpiredNotify(sessionid, notified)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiredNotify", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateExpiresAt(sessionID string, time int64) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateExpiresAt(sessionID, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiresAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateLastActivityAt(sessionID string, time int64) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateLastActivityAt(sessionID, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateProps(session *model.Session) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateProps(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateProps", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateRoles(userID string, roles string) (string, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.UpdateRoles(userID, roles)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateRoles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) ApplicableShippingMethods(price *goprices.Money, channelID string, weight *measurement.Weight, countryCode string, productIDs []string) ([]*shipping.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.ApplicableShippingMethods(price, channelID, weight, countryCode, productIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.ApplicableShippingMethods", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) Get(methodID string) (*shipping.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.Get(methodID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) Upsert(method *shipping.ShippingMethod) (*shipping.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.Upsert(method)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStore) Get(shopID string) (*shop.Shop, error) {
	start := timemodule.Now()

	result, err := s.ShopStore.Get(shopID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStore) Upsert(shop *shop.Shop) (*shop.Shop, error) {
	start := timemodule.Now()

	result, err := s.ShopStore.Upsert(shop)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) FilterByShopAndStaff(shopID string, staffID string) (*shop.ShopStaffRelation, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.FilterByShopAndStaff(shopID, staffID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.FilterByShopAndStaff", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) Get(shopStaffID string) (*shop.ShopStaffRelation, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.Get(shopStaffID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) Save(shopStaff *shop.ShopStaffRelation) (*shop.ShopStaffRelation, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.Save(shopStaff)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopTranslationStore) Get(id string) (*shop.ShopTranslation, error) {
	start := timemodule.Now()

	result, err := s.ShopTranslationStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopTranslationStore) Upsert(translation *shop.ShopTranslation) (*shop.ShopTranslation, error) {
	start := timemodule.Now()

	result, err := s.ShopTranslationStore.Upsert(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopTranslationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStaffNotificationRecipientStore) Get(id string) (*account.StaffNotificationRecipient, error) {
	start := timemodule.Now()

	result, err := s.StaffNotificationRecipientStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StaffNotificationRecipientStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStaffNotificationRecipientStore) Save(notificationRecipient *account.StaffNotificationRecipient) (*account.StaffNotificationRecipient, error) {
	start := timemodule.Now()

	result, err := s.StaffNotificationRecipientStore.Save(notificationRecipient)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StaffNotificationRecipientStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) Get(userID string) (*account.Status, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.Get(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetByIds(userIds []string) ([]*account.Status, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.GetByIds(userIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetTotalActiveUsersCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.GetTotalActiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetTotalActiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) ResetAll() error {
	start := timemodule.Now()

	err := s.StatusStore.ResetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.ResetAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) SaveOrUpdate(status *account.Status) error {
	start := timemodule.Now()

	err := s.StatusStore.SaveOrUpdate(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) UpdateLastActivityAt(userID string, lastActivityAt int64) error {
	start := timemodule.Now()

	err := s.StatusStore.UpdateLastActivityAt(userID, lastActivityAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerStockStore) FilterForCountryAndChannel(options *warehouse.ForCountryAndChannelFilter) ([]*warehouse.Stock, []*warehouse.WareHouse, []*product_and_discount.ProductVariant, error) {
	start := timemodule.Now()

	result, resultVar1, resultVar2, err := s.StockStore.FilterForCountryAndChannel(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterForCountryAndChannel", success, elapsed)
	}
	return result, resultVar1, resultVar2, err
}

func (s *TimerLayerStockStore) FilterProductStocksForCountryAndChannel(options *warehouse.ForCountryAndChannelFilter, productID string) ([]*warehouse.Stock, []*warehouse.WareHouse, []*product_and_discount.ProductVariant, error) {
	start := timemodule.Now()

	result, resultVar1, resultVar2, err := s.StockStore.FilterProductStocksForCountryAndChannel(options, productID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterProductStocksForCountryAndChannel", success, elapsed)
	}
	return result, resultVar1, resultVar2, err
}

func (s *TimerLayerStockStore) FilterVariantStocksForCountry(options *warehouse.ForCountryAndChannelFilter, productVariantID string) ([]*warehouse.Stock, []*warehouse.WareHouse, []*product_and_discount.ProductVariant, error) {
	start := timemodule.Now()

	result, resultVar1, resultVar2, err := s.StockStore.FilterVariantStocksForCountry(options, productVariantID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterVariantStocksForCountry", success, elapsed)
	}
	return result, resultVar1, resultVar2, err
}

func (s *TimerLayerStockStore) Get(stockID string) (*warehouse.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.Get(stockID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) Save(stock *warehouse.Stock) (*warehouse.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.Save(stock)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) Get() (model.StringMap, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.Get()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) GetByName(name string) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) InsertIfExists(system *model.System) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.InsertIfExists(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.InsertIfExists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) PermanentDeleteByName(name string) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.PermanentDeleteByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.PermanentDeleteByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) Save(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.Save(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdate(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.SaveOrUpdate(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdateWithWarnMetricHandling(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.SaveOrUpdateWithWarnMetricHandling(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdateWithWarnMetricHandling", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) Update(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.Update(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.Get(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.GetLatest(allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.GetLatest", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.Save(termsOfService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) Cleanup() {
	start := timemodule.Now()

	s.TokenStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerTokenStore) Delete(token string) error {
	start := timemodule.Now()

	err := s.TokenStore.Delete(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) GetAllTokensByType(tokenType string) ([]*model.Token, error) {
	start := timemodule.Now()

	result, err := s.TokenStore.GetAllTokensByType(tokenType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetAllTokensByType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) GetByToken(token string) (*model.Token, error) {
	start := timemodule.Now()

	result, err := s.TokenStore.GetByToken(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) RemoveAllTokensByType(tokenType string) error {
	start := timemodule.Now()

	err := s.TokenStore.RemoveAllTokensByType(tokenType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.RemoveAllTokensByType", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) Save(recovery *model.Token) error {
	start := timemodule.Now()

	err := s.TokenStore.Save(recovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) Delete(id string) error {
	start := timemodule.Now()

	err := s.UploadSessionStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) Get(id string) (*file.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) GetForUser(userID string) ([]*file.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.GetForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.GetForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Save(session *file.UploadSession) (*file.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.Save(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Update(session *file.UploadSession) error {
	start := timemodule.Now()

	err := s.UploadSessionStore.Update(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) AnalyticsActiveCount(time int64, options account.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsActiveCount(time, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsActiveCountForPeriod(startTime int64, endTime int64, options account.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsActiveCountForPeriod(startTime, endTime, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCountForPeriod", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetExternalUsers(hostDomain string) (bool, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetExternalUsers(hostDomain)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetExternalUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetGuestCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetGuestCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetGuestCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetInactiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetInactiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetSystemAdminCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetSystemAdminCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetSystemAdminCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ClearAllCustomRoleAssignments() error {
	start := timemodule.Now()

	err := s.UserStore.ClearAllCustomRoleAssignments()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ClearCaches() {
	start := timemodule.Now()

	s.UserStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerUserStore) Count(options account.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Count(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) DeactivateGuests() ([]string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.DeactivateGuests()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.DeactivateGuests", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) DemoteUserToGuest(userID string) (*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.DemoteUserToGuest(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.DemoteUserToGuest", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Get(ctx context.Context, id string) (*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Get(ctx, id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAll() ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllAfter(limit int, afterID string) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllAfter(limit, afterID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllNotInAuthService(authServices []string) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllNotInAuthService(authServices)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllNotInAuthService", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllProfiles(options *account.UserGetOptions) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllUsingAuthService(authService string) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllUsingAuthService(authService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllUsingAuthService", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByAuth(authData *string, authService string) (*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByAuth(authData, authService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByAuth", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByEmail(email string) (*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByEmail(email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByUsername(username string) (*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByUsername(username)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByUsername", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetEtagForAllProfiles() string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForAllProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForAllProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetEtagForProfiles(teamID string) string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForProfiles(teamID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetForLogin(loginID string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetForLogin(loginID, allowSignInWithUsername, allowSignInWithEmail)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetForLogin", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetKnownUsers(userID string) ([]string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetKnownUsers(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetKnownUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetMany(ctx context.Context, ids []string) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetMany(ctx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetMany", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfileByIds(ctx context.Context, userIds []string, options *store.UserGetByIdsOpts, allowFromCache bool) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfileByIds(ctx, userIds, options, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfileByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfiles(options *account.UserGetOptions) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesByUsernames(usernames []string) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfilesByUsernames(usernames)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesByUsernames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetSystemAdminProfiles() (map[string]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetSystemAdminProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetSystemAdminProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUnreadCount(userID string) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetUnreadCount(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUnreadCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*account.UserForIndexing, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUsersBatchForIndexing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InferSystemInstallDate() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.InferSystemInstallDate()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InferSystemInstallDate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InvalidateProfileCacheForUser(userID string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfileCacheForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfileCacheForUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) PermanentDelete(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.PermanentDelete(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) PromoteGuestToUser(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.PromoteGuestToUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PromoteGuestToUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ResetAuthDataToEmailForUsers(service string, userIDs []string, includeDeleted bool, dryRun bool) (int, error) {
	start := timemodule.Now()

	result, err := s.UserStore.ResetAuthDataToEmailForUsers(service, userIDs, includeDeleted, dryRun)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetAuthDataToEmailForUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ResetLastPictureUpdate(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.ResetLastPictureUpdate(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) Save(user *account.User) (*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Save(user)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Search(term string, options *account.UserSearchOptions) ([]*account.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Search(term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Update(user *account.User, allowRoleUpdate bool) (*account.UserUpdate, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Update(user, allowRoleUpdate)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateAuthData(userID string, service string, authData *string, email string, resetMfa bool) (string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.UpdateAuthData(userID, service, authData, email, resetMfa)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateFailedPasswordAttempts(userID string, attempts int) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateFailedPasswordAttempts(userID, attempts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateFailedPasswordAttempts", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateLastPictureUpdate(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateLastPictureUpdate(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaActive(userID string, active bool) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateMfaActive(userID, active)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaActive", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaSecret(userID string, secret string) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateMfaSecret(userID, secret)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaSecret", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdatePassword(userID string, newPassword string) error {
	start := timemodule.Now()

	err := s.UserStore.UpdatePassword(userID, newPassword)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdatePassword", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateUpdateAt(userID string) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.UpdateUpdateAt(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateUpdateAt", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) VerifyEmail(userID string, email string) (string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.VerifyEmail(userID, email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.VerifyEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Delete(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.Delete(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) DeleteAllForUser(userID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.DeleteAllForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.DeleteAllForUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) Get(tokenID string) (*account.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Get(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*account.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByToken(tokenString string) (*account.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetByToken(tokenString)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByUser(userID string, page int, perPage int) ([]*account.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetByUser(userID, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Save(token *account.UserAccessToken) (*account.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Save(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Search(term string) ([]*account.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Search(term)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenDisable(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.UpdateTokenDisable(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenDisable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenEnable(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.UpdateTokenEnable(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenEnable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAddressStore) DeleteForUser(userID string, addressID string) error {
	start := timemodule.Now()

	err := s.UserAddressStore.DeleteForUser(userID, addressID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAddressStore.DeleteForUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAddressStore) Save(userAddress *account.UserAddress) (*account.UserAddress, error) {
	start := timemodule.Now()

	result, err := s.UserAddressStore.Save(userAddress)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAddressStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserTermOfServiceStore) Delete(userID string, termsOfServiceId string) error {
	start := timemodule.Now()

	err := s.UserTermOfServiceStore.Delete(userID, termsOfServiceId)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermOfServiceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserTermOfServiceStore) GetByUser(userID string) (*account.UserTermsOfService, error) {
	start := timemodule.Now()

	result, err := s.UserTermOfServiceStore.GetByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermOfServiceStore.GetByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserTermOfServiceStore) Save(userTermsOfService *account.UserTermsOfService) (*account.UserTermsOfService, error) {
	start := timemodule.Now()

	result, err := s.UserTermOfServiceStore.Save(userTermsOfService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserTermOfServiceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCategoryStore) Get(voucherCategoryID string) (*product_and_discount.VoucherCategory, error) {
	start := timemodule.Now()

	result, err := s.VoucherCategoryStore.Get(voucherCategoryID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCategoryStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCategoryStore) ProductCategoriesByVoucherID(voucherID string) ([]*product_and_discount.Category, error) {
	start := timemodule.Now()

	result, err := s.VoucherCategoryStore.ProductCategoriesByVoucherID(voucherID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCategoryStore.ProductCategoriesByVoucherID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCategoryStore) Upsert(voucherCategory *product_and_discount.VoucherCategory) (*product_and_discount.VoucherCategory, error) {
	start := timemodule.Now()

	result, err := s.VoucherCategoryStore.Upsert(voucherCategory)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCategoryStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) FilterByVoucherAndChannel(voucherID string, channelID string) ([]*product_and_discount.VoucherChannelListing, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.FilterByVoucherAndChannel(voucherID, channelID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.FilterByVoucherAndChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) Get(voucherChannelListingID string) (*product_and_discount.VoucherChannelListing, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.Get(voucherChannelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) Upsert(voucherChannelListing *product_and_discount.VoucherChannelListing) (*product_and_discount.VoucherChannelListing, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.Upsert(voucherChannelListing)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCollectionStore) CollectionsByVoucherID(voucherID string) ([]*product_and_discount.Collection, error) {
	start := timemodule.Now()

	result, err := s.VoucherCollectionStore.CollectionsByVoucherID(voucherID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCollectionStore.CollectionsByVoucherID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCollectionStore) Get(voucherCollectionID string) (*product_and_discount.VoucherCollection, error) {
	start := timemodule.Now()

	result, err := s.VoucherCollectionStore.Get(voucherCollectionID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCollectionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCollectionStore) Upsert(voucherCollection *product_and_discount.VoucherCollection) (*product_and_discount.VoucherCollection, error) {
	start := timemodule.Now()

	result, err := s.VoucherCollectionStore.Upsert(voucherCollection)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCollectionStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) FilterByVoucherAndEmail(voucherID string, email string) (*product_and_discount.VoucherCustomer, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.FilterByVoucherAndEmail(voucherID, email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.FilterByVoucherAndEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) Get(id string) (*product_and_discount.VoucherCustomer, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) Save(voucherCustomer *product_and_discount.VoucherCustomer) (*product_and_discount.VoucherCustomer, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.Save(voucherCustomer)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherProductStore) Get(voucherProductID string) (*product_and_discount.VoucherProduct, error) {
	start := timemodule.Now()

	result, err := s.VoucherProductStore.Get(voucherProductID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherProductStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherProductStore) ProductsByVoucherID(voucherID string) ([]*product_and_discount.Product, error) {
	start := timemodule.Now()

	result, err := s.VoucherProductStore.ProductsByVoucherID(voucherID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherProductStore.ProductsByVoucherID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherProductStore) Upsert(voucherProduct *product_and_discount.VoucherProduct) (*product_and_discount.VoucherProduct, error) {
	start := timemodule.Now()

	result, err := s.VoucherProductStore.Upsert(voucherProduct)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherProductStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) Get(id string) (*warehouse.WareHouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) GetWarehousesHeaders(ids []string) ([]string, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.GetWarehousesHeaders(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.GetWarehousesHeaders", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) Save(warehouse *warehouse.WareHouse) (*warehouse.WareHouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.Save(warehouse)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistStore) GetById(id string) (*wishlist.Wishlist, error) {
	start := timemodule.Now()

	result, err := s.WishlistStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistStore) GetByUserID(userID string) (*wishlist.Wishlist, error) {
	start := timemodule.Now()

	result, err := s.WishlistStore.GetByUserID(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistStore.GetByUserID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistStore) Save(wishlist *wishlist.Wishlist) (*wishlist.Wishlist, error) {
	start := timemodule.Now()

	result, err := s.WishlistStore.Save(wishlist)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) GetById(id string) (*wishlist.WishlistItem, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) Save(wishlistItem *wishlist.WishlistItem) (*wishlist.WishlistItem, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.Save(wishlistItem)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) WishlistItemsByWishlistId(wishlistID string) ([]*wishlist.WishlistItem, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.WishlistItemsByWishlistId(wishlistID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.WishlistItemsByWishlistId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistProductVariantStore) GetById(id string) (*wishlist.WishlistProductVariant, error) {
	start := timemodule.Now()

	result, err := s.WishlistProductVariantStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistProductVariantStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistProductVariantStore) Save(wishlistVariant *wishlist.WishlistProductVariant) (*wishlist.WishlistProductVariant, error) {
	start := timemodule.Now()

	result, err := s.WishlistProductVariantStore.Save(wishlistVariant)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistProductVariantStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayer) Close() {
	s.Store.Close()
}

func (s *TimerLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *TimerLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *TimerLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *TimerLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *TimerLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func New(childStore store.Store, metrics einterfaces.MetricsInterface) *TimerLayer {
	newStore := TimerLayer{
		Store:   childStore,
		Metrics: metrics,
	}

	newStore.AddressStore = &TimerLayerAddressStore{AddressStore: childStore.Address(), Root: &newStore}
	newStore.AllocationStore = &TimerLayerAllocationStore{AllocationStore: childStore.Allocation(), Root: &newStore}
	newStore.AppStore = &TimerLayerAppStore{AppStore: childStore.App(), Root: &newStore}
	newStore.AppTokenStore = &TimerLayerAppTokenStore{AppTokenStore: childStore.AppToken(), Root: &newStore}
	newStore.AssignedPageAttributeStore = &TimerLayerAssignedPageAttributeStore{AssignedPageAttributeStore: childStore.AssignedPageAttribute(), Root: &newStore}
	newStore.AssignedPageAttributeValueStore = &TimerLayerAssignedPageAttributeValueStore{AssignedPageAttributeValueStore: childStore.AssignedPageAttributeValue(), Root: &newStore}
	newStore.AssignedProductAttributeStore = &TimerLayerAssignedProductAttributeStore{AssignedProductAttributeStore: childStore.AssignedProductAttribute(), Root: &newStore}
	newStore.AssignedProductAttributeValueStore = &TimerLayerAssignedProductAttributeValueStore{AssignedProductAttributeValueStore: childStore.AssignedProductAttributeValue(), Root: &newStore}
	newStore.AssignedVariantAttributeStore = &TimerLayerAssignedVariantAttributeStore{AssignedVariantAttributeStore: childStore.AssignedVariantAttribute(), Root: &newStore}
	newStore.AssignedVariantAttributeValueStore = &TimerLayerAssignedVariantAttributeValueStore{AssignedVariantAttributeValueStore: childStore.AssignedVariantAttributeValue(), Root: &newStore}
	newStore.AttributeStore = &TimerLayerAttributeStore{AttributeStore: childStore.Attribute(), Root: &newStore}
	newStore.AttributePageStore = &TimerLayerAttributePageStore{AttributePageStore: childStore.AttributePage(), Root: &newStore}
	newStore.AttributeProductStore = &TimerLayerAttributeProductStore{AttributeProductStore: childStore.AttributeProduct(), Root: &newStore}
	newStore.AttributeTranslationStore = &TimerLayerAttributeTranslationStore{AttributeTranslationStore: childStore.AttributeTranslation(), Root: &newStore}
	newStore.AttributeValueStore = &TimerLayerAttributeValueStore{AttributeValueStore: childStore.AttributeValue(), Root: &newStore}
	newStore.AttributeValueTranslationStore = &TimerLayerAttributeValueTranslationStore{AttributeValueTranslationStore: childStore.AttributeValueTranslation(), Root: &newStore}
	newStore.AttributeVariantStore = &TimerLayerAttributeVariantStore{AttributeVariantStore: childStore.AttributeVariant(), Root: &newStore}
	newStore.AuditStore = &TimerLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.CategoryStore = &TimerLayerCategoryStore{CategoryStore: childStore.Category(), Root: &newStore}
	newStore.CategoryTranslationStore = &TimerLayerCategoryTranslationStore{CategoryTranslationStore: childStore.CategoryTranslation(), Root: &newStore}
	newStore.ChannelStore = &TimerLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.CheckoutStore = &TimerLayerCheckoutStore{CheckoutStore: childStore.Checkout(), Root: &newStore}
	newStore.CheckoutLineStore = &TimerLayerCheckoutLineStore{CheckoutLineStore: childStore.CheckoutLine(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &TimerLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CollectionStore = &TimerLayerCollectionStore{CollectionStore: childStore.Collection(), Root: &newStore}
	newStore.CollectionChannelListingStore = &TimerLayerCollectionChannelListingStore{CollectionChannelListingStore: childStore.CollectionChannelListing(), Root: &newStore}
	newStore.CollectionProductStore = &TimerLayerCollectionProductStore{CollectionProductStore: childStore.CollectionProduct(), Root: &newStore}
	newStore.CollectionTranslationStore = &TimerLayerCollectionTranslationStore{CollectionTranslationStore: childStore.CollectionTranslation(), Root: &newStore}
	newStore.ComplianceStore = &TimerLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.CsvExportEventStore = &TimerLayerCsvExportEventStore{CsvExportEventStore: childStore.CsvExportEvent(), Root: &newStore}
	newStore.CsvExportFileStore = &TimerLayerCsvExportFileStore{CsvExportFileStore: childStore.CsvExportFile(), Root: &newStore}
	newStore.CustomerEventStore = &TimerLayerCustomerEventStore{CustomerEventStore: childStore.CustomerEvent(), Root: &newStore}
	newStore.CustomerNoteStore = &TimerLayerCustomerNoteStore{CustomerNoteStore: childStore.CustomerNote(), Root: &newStore}
	newStore.DigitalContentStore = &TimerLayerDigitalContentStore{DigitalContentStore: childStore.DigitalContent(), Root: &newStore}
	newStore.DigitalContentUrlStore = &TimerLayerDigitalContentUrlStore{DigitalContentUrlStore: childStore.DigitalContentUrl(), Root: &newStore}
	newStore.DiscountSaleStore = &TimerLayerDiscountSaleStore{DiscountSaleStore: childStore.DiscountSale(), Root: &newStore}
	newStore.DiscountSaleChannelListingStore = &TimerLayerDiscountSaleChannelListingStore{DiscountSaleChannelListingStore: childStore.DiscountSaleChannelListing(), Root: &newStore}
	newStore.DiscountSaleTranslationStore = &TimerLayerDiscountSaleTranslationStore{DiscountSaleTranslationStore: childStore.DiscountSaleTranslation(), Root: &newStore}
	newStore.DiscountVoucherStore = &TimerLayerDiscountVoucherStore{DiscountVoucherStore: childStore.DiscountVoucher(), Root: &newStore}
	newStore.FileInfoStore = &TimerLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.FulfillmentStore = &TimerLayerFulfillmentStore{FulfillmentStore: childStore.Fulfillment(), Root: &newStore}
	newStore.FulfillmentLineStore = &TimerLayerFulfillmentLineStore{FulfillmentLineStore: childStore.FulfillmentLine(), Root: &newStore}
	newStore.GiftCardStore = &TimerLayerGiftCardStore{GiftCardStore: childStore.GiftCard(), Root: &newStore}
	newStore.GiftCardCheckoutStore = &TimerLayerGiftCardCheckoutStore{GiftCardCheckoutStore: childStore.GiftCardCheckout(), Root: &newStore}
	newStore.GiftCardOrderStore = &TimerLayerGiftCardOrderStore{GiftCardOrderStore: childStore.GiftCardOrder(), Root: &newStore}
	newStore.InvoiceEventStore = &TimerLayerInvoiceEventStore{InvoiceEventStore: childStore.InvoiceEvent(), Root: &newStore}
	newStore.JobStore = &TimerLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.MenuStore = &TimerLayerMenuStore{MenuStore: childStore.Menu(), Root: &newStore}
	newStore.MenuItemStore = &TimerLayerMenuItemStore{MenuItemStore: childStore.MenuItem(), Root: &newStore}
	newStore.MenuItemTranslationStore = &TimerLayerMenuItemTranslationStore{MenuItemTranslationStore: childStore.MenuItemTranslation(), Root: &newStore}
	newStore.OrderStore = &TimerLayerOrderStore{OrderStore: childStore.Order(), Root: &newStore}
	newStore.OrderDiscountStore = &TimerLayerOrderDiscountStore{OrderDiscountStore: childStore.OrderDiscount(), Root: &newStore}
	newStore.OrderEventStore = &TimerLayerOrderEventStore{OrderEventStore: childStore.OrderEvent(), Root: &newStore}
	newStore.OrderLineStore = &TimerLayerOrderLineStore{OrderLineStore: childStore.OrderLine(), Root: &newStore}
	newStore.PageStore = &TimerLayerPageStore{PageStore: childStore.Page(), Root: &newStore}
	newStore.PageTranslationStore = &TimerLayerPageTranslationStore{PageTranslationStore: childStore.PageTranslation(), Root: &newStore}
	newStore.PageTypeStore = &TimerLayerPageTypeStore{PageTypeStore: childStore.PageType(), Root: &newStore}
	newStore.PaymentStore = &TimerLayerPaymentStore{PaymentStore: childStore.Payment(), Root: &newStore}
	newStore.PaymentTransactionStore = &TimerLayerPaymentTransactionStore{PaymentTransactionStore: childStore.PaymentTransaction(), Root: &newStore}
	newStore.PluginStore = &TimerLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PluginConfigurationStore = &TimerLayerPluginConfigurationStore{PluginConfigurationStore: childStore.PluginConfiguration(), Root: &newStore}
	newStore.PreferenceStore = &TimerLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.ProductStore = &TimerLayerProductStore{ProductStore: childStore.Product(), Root: &newStore}
	newStore.ProductChannelListingStore = &TimerLayerProductChannelListingStore{ProductChannelListingStore: childStore.ProductChannelListing(), Root: &newStore}
	newStore.ProductMediaStore = &TimerLayerProductMediaStore{ProductMediaStore: childStore.ProductMedia(), Root: &newStore}
	newStore.ProductTranslationStore = &TimerLayerProductTranslationStore{ProductTranslationStore: childStore.ProductTranslation(), Root: &newStore}
	newStore.ProductTypeStore = &TimerLayerProductTypeStore{ProductTypeStore: childStore.ProductType(), Root: &newStore}
	newStore.ProductVariantStore = &TimerLayerProductVariantStore{ProductVariantStore: childStore.ProductVariant(), Root: &newStore}
	newStore.ProductVariantChannelListingStore = &TimerLayerProductVariantChannelListingStore{ProductVariantChannelListingStore: childStore.ProductVariantChannelListing(), Root: &newStore}
	newStore.ProductVariantTranslationStore = &TimerLayerProductVariantTranslationStore{ProductVariantTranslationStore: childStore.ProductVariantTranslation(), Root: &newStore}
	newStore.RoleStore = &TimerLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SessionStore = &TimerLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.ShippingMethodStore = &TimerLayerShippingMethodStore{ShippingMethodStore: childStore.ShippingMethod(), Root: &newStore}
	newStore.ShippingMethodChannelListingStore = &TimerLayerShippingMethodChannelListingStore{ShippingMethodChannelListingStore: childStore.ShippingMethodChannelListing(), Root: &newStore}
	newStore.ShippingMethodExcludedProductStore = &TimerLayerShippingMethodExcludedProductStore{ShippingMethodExcludedProductStore: childStore.ShippingMethodExcludedProduct(), Root: &newStore}
	newStore.ShippingMethodPostalCodeRuleStore = &TimerLayerShippingMethodPostalCodeRuleStore{ShippingMethodPostalCodeRuleStore: childStore.ShippingMethodPostalCodeRule(), Root: &newStore}
	newStore.ShippingMethodTranslationStore = &TimerLayerShippingMethodTranslationStore{ShippingMethodTranslationStore: childStore.ShippingMethodTranslation(), Root: &newStore}
	newStore.ShippingZoneStore = &TimerLayerShippingZoneStore{ShippingZoneStore: childStore.ShippingZone(), Root: &newStore}
	newStore.ShippingZoneChannelStore = &TimerLayerShippingZoneChannelStore{ShippingZoneChannelStore: childStore.ShippingZoneChannel(), Root: &newStore}
	newStore.ShopStore = &TimerLayerShopStore{ShopStore: childStore.Shop(), Root: &newStore}
	newStore.ShopStaffStore = &TimerLayerShopStaffStore{ShopStaffStore: childStore.ShopStaff(), Root: &newStore}
	newStore.ShopTranslationStore = &TimerLayerShopTranslationStore{ShopTranslationStore: childStore.ShopTranslation(), Root: &newStore}
	newStore.StaffNotificationRecipientStore = &TimerLayerStaffNotificationRecipientStore{StaffNotificationRecipientStore: childStore.StaffNotificationRecipient(), Root: &newStore}
	newStore.StatusStore = &TimerLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.StockStore = &TimerLayerStockStore{StockStore: childStore.Stock(), Root: &newStore}
	newStore.SystemStore = &TimerLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TermsOfServiceStore = &TimerLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &TimerLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UploadSessionStore = &TimerLayerUploadSessionStore{UploadSessionStore: childStore.UploadSession(), Root: &newStore}
	newStore.UserStore = &TimerLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &TimerLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserAddressStore = &TimerLayerUserAddressStore{UserAddressStore: childStore.UserAddress(), Root: &newStore}
	newStore.UserTermOfServiceStore = &TimerLayerUserTermOfServiceStore{UserTermOfServiceStore: childStore.UserTermOfService(), Root: &newStore}
	newStore.VariantMediaStore = &TimerLayerVariantMediaStore{VariantMediaStore: childStore.VariantMedia(), Root: &newStore}
	newStore.VoucherCategoryStore = &TimerLayerVoucherCategoryStore{VoucherCategoryStore: childStore.VoucherCategory(), Root: &newStore}
	newStore.VoucherChannelListingStore = &TimerLayerVoucherChannelListingStore{VoucherChannelListingStore: childStore.VoucherChannelListing(), Root: &newStore}
	newStore.VoucherCollectionStore = &TimerLayerVoucherCollectionStore{VoucherCollectionStore: childStore.VoucherCollection(), Root: &newStore}
	newStore.VoucherCustomerStore = &TimerLayerVoucherCustomerStore{VoucherCustomerStore: childStore.VoucherCustomer(), Root: &newStore}
	newStore.VoucherProductStore = &TimerLayerVoucherProductStore{VoucherProductStore: childStore.VoucherProduct(), Root: &newStore}
	newStore.VoucherTranslationStore = &TimerLayerVoucherTranslationStore{VoucherTranslationStore: childStore.VoucherTranslation(), Root: &newStore}
	newStore.WarehouseStore = &TimerLayerWarehouseStore{WarehouseStore: childStore.Warehouse(), Root: &newStore}
	newStore.WarehouseShippingZoneStore = &TimerLayerWarehouseShippingZoneStore{WarehouseShippingZoneStore: childStore.WarehouseShippingZone(), Root: &newStore}
	newStore.WishlistStore = &TimerLayerWishlistStore{WishlistStore: childStore.Wishlist(), Root: &newStore}
	newStore.WishlistItemStore = &TimerLayerWishlistItemStore{WishlistItemStore: childStore.WishlistItem(), Root: &newStore}
	newStore.WishlistProductVariantStore = &TimerLayerWishlistProductVariantStore{WishlistProductVariantStore: childStore.WishlistProductVariant(), Root: &newStore}
	return &newStore
}
