// Code generated by "make store-layers"
// DO NOT EDIT

package timerlayer

import (
	"context"
	timemodule "time"

	"github.com/Masterminds/squirrel"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/einterfaces"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/model_helper"
	"github.com/sitename/sitename/modules/measurement"
	"github.com/sitename/sitename/store"
	"github.com/volatiletech/sqlboiler/v4/boil"
)

type TimerLayer struct {
	store.Store
	Metrics                            einterfaces.MetricsInterface
	AddressStore                       store.AddressStore
	AllocationStore                    store.AllocationStore
	AppStore                           store.AppStore
	AppTokenStore                      store.AppTokenStore
	AssignedPageAttributeStore         store.AssignedPageAttributeStore
	AssignedPageAttributeValueStore    store.AssignedPageAttributeValueStore
	AssignedProductAttributeStore      store.AssignedProductAttributeStore
	AssignedProductAttributeValueStore store.AssignedProductAttributeValueStore
	AttributeStore                     store.AttributeStore
	AttributePageStore                 store.AttributePageStore
	AttributeTranslationStore          store.AttributeTranslationStore
	AttributeValueStore                store.AttributeValueStore
	AttributeValueTranslationStore     store.AttributeValueTranslationStore
	AuditStore                         store.AuditStore
	CategoryStore                      store.CategoryStore
	CategoryTranslationStore           store.CategoryTranslationStore
	ChannelStore                       store.ChannelStore
	CheckoutStore                      store.CheckoutStore
	CheckoutLineStore                  store.CheckoutLineStore
	ClusterDiscoveryStore              store.ClusterDiscoveryStore
	CollectionStore                    store.CollectionStore
	CollectionChannelListingStore      store.CollectionChannelListingStore
	CollectionProductStore             store.CollectionProductStore
	CollectionTranslationStore         store.CollectionTranslationStore
	ComplianceStore                    store.ComplianceStore
	CsvExportEventStore                store.CsvExportEventStore
	CsvExportFileStore                 store.CsvExportFileStore
	CustomProductAttributeStore        store.CustomProductAttributeStore
	CustomerEventStore                 store.CustomerEventStore
	CustomerNoteStore                  store.CustomerNoteStore
	DigitalContentStore                store.DigitalContentStore
	DigitalContentUrlStore             store.DigitalContentUrlStore
	DiscountSaleStore                  store.DiscountSaleStore
	DiscountSaleChannelListingStore    store.DiscountSaleChannelListingStore
	DiscountSaleTranslationStore       store.DiscountSaleTranslationStore
	DiscountVoucherStore               store.DiscountVoucherStore
	FileInfoStore                      store.FileInfoStore
	FulfillmentStore                   store.FulfillmentStore
	FulfillmentLineStore               store.FulfillmentLineStore
	GiftCardStore                      store.GiftCardStore
	GiftcardEventStore                 store.GiftcardEventStore
	InvoiceStore                       store.InvoiceStore
	InvoiceEventStore                  store.InvoiceEventStore
	JobStore                           store.JobStore
	MenuStore                          store.MenuStore
	MenuItemStore                      store.MenuItemStore
	MenuItemTranslationStore           store.MenuItemTranslationStore
	OpenExchangeRateStore              store.OpenExchangeRateStore
	OrderStore                         store.OrderStore
	OrderDiscountStore                 store.OrderDiscountStore
	OrderEventStore                    store.OrderEventStore
	OrderLineStore                     store.OrderLineStore
	PageStore                          store.PageStore
	PageTranslationStore               store.PageTranslationStore
	PageTypeStore                      store.PageTypeStore
	PaymentStore                       store.PaymentStore
	PaymentTransactionStore            store.PaymentTransactionStore
	PluginStore                        store.PluginStore
	PluginConfigurationStore           store.PluginConfigurationStore
	PreferenceStore                    store.PreferenceStore
	PreorderAllocationStore            store.PreorderAllocationStore
	ProductStore                       store.ProductStore
	ProductChannelListingStore         store.ProductChannelListingStore
	ProductMediaStore                  store.ProductMediaStore
	ProductTranslationStore            store.ProductTranslationStore
	ProductTypeStore                   store.ProductTypeStore
	ProductVariantStore                store.ProductVariantStore
	ProductVariantChannelListingStore  store.ProductVariantChannelListingStore
	ProductVariantTranslationStore     store.ProductVariantTranslationStore
	RoleStore                          store.RoleStore
	SessionStore                       store.SessionStore
	ShippingMethodStore                store.ShippingMethodStore
	ShippingMethodChannelListingStore  store.ShippingMethodChannelListingStore
	ShippingMethodPostalCodeRuleStore  store.ShippingMethodPostalCodeRuleStore
	ShippingMethodTranslationStore     store.ShippingMethodTranslationStore
	ShippingZoneStore                  store.ShippingZoneStore
	ShopStaffStore                     store.ShopStaffStore
	ShopTranslationStore               store.ShopTranslationStore
	StaffNotificationRecipientStore    store.StaffNotificationRecipientStore
	StatusStore                        store.StatusStore
	StockStore                         store.StockStore
	SystemStore                        store.SystemStore
	TermsOfServiceStore                store.TermsOfServiceStore
	TokenStore                         store.TokenStore
	UploadSessionStore                 store.UploadSessionStore
	UserStore                          store.UserStore
	UserAccessTokenStore               store.UserAccessTokenStore
	VatStore                           store.VatStore
	VoucherChannelListingStore         store.VoucherChannelListingStore
	VoucherCustomerStore               store.VoucherCustomerStore
	VoucherTranslationStore            store.VoucherTranslationStore
	WarehouseStore                     store.WarehouseStore
	WishlistStore                      store.WishlistStore
	WishlistItemStore                  store.WishlistItemStore
}

func (s *TimerLayer) Address() store.AddressStore {
	return s.AddressStore
}

func (s *TimerLayer) Allocation() store.AllocationStore {
	return s.AllocationStore
}

func (s *TimerLayer) App() store.AppStore {
	return s.AppStore
}

func (s *TimerLayer) AppToken() store.AppTokenStore {
	return s.AppTokenStore
}

func (s *TimerLayer) AssignedPageAttribute() store.AssignedPageAttributeStore {
	return s.AssignedPageAttributeStore
}

func (s *TimerLayer) AssignedPageAttributeValue() store.AssignedPageAttributeValueStore {
	return s.AssignedPageAttributeValueStore
}

func (s *TimerLayer) AssignedProductAttribute() store.AssignedProductAttributeStore {
	return s.AssignedProductAttributeStore
}

func (s *TimerLayer) AssignedProductAttributeValue() store.AssignedProductAttributeValueStore {
	return s.AssignedProductAttributeValueStore
}

func (s *TimerLayer) Attribute() store.AttributeStore {
	return s.AttributeStore
}

func (s *TimerLayer) AttributePage() store.AttributePageStore {
	return s.AttributePageStore
}

func (s *TimerLayer) AttributeTranslation() store.AttributeTranslationStore {
	return s.AttributeTranslationStore
}

func (s *TimerLayer) AttributeValue() store.AttributeValueStore {
	return s.AttributeValueStore
}

func (s *TimerLayer) AttributeValueTranslation() store.AttributeValueTranslationStore {
	return s.AttributeValueTranslationStore
}

func (s *TimerLayer) Audit() store.AuditStore {
	return s.AuditStore
}

func (s *TimerLayer) Category() store.CategoryStore {
	return s.CategoryStore
}

func (s *TimerLayer) CategoryTranslation() store.CategoryTranslationStore {
	return s.CategoryTranslationStore
}

func (s *TimerLayer) Channel() store.ChannelStore {
	return s.ChannelStore
}

func (s *TimerLayer) Checkout() store.CheckoutStore {
	return s.CheckoutStore
}

func (s *TimerLayer) CheckoutLine() store.CheckoutLineStore {
	return s.CheckoutLineStore
}

func (s *TimerLayer) ClusterDiscovery() store.ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *TimerLayer) Collection() store.CollectionStore {
	return s.CollectionStore
}

func (s *TimerLayer) CollectionChannelListing() store.CollectionChannelListingStore {
	return s.CollectionChannelListingStore
}

func (s *TimerLayer) CollectionProduct() store.CollectionProductStore {
	return s.CollectionProductStore
}

func (s *TimerLayer) CollectionTranslation() store.CollectionTranslationStore {
	return s.CollectionTranslationStore
}

func (s *TimerLayer) Compliance() store.ComplianceStore {
	return s.ComplianceStore
}

func (s *TimerLayer) CsvExportEvent() store.CsvExportEventStore {
	return s.CsvExportEventStore
}

func (s *TimerLayer) CsvExportFile() store.CsvExportFileStore {
	return s.CsvExportFileStore
}

func (s *TimerLayer) CustomProductAttribute() store.CustomProductAttributeStore {
	return s.CustomProductAttributeStore
}

func (s *TimerLayer) CustomerEvent() store.CustomerEventStore {
	return s.CustomerEventStore
}

func (s *TimerLayer) CustomerNote() store.CustomerNoteStore {
	return s.CustomerNoteStore
}

func (s *TimerLayer) DigitalContent() store.DigitalContentStore {
	return s.DigitalContentStore
}

func (s *TimerLayer) DigitalContentUrl() store.DigitalContentUrlStore {
	return s.DigitalContentUrlStore
}

func (s *TimerLayer) DiscountSale() store.DiscountSaleStore {
	return s.DiscountSaleStore
}

func (s *TimerLayer) DiscountSaleChannelListing() store.DiscountSaleChannelListingStore {
	return s.DiscountSaleChannelListingStore
}

func (s *TimerLayer) DiscountSaleTranslation() store.DiscountSaleTranslationStore {
	return s.DiscountSaleTranslationStore
}

func (s *TimerLayer) DiscountVoucher() store.DiscountVoucherStore {
	return s.DiscountVoucherStore
}

func (s *TimerLayer) FileInfo() store.FileInfoStore {
	return s.FileInfoStore
}

func (s *TimerLayer) Fulfillment() store.FulfillmentStore {
	return s.FulfillmentStore
}

func (s *TimerLayer) FulfillmentLine() store.FulfillmentLineStore {
	return s.FulfillmentLineStore
}

func (s *TimerLayer) GiftCard() store.GiftCardStore {
	return s.GiftCardStore
}

func (s *TimerLayer) GiftcardEvent() store.GiftcardEventStore {
	return s.GiftcardEventStore
}

func (s *TimerLayer) Invoice() store.InvoiceStore {
	return s.InvoiceStore
}

func (s *TimerLayer) InvoiceEvent() store.InvoiceEventStore {
	return s.InvoiceEventStore
}

func (s *TimerLayer) Job() store.JobStore {
	return s.JobStore
}

func (s *TimerLayer) Menu() store.MenuStore {
	return s.MenuStore
}

func (s *TimerLayer) MenuItem() store.MenuItemStore {
	return s.MenuItemStore
}

func (s *TimerLayer) MenuItemTranslation() store.MenuItemTranslationStore {
	return s.MenuItemTranslationStore
}

func (s *TimerLayer) OpenExchangeRate() store.OpenExchangeRateStore {
	return s.OpenExchangeRateStore
}

func (s *TimerLayer) Order() store.OrderStore {
	return s.OrderStore
}

func (s *TimerLayer) OrderDiscount() store.OrderDiscountStore {
	return s.OrderDiscountStore
}

func (s *TimerLayer) OrderEvent() store.OrderEventStore {
	return s.OrderEventStore
}

func (s *TimerLayer) OrderLine() store.OrderLineStore {
	return s.OrderLineStore
}

func (s *TimerLayer) Page() store.PageStore {
	return s.PageStore
}

func (s *TimerLayer) PageTranslation() store.PageTranslationStore {
	return s.PageTranslationStore
}

func (s *TimerLayer) PageType() store.PageTypeStore {
	return s.PageTypeStore
}

func (s *TimerLayer) Payment() store.PaymentStore {
	return s.PaymentStore
}

func (s *TimerLayer) PaymentTransaction() store.PaymentTransactionStore {
	return s.PaymentTransactionStore
}

func (s *TimerLayer) Plugin() store.PluginStore {
	return s.PluginStore
}

func (s *TimerLayer) PluginConfiguration() store.PluginConfigurationStore {
	return s.PluginConfigurationStore
}

func (s *TimerLayer) Preference() store.PreferenceStore {
	return s.PreferenceStore
}

func (s *TimerLayer) PreorderAllocation() store.PreorderAllocationStore {
	return s.PreorderAllocationStore
}

func (s *TimerLayer) Product() store.ProductStore {
	return s.ProductStore
}

func (s *TimerLayer) ProductChannelListing() store.ProductChannelListingStore {
	return s.ProductChannelListingStore
}

func (s *TimerLayer) ProductMedia() store.ProductMediaStore {
	return s.ProductMediaStore
}

func (s *TimerLayer) ProductTranslation() store.ProductTranslationStore {
	return s.ProductTranslationStore
}

func (s *TimerLayer) ProductType() store.ProductTypeStore {
	return s.ProductTypeStore
}

func (s *TimerLayer) ProductVariant() store.ProductVariantStore {
	return s.ProductVariantStore
}

func (s *TimerLayer) ProductVariantChannelListing() store.ProductVariantChannelListingStore {
	return s.ProductVariantChannelListingStore
}

func (s *TimerLayer) ProductVariantTranslation() store.ProductVariantTranslationStore {
	return s.ProductVariantTranslationStore
}

func (s *TimerLayer) Role() store.RoleStore {
	return s.RoleStore
}

func (s *TimerLayer) Session() store.SessionStore {
	return s.SessionStore
}

func (s *TimerLayer) ShippingMethod() store.ShippingMethodStore {
	return s.ShippingMethodStore
}

func (s *TimerLayer) ShippingMethodChannelListing() store.ShippingMethodChannelListingStore {
	return s.ShippingMethodChannelListingStore
}

func (s *TimerLayer) ShippingMethodPostalCodeRule() store.ShippingMethodPostalCodeRuleStore {
	return s.ShippingMethodPostalCodeRuleStore
}

func (s *TimerLayer) ShippingMethodTranslation() store.ShippingMethodTranslationStore {
	return s.ShippingMethodTranslationStore
}

func (s *TimerLayer) ShippingZone() store.ShippingZoneStore {
	return s.ShippingZoneStore
}

func (s *TimerLayer) ShopStaff() store.ShopStaffStore {
	return s.ShopStaffStore
}

func (s *TimerLayer) ShopTranslation() store.ShopTranslationStore {
	return s.ShopTranslationStore
}

func (s *TimerLayer) StaffNotificationRecipient() store.StaffNotificationRecipientStore {
	return s.StaffNotificationRecipientStore
}

func (s *TimerLayer) Status() store.StatusStore {
	return s.StatusStore
}

func (s *TimerLayer) Stock() store.StockStore {
	return s.StockStore
}

func (s *TimerLayer) System() store.SystemStore {
	return s.SystemStore
}

func (s *TimerLayer) TermsOfService() store.TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *TimerLayer) Token() store.TokenStore {
	return s.TokenStore
}

func (s *TimerLayer) UploadSession() store.UploadSessionStore {
	return s.UploadSessionStore
}

func (s *TimerLayer) User() store.UserStore {
	return s.UserStore
}

func (s *TimerLayer) UserAccessToken() store.UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *TimerLayer) Vat() store.VatStore {
	return s.VatStore
}

func (s *TimerLayer) VoucherChannelListing() store.VoucherChannelListingStore {
	return s.VoucherChannelListingStore
}

func (s *TimerLayer) VoucherCustomer() store.VoucherCustomerStore {
	return s.VoucherCustomerStore
}

func (s *TimerLayer) VoucherTranslation() store.VoucherTranslationStore {
	return s.VoucherTranslationStore
}

func (s *TimerLayer) Warehouse() store.WarehouseStore {
	return s.WarehouseStore
}

func (s *TimerLayer) Wishlist() store.WishlistStore {
	return s.WishlistStore
}

func (s *TimerLayer) WishlistItem() store.WishlistItemStore {
	return s.WishlistItemStore
}

type TimerLayerAddressStore struct {
	store.AddressStore
	Root *TimerLayer
}

type TimerLayerAllocationStore struct {
	store.AllocationStore
	Root *TimerLayer
}

type TimerLayerAppStore struct {
	store.AppStore
	Root *TimerLayer
}

type TimerLayerAppTokenStore struct {
	store.AppTokenStore
	Root *TimerLayer
}

type TimerLayerAssignedPageAttributeStore struct {
	store.AssignedPageAttributeStore
	Root *TimerLayer
}

type TimerLayerAssignedPageAttributeValueStore struct {
	store.AssignedPageAttributeValueStore
	Root *TimerLayer
}

type TimerLayerAssignedProductAttributeStore struct {
	store.AssignedProductAttributeStore
	Root *TimerLayer
}

type TimerLayerAssignedProductAttributeValueStore struct {
	store.AssignedProductAttributeValueStore
	Root *TimerLayer
}

type TimerLayerAttributeStore struct {
	store.AttributeStore
	Root *TimerLayer
}

type TimerLayerAttributePageStore struct {
	store.AttributePageStore
	Root *TimerLayer
}

type TimerLayerAttributeTranslationStore struct {
	store.AttributeTranslationStore
	Root *TimerLayer
}

type TimerLayerAttributeValueStore struct {
	store.AttributeValueStore
	Root *TimerLayer
}

type TimerLayerAttributeValueTranslationStore struct {
	store.AttributeValueTranslationStore
	Root *TimerLayer
}

type TimerLayerAuditStore struct {
	store.AuditStore
	Root *TimerLayer
}

type TimerLayerCategoryStore struct {
	store.CategoryStore
	Root *TimerLayer
}

type TimerLayerCategoryTranslationStore struct {
	store.CategoryTranslationStore
	Root *TimerLayer
}

type TimerLayerChannelStore struct {
	store.ChannelStore
	Root *TimerLayer
}

type TimerLayerCheckoutStore struct {
	store.CheckoutStore
	Root *TimerLayer
}

type TimerLayerCheckoutLineStore struct {
	store.CheckoutLineStore
	Root *TimerLayer
}

type TimerLayerClusterDiscoveryStore struct {
	store.ClusterDiscoveryStore
	Root *TimerLayer
}

type TimerLayerCollectionStore struct {
	store.CollectionStore
	Root *TimerLayer
}

type TimerLayerCollectionChannelListingStore struct {
	store.CollectionChannelListingStore
	Root *TimerLayer
}

type TimerLayerCollectionProductStore struct {
	store.CollectionProductStore
	Root *TimerLayer
}

type TimerLayerCollectionTranslationStore struct {
	store.CollectionTranslationStore
	Root *TimerLayer
}

type TimerLayerComplianceStore struct {
	store.ComplianceStore
	Root *TimerLayer
}

type TimerLayerCsvExportEventStore struct {
	store.CsvExportEventStore
	Root *TimerLayer
}

type TimerLayerCsvExportFileStore struct {
	store.CsvExportFileStore
	Root *TimerLayer
}

type TimerLayerCustomProductAttributeStore struct {
	store.CustomProductAttributeStore
	Root *TimerLayer
}

type TimerLayerCustomerEventStore struct {
	store.CustomerEventStore
	Root *TimerLayer
}

type TimerLayerCustomerNoteStore struct {
	store.CustomerNoteStore
	Root *TimerLayer
}

type TimerLayerDigitalContentStore struct {
	store.DigitalContentStore
	Root *TimerLayer
}

type TimerLayerDigitalContentUrlStore struct {
	store.DigitalContentUrlStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleStore struct {
	store.DiscountSaleStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleChannelListingStore struct {
	store.DiscountSaleChannelListingStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleTranslationStore struct {
	store.DiscountSaleTranslationStore
	Root *TimerLayer
}

type TimerLayerDiscountVoucherStore struct {
	store.DiscountVoucherStore
	Root *TimerLayer
}

type TimerLayerFileInfoStore struct {
	store.FileInfoStore
	Root *TimerLayer
}

type TimerLayerFulfillmentStore struct {
	store.FulfillmentStore
	Root *TimerLayer
}

type TimerLayerFulfillmentLineStore struct {
	store.FulfillmentLineStore
	Root *TimerLayer
}

type TimerLayerGiftCardStore struct {
	store.GiftCardStore
	Root *TimerLayer
}

type TimerLayerGiftcardEventStore struct {
	store.GiftcardEventStore
	Root *TimerLayer
}

type TimerLayerInvoiceStore struct {
	store.InvoiceStore
	Root *TimerLayer
}

type TimerLayerInvoiceEventStore struct {
	store.InvoiceEventStore
	Root *TimerLayer
}

type TimerLayerJobStore struct {
	store.JobStore
	Root *TimerLayer
}

type TimerLayerMenuStore struct {
	store.MenuStore
	Root *TimerLayer
}

type TimerLayerMenuItemStore struct {
	store.MenuItemStore
	Root *TimerLayer
}

type TimerLayerMenuItemTranslationStore struct {
	store.MenuItemTranslationStore
	Root *TimerLayer
}

type TimerLayerOpenExchangeRateStore struct {
	store.OpenExchangeRateStore
	Root *TimerLayer
}

type TimerLayerOrderStore struct {
	store.OrderStore
	Root *TimerLayer
}

type TimerLayerOrderDiscountStore struct {
	store.OrderDiscountStore
	Root *TimerLayer
}

type TimerLayerOrderEventStore struct {
	store.OrderEventStore
	Root *TimerLayer
}

type TimerLayerOrderLineStore struct {
	store.OrderLineStore
	Root *TimerLayer
}

type TimerLayerPageStore struct {
	store.PageStore
	Root *TimerLayer
}

type TimerLayerPageTranslationStore struct {
	store.PageTranslationStore
	Root *TimerLayer
}

type TimerLayerPageTypeStore struct {
	store.PageTypeStore
	Root *TimerLayer
}

type TimerLayerPaymentStore struct {
	store.PaymentStore
	Root *TimerLayer
}

type TimerLayerPaymentTransactionStore struct {
	store.PaymentTransactionStore
	Root *TimerLayer
}

type TimerLayerPluginStore struct {
	store.PluginStore
	Root *TimerLayer
}

type TimerLayerPluginConfigurationStore struct {
	store.PluginConfigurationStore
	Root *TimerLayer
}

type TimerLayerPreferenceStore struct {
	store.PreferenceStore
	Root *TimerLayer
}

type TimerLayerPreorderAllocationStore struct {
	store.PreorderAllocationStore
	Root *TimerLayer
}

type TimerLayerProductStore struct {
	store.ProductStore
	Root *TimerLayer
}

type TimerLayerProductChannelListingStore struct {
	store.ProductChannelListingStore
	Root *TimerLayer
}

type TimerLayerProductMediaStore struct {
	store.ProductMediaStore
	Root *TimerLayer
}

type TimerLayerProductTranslationStore struct {
	store.ProductTranslationStore
	Root *TimerLayer
}

type TimerLayerProductTypeStore struct {
	store.ProductTypeStore
	Root *TimerLayer
}

type TimerLayerProductVariantStore struct {
	store.ProductVariantStore
	Root *TimerLayer
}

type TimerLayerProductVariantChannelListingStore struct {
	store.ProductVariantChannelListingStore
	Root *TimerLayer
}

type TimerLayerProductVariantTranslationStore struct {
	store.ProductVariantTranslationStore
	Root *TimerLayer
}

type TimerLayerRoleStore struct {
	store.RoleStore
	Root *TimerLayer
}

type TimerLayerSessionStore struct {
	store.SessionStore
	Root *TimerLayer
}

type TimerLayerShippingMethodStore struct {
	store.ShippingMethodStore
	Root *TimerLayer
}

type TimerLayerShippingMethodChannelListingStore struct {
	store.ShippingMethodChannelListingStore
	Root *TimerLayer
}

type TimerLayerShippingMethodPostalCodeRuleStore struct {
	store.ShippingMethodPostalCodeRuleStore
	Root *TimerLayer
}

type TimerLayerShippingMethodTranslationStore struct {
	store.ShippingMethodTranslationStore
	Root *TimerLayer
}

type TimerLayerShippingZoneStore struct {
	store.ShippingZoneStore
	Root *TimerLayer
}

type TimerLayerShopStaffStore struct {
	store.ShopStaffStore
	Root *TimerLayer
}

type TimerLayerShopTranslationStore struct {
	store.ShopTranslationStore
	Root *TimerLayer
}

type TimerLayerStaffNotificationRecipientStore struct {
	store.StaffNotificationRecipientStore
	Root *TimerLayer
}

type TimerLayerStatusStore struct {
	store.StatusStore
	Root *TimerLayer
}

type TimerLayerStockStore struct {
	store.StockStore
	Root *TimerLayer
}

type TimerLayerSystemStore struct {
	store.SystemStore
	Root *TimerLayer
}

type TimerLayerTermsOfServiceStore struct {
	store.TermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerTokenStore struct {
	store.TokenStore
	Root *TimerLayer
}

type TimerLayerUploadSessionStore struct {
	store.UploadSessionStore
	Root *TimerLayer
}

type TimerLayerUserStore struct {
	store.UserStore
	Root *TimerLayer
}

type TimerLayerUserAccessTokenStore struct {
	store.UserAccessTokenStore
	Root *TimerLayer
}

type TimerLayerVatStore struct {
	store.VatStore
	Root *TimerLayer
}

type TimerLayerVoucherChannelListingStore struct {
	store.VoucherChannelListingStore
	Root *TimerLayer
}

type TimerLayerVoucherCustomerStore struct {
	store.VoucherCustomerStore
	Root *TimerLayer
}

type TimerLayerVoucherTranslationStore struct {
	store.VoucherTranslationStore
	Root *TimerLayer
}

type TimerLayerWarehouseStore struct {
	store.WarehouseStore
	Root *TimerLayer
}

type TimerLayerWishlistStore struct {
	store.WishlistStore
	Root *TimerLayer
}

type TimerLayerWishlistItemStore struct {
	store.WishlistItemStore
	Root *TimerLayer
}

func (s *TimerLayerAddressStore) DeleteAddresses(tx boil.ContextTransactor, addressIDs []string) error {
	start := timemodule.Now()

	err := s.AddressStore.DeleteAddresses(tx, addressIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.DeleteAddresses", success, elapsed)
	}
	return err
}

func (s *TimerLayerAddressStore) FilterByOption(option model_helper.AddressFilterOptions) (model.AddressSlice, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAddressStore) Get(addressID string) (*model.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.Get(addressID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAddressStore) Upsert(tx boil.ContextTransactor, address model.Address) (*model.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.Upsert(tx, address)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) BulkUpsert(tx boil.ContextTransactor, allocations model.AllocationSlice) (model.AllocationSlice, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.BulkUpsert(tx, allocations)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) CountAvailableQuantityForStock(stock model.Stock) (int, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.CountAvailableQuantityForStock(stock)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.CountAvailableQuantityForStock", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.AllocationStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerAllocationStore) FilterByOption(option model_helper.AllocationFilterOption) (model.AllocationSlice, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) Get(id string) (*model.Allocation, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) FilterByOptions(options model_helper.AssignedPageAttributeFilterOption) (model.AssignedPageAttributeSlice, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) Get(id string) (*model.AssignedPageAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) Upsert(assignedPageAttr model.AssignedPageAttribute) (*model.AssignedPageAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.Upsert(assignedPageAttr)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) Get(assignedPageAttrValueID string) (*model.AssignedPageAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeValueStore.Get(assignedPageAttrValueID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) SelectForSort(assignmentID string) (model.AssignedPageAttributeValueSlice, model.AttributeValueSlice, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.AssignedPageAttributeValueStore.SelectForSort(assignmentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.SelectForSort", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) Upsert(tx boil.ContextTransactor, assignedPageAttrValue model.AssignedPageAttributeValueSlice) (model.AssignedPageAttributeValueSlice, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeValueStore.Upsert(tx, assignedPageAttrValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeStore) FilterByOptions(options model_helper.AssignedProductAttributeFilterOption) (model.AssignedProductAttributeSlice, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeStore) GetWithOption(option model_helper.AssignedProductAttributeFilterOption) (*model.AssignedProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.GetWithOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.GetWithOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) FilterByOptions(options model_helper.AssignedProductAttributeValueFilterOptions) (model.AssignedProductAttributeValueSlice, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) Get(assignedProductAttrValueID string) (*model.AssignedProductAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.Get(assignedProductAttrValueID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) Save(assignedProductAttrValue model.AssignedProductAttributeValue) (*model.AssignedProductAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.Save(assignedProductAttrValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) SelectForSort(assignmentID string) (model.AssignedProductAttributeValueSlice, model.AttributeValueSlice, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.AssignedProductAttributeValueStore.SelectForSort(assignmentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.SelectForSort", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAttributeStore) CountByOptions(options model_helper.AttributeFilterOption) (int64, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.CountByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.CountByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) FilterbyOption(option model_helper.AttributeFilterOption) (model.AttributeSlice, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) GetPageTypeAttributes(pageTypeID string, unassigned bool) (model.AttributeSlice, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.GetPageTypeAttributes(pageTypeID, unassigned)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.GetPageTypeAttributes", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) GetProductTypeAttributes(productTypeID string, unassigned bool, filter model_helper.AttributeFilterOption) (model.AttributeSlice, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.GetProductTypeAttributes(productTypeID, unassigned, filter)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.GetProductTypeAttributes", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) Upsert(attr model.Attribute) (*model.Attribute, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.Upsert(attr)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) Get(pageID string) (*model.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.Get(pageID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) GetByOption(option model_helper.AttributePageFilterOption) (*model.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) Save(page model.AttributePage) (*model.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.Save(page)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Count(options model_helper.AttributeValueFilterOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Count(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) FilterByOptions(options model_helper.AttributeValueFilterOptions) (model.AttributeValueSlice, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Get(attributeID string) (*model.AttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Get(attributeID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Upsert(tx boil.ContextTransactor, values model.AttributeValueSlice) (model.AttributeValueSlice, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Upsert(tx, values)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAuditStore) Get(userID string, offset int, limit int) (model.AuditSlice, error) {
	start := timemodule.Now()

	result, err := s.AuditStore.Get(userID, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAuditStore) PermanentDeleteByUser(userID string) error {
	start := timemodule.Now()

	err := s.AuditStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerAuditStore) Save(audit model.Audit) error {
	start := timemodule.Now()

	err := s.AuditStore.Save(audit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerCategoryStore) FilterByOption(option *model.CategoryFilterOption) ([]*model.Category, error) {
	start := timemodule.Now()

	result, err := s.CategoryStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CategoryStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCategoryStore) Get(ctx context.Context, categoryID string, allowFromCache bool) (*model.Category, error) {
	start := timemodule.Now()

	result, err := s.CategoryStore.Get(ctx, categoryID, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CategoryStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCategoryStore) GetByOption(option *model.CategoryFilterOption) (*model.Category, error) {
	start := timemodule.Now()

	result, err := s.CategoryStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CategoryStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCategoryStore) Upsert(category *model.Category) (*model.Category, error) {
	start := timemodule.Now()

	result, err := s.CategoryStore.Upsert(category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CategoryStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) DeleteChannels(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.ChannelStore.DeleteChannels(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.DeleteChannels", success, elapsed)
	}
	return err
}

func (s *TimerLayerChannelStore) Find(conds model_helper.ChannelFilterOptions) (model.ChannelSlice, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.Find(conds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Find", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) Get(id string) (*model.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetByOptions(conds model_helper.ChannelFilterOptions) (*model.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.GetByOptions(conds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) Upsert(tx boil.ContextTransactor, channel model.Channel) (*model.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.Upsert(tx, channel)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) CountCheckouts(options model_helper.CheckoutFilterOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.CountCheckouts(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.CountCheckouts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.CheckoutStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerCheckoutStore) FetchCheckoutLinesAndPrefetchRelatedValue(checkout model.Checkout) (model_helper.CheckoutLineInfos, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.FetchCheckoutLinesAndPrefetchRelatedValue(checkout)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.FetchCheckoutLinesAndPrefetchRelatedValue", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) FilterByOption(option model_helper.CheckoutFilterOptions) (model.CheckoutSlice, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) GetByOption(option model_helper.CheckoutFilterOptions) (*model.Checkout, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) Upsert(tx boil.ContextTransactor, checkouts model.CheckoutSlice) (model.CheckoutSlice, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.Upsert(tx, checkouts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) CheckoutLinesByOption(option model_helper.CheckoutLineFilterOptions) (model.CheckoutLineSlice, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.CheckoutLinesByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.CheckoutLinesByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) DeleteLines(tx boil.ContextTransactor, checkoutLineIDs []string) error {
	start := timemodule.Now()

	err := s.CheckoutLineStore.DeleteLines(tx, checkoutLineIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.DeleteLines", success, elapsed)
	}
	return err
}

func (s *TimerLayerCheckoutLineStore) Get(id string) (*model.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) TotalWeightForCheckoutLines(checkoutLineIDs []string) (*measurement.Weight, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.TotalWeightForCheckoutLines(checkoutLineIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.TotalWeightForCheckoutLines", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) Upsert(checkoutLines model.CheckoutLineSlice) (model.CheckoutLineSlice, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.Upsert(checkoutLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Cleanup() error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Cleanup", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) Delete(discovery model.ClusterDiscovery) (bool, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.Delete(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Exists(discovery model.ClusterDiscovery) (bool, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.Exists(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Exists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) (model.ClusterDiscoverySlice, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Save(discovery model.ClusterDiscovery) error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.Save(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) SetLastPingAt(discovery model.ClusterDiscovery) error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.SetLastPingAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerCollectionStore) Delete(ids ...string) error {
	start := timemodule.Now()

	err := s.CollectionStore.Delete(ids...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerCollectionStore) FilterByOption(option *model.CollectionFilterOption) (int64, []*model.Collection, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.CollectionStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionStore.FilterByOption", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerCollectionStore) Get(collectionID string) (*model.Collection, error) {
	start := timemodule.Now()

	result, err := s.CollectionStore.Get(collectionID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionStore) Upsert(collection *model.Collection) (*model.Collection, error) {
	start := timemodule.Now()

	result, err := s.CollectionStore.Upsert(collection)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionChannelListingStore) Delete(tx boil.ContextTransactor, options *model.CollectionChannelListingFilterOptions) error {
	start := timemodule.Now()

	err := s.CollectionChannelListingStore.Delete(tx, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionChannelListingStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerCollectionChannelListingStore) FilterByOptions(options *model.CollectionChannelListingFilterOptions) ([]*model.CollectionChannelListing, error) {
	start := timemodule.Now()

	result, err := s.CollectionChannelListingStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionChannelListingStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionChannelListingStore) Upsert(tx boil.ContextTransactor, relations ...*model.CollectionChannelListing) ([]*model.CollectionChannelListing, error) {
	start := timemodule.Now()

	result, err := s.CollectionChannelListingStore.Upsert(tx, relations...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionChannelListingStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionProductStore) BulkSave(tx boil.ContextTransactor, relations []*model.CollectionProduct) ([]*model.CollectionProduct, error) {
	start := timemodule.Now()

	result, err := s.CollectionProductStore.BulkSave(tx, relations)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionProductStore.BulkSave", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionProductStore) Delete(tx boil.ContextTransactor, options *model.CollectionProductFilterOptions) error {
	start := timemodule.Now()

	err := s.CollectionProductStore.Delete(tx, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionProductStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerCollectionProductStore) FilterByOptions(options *model.CollectionProductFilterOptions) ([]*model.CollectionProduct, error) {
	start := timemodule.Now()

	result, err := s.CollectionProductStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionProductStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) ComplianceExport(model model.Compliance, cursor model_helper.ComplianceExportCursor, limit int) ([]*model_helper.CompliancePost, model_helper.ComplianceExportCursor, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.ComplianceStore.ComplianceExport(model, cursor, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.ComplianceExport", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerComplianceStore) Get(id string) (*model.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) GetAll(offset int, limit int) (model.ComplianceSlice, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) MessageExport(cursor model_helper.MessageExportCursor, limit int) ([]*model_helper.MessageExport, model_helper.MessageExportCursor, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.ComplianceStore.MessageExport(cursor, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.MessageExport", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerComplianceStore) Upsert(model model.Compliance) (*model.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Upsert(model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportEventStore) FilterByOption(options model_helper.ExportEventFilterOption) ([]*model.ExportEvent, error) {
	start := timemodule.Now()

	result, err := s.CsvExportEventStore.FilterByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportEventStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportEventStore) Save(event model.ExportEvent) (*model.ExportEvent, error) {
	start := timemodule.Now()

	result, err := s.CsvExportEventStore.Save(event)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportEventStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportFileStore) Get(id string) (*model.ExportFile, error) {
	start := timemodule.Now()

	result, err := s.CsvExportFileStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportFileStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportFileStore) Save(file model.ExportFile) (*model.ExportFile, error) {
	start := timemodule.Now()

	result, err := s.CsvExportFileStore.Save(file)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportFileStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomProductAttributeStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.CustomProductAttributeStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomProductAttributeStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomProductAttributeStore) FilterByOptions(options model_helper.CustomProductAttributeFilterOptions) (model.CustomProductAttributeSlice, error) {
	start := timemodule.Now()

	result, err := s.CustomProductAttributeStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomProductAttributeStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomProductAttributeStore) Upsert(tx boil.ContextTransactor, record model.CustomProductAttribute) (*model.CustomProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.CustomProductAttributeStore.Upsert(tx, record)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomProductAttributeStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Count() (int64, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Count()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) FilterByOptions(queryMods ...qm.QueryMod) (model.CustomerEventSlice, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.FilterByOptions(queryMods...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Get(id string) (*model.CustomerEvent, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Upsert(tx boil.ContextTransactor, customemrEvent model.CustomerEvent) (*model.CustomerEvent, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Upsert(tx, customemrEvent)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerNoteStore) Get(id string) (*model.CustomerNote, error) {
	start := timemodule.Now()

	result, err := s.CustomerNoteStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerNoteStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerNoteStore) Upsert(note model.CustomerNote) (*model.CustomerNote, error) {
	start := timemodule.Now()

	result, err := s.CustomerNoteStore.Upsert(note)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerNoteStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentStore) Delete(tx boil.ContextTransactor, options *model.DigitalContentFilterOption) error {
	start := timemodule.Now()

	err := s.DigitalContentStore.Delete(tx, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerDigitalContentStore) FilterByOption(option *model.DigitalContentFilterOption) (int64, []*model.DigitalContent, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.DigitalContentStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentStore.FilterByOption", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerDigitalContentStore) GetByOption(option *model.DigitalContentFilterOption) (*model.DigitalContent, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentStore) Save(content *model.DigitalContent) (*model.DigitalContent, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentStore.Save(content)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentUrlStore) FilterByOptions(options *model.DigitalContentUrlFilterOptions) ([]*model.DigitalContentUrl, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentUrlStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentUrlStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentUrlStore) Get(id string) (*model.DigitalContentUrl, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentUrlStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentUrlStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentUrlStore) Upsert(contentURL *model.DigitalContentUrl) (*model.DigitalContentUrl, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentUrlStore.Upsert(contentURL)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentUrlStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) FilterSalesByOption(option model_helper.SaleFilterOption) (model_helper.CustomSaleSlice, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.FilterSalesByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.FilterSalesByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) Get(saleID string) (*model.Sale, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.Get(saleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) Upsert(tx boil.ContextTransactor, sale model.Sale) (*model.Sale, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.Upsert(tx, sale)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleChannelListingStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.DiscountSaleChannelListingStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleChannelListingStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerDiscountSaleChannelListingStore) FilterByOptions(option model_helper.SaleChannelListingFilterOption) (model.SaleChannelListingSlice, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleChannelListingStore.FilterByOptions(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleChannelListingStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleChannelListingStore) Get(id string) (*model.SaleChannelListing, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleChannelListingStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleChannelListingStore) Upsert(tx boil.ContextTransactor, listings model.SaleChannelListingSlice) (model.SaleChannelListingSlice, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleChannelListingStore.Upsert(tx, listings)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleChannelListingStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) ExpiredVouchers(date timemodule.Time) (model.VoucherSlice, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.ExpiredVouchers(date)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.ExpiredVouchers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) FilterVouchersByOption(option model_helper.VoucherFilterOption) (model_helper.CustomVoucherSlice, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.FilterVouchersByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.FilterVouchersByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) Get(id string) (*model.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) Upsert(voucher model.Voucher) (*model.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.Upsert(voucher)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) ClearCaches() {
	start := timemodule.Now()

	s.FileInfoStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) CountAll() (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.CountAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.CountAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Get(id string, fromMaster bool) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Get(id, fromMaster)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetWithOptions(options model_helper.FileInfoFilterOption) (model.FileInfoSlice, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetWithOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) InvalidateFileInfosForPostCache(postID string, deleted bool) {
	start := timemodule.Now()

	s.FileInfoStore.InvalidateFileInfosForPostCache(postID, deleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.InvalidateFileInfosForPostCache", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) PermanentDelete(fileID string) error {
	start := timemodule.Now()

	err := s.FileInfoStore.PermanentDelete(fileID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteByUser(userID string) (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Upsert(info model.FileInfo) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Upsert(info)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) BulkDeleteFulfillments(tx boil.ContextTransactor, fulfillments model.Fulfillments) error {
	start := timemodule.Now()

	err := s.FulfillmentStore.BulkDeleteFulfillments(tx, fulfillments)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.BulkDeleteFulfillments", success, elapsed)
	}
	return err
}

func (s *TimerLayerFulfillmentStore) FilterByOption(option *model.FulfillmentFilterOption) ([]*model.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) Get(id string) (*model.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) GetByOption(option *model.FulfillmentFilterOption) (*model.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) Upsert(tx boil.ContextTransactor, fulfillment *model.Fulfillment) (*model.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.Upsert(tx, fulfillment)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) BulkUpsert(tx boil.ContextTransactor, fulfillmentLines []*model.FulfillmentLine) ([]*model.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.BulkUpsert(tx, fulfillmentLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) DeleteFulfillmentLinesByOption(tx boil.ContextTransactor, option *model.FulfillmentLineFilterOption) error {
	start := timemodule.Now()

	err := s.FulfillmentLineStore.DeleteFulfillmentLinesByOption(tx, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.DeleteFulfillmentLinesByOption", success, elapsed)
	}
	return err
}

func (s *TimerLayerFulfillmentLineStore) FilterbyOption(option *model.FulfillmentLineFilterOption) ([]*model.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) Get(id string) (*model.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) Save(fulfillmentLine *model.FulfillmentLine) (*model.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.Save(fulfillmentLine)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) BulkUpsert(tx boil.ContextTransactor, giftCards model.GiftcardSlice) (model.GiftcardSlice, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.BulkUpsert(tx, giftCards)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) DeactivateOrderGiftcards(tx boil.ContextTransactor, orderID string) ([]string, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.DeactivateOrderGiftcards(tx, orderID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.DeactivateOrderGiftcards", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.GiftCardStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerGiftCardStore) FilterByOption(option *model.GiftCardFilterOption) (int64, model.GiftcardSlice, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.GiftCardStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.FilterByOption", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerGiftCardStore) GetById(id string) (*model.Giftcard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftcardEventStore) FilterByOptions(options model_helper.GiftCardEventFilterOption) (model.GiftcardEventSlice, error) {
	start := timemodule.Now()

	result, err := s.GiftcardEventStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftcardEventStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftcardEventStore) Get(id string) (*model.GiftcardEvent, error) {
	start := timemodule.Now()

	result, err := s.GiftcardEventStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftcardEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftcardEventStore) Upsert(tx boil.ContextTransactor, events model.GiftcardEventSlice) (model.GiftcardEventSlice, error) {
	start := timemodule.Now()

	result, err := s.GiftcardEventStore.Upsert(tx, events)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftcardEventStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.InvoiceStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerInvoiceStore) FilterByOptions(options model_helper.InvoiceFilterOption) (model.InvoiceSlice, error) {
	start := timemodule.Now()

	result, err := s.InvoiceStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceStore) GetbyOptions(options model_helper.InvoiceFilterOption) (*model.Invoice, error) {
	start := timemodule.Now()

	result, err := s.InvoiceStore.GetbyOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceStore.GetbyOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceStore) Upsert(invoice model.Invoice) (*model.Invoice, error) {
	start := timemodule.Now()

	result, err := s.InvoiceStore.Upsert(invoice)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceEventStore) Get(id string) (*model.InvoiceEvent, error) {
	start := timemodule.Now()

	result, err := s.InvoiceEventStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceEventStore) Upsert(invoiceEvent model.InvoiceEvent) (*model.InvoiceEvent, error) {
	start := timemodule.Now()

	result, err := s.InvoiceEventStore.Upsert(invoiceEvent)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceEventStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Count(mods ...qm.QueryMod) (int64, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Count(mods...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Delete(id string) (string, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) FindAll(mods ...qm.QueryMod) (model.JobSlice, error) {
	start := timemodule.Now()

	result, err := s.JobStore.FindAll(mods...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.FindAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Get(mods ...qm.QueryMod) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Get(mods...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Save(job model.Job) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Save(job)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateOptimistically(job model.Job, currentStatus model.JobStatus) (bool, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateOptimistically(job, currentStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatus(id string, status model.JobStatus) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateStatus(id, status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatusOptimistically(id string, currentStatus model.JobStatus, newStatus model.JobStatus) (bool, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatusOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) FilterByOptions(options model_helper.MenuFilterOptions) (model.MenuSlice, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) GetByOptions(options model_helper.MenuFilterOptions) (*model.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) Upsert(menu model.Menu) (*model.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.Upsert(menu)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) Delete(ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.Delete(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) FilterByOptions(options model_helper.MenuItemFilterOptions) (model.MenuItemSlice, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) GetByOptions(options model_helper.MenuItemFilterOptions) (*model.MenuItem, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) Upsert(menuItem model.MenuItem) (*model.MenuItem, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.Upsert(menuItem)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOpenExchangeRateStore) BulkUpsert(rates model.OpenExchangeRateSlice) (model.OpenExchangeRateSlice, error) {
	start := timemodule.Now()

	result, err := s.OpenExchangeRateStore.BulkUpsert(rates)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OpenExchangeRateStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOpenExchangeRateStore) GetAll() (model.OpenExchangeRateSlice, error) {
	start := timemodule.Now()

	result, err := s.OpenExchangeRateStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OpenExchangeRateStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) BulkUpsert(tx boil.ContextTransactor, orders []*model.Order) ([]*model.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.BulkUpsert(tx, orders)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) FilterByOption(option *model.OrderFilterOption) (int64, []*model.Order, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.OrderStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.FilterByOption", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerOrderStore) Get(id string) (*model.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderDiscountStore) BulkDelete(ids []string) error {
	start := timemodule.Now()

	err := s.OrderDiscountStore.BulkDelete(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderDiscountStore.BulkDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerOrderDiscountStore) FilterbyOption(option model_helper.OrderDiscountFilterOption) (model.OrderDiscountSlice, error) {
	start := timemodule.Now()

	result, err := s.OrderDiscountStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderDiscountStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderDiscountStore) Get(orderDiscountID string) (*model.OrderDiscount, error) {
	start := timemodule.Now()

	result, err := s.OrderDiscountStore.Get(orderDiscountID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderDiscountStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderDiscountStore) Upsert(tx boil.ContextTransactor, orderDiscount model.OrderDiscount) (*model.OrderDiscount, error) {
	start := timemodule.Now()

	result, err := s.OrderDiscountStore.Upsert(tx, orderDiscount)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderDiscountStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderEventStore) FilterByOptions(options *model.OrderEventFilterOptions) ([]*model.OrderEvent, error) {
	start := timemodule.Now()

	result, err := s.OrderEventStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderEventStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderEventStore) Get(orderEventID string) (*model.OrderEvent, error) {
	start := timemodule.Now()

	result, err := s.OrderEventStore.Get(orderEventID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderEventStore) Save(tx boil.ContextTransactor, orderEvent *model.OrderEvent) (*model.OrderEvent, error) {
	start := timemodule.Now()

	result, err := s.OrderEventStore.Save(tx, orderEvent)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderEventStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) BulkDelete(tx boil.ContextTransactor, orderLineIDs []string) error {
	start := timemodule.Now()

	err := s.OrderLineStore.BulkDelete(tx, orderLineIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.BulkDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerOrderLineStore) BulkUpsert(tx boil.ContextTransactor, orderLines []*model.OrderLine) ([]*model.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.BulkUpsert(tx, orderLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) FilterbyOption(option *model.OrderLineFilterOption) (model.OrderLineSlice, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) Get(id string) (*model.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) Upsert(tx boil.ContextTransactor, orderLine *model.OrderLine) (*model.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.Upsert(tx, orderLine)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPageStore) FilterByOptions(options model_helper.PageFilterOptions) (model.PageSlice, error) {
	start := timemodule.Now()

	result, err := s.PageStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) CancelActivePaymentsOfCheckout(checkoutToken string) error {
	start := timemodule.Now()

	err := s.PaymentStore.CancelActivePaymentsOfCheckout(checkoutToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.CancelActivePaymentsOfCheckout", success, elapsed)
	}
	return err
}

func (s *TimerLayerPaymentStore) FilterByOption(option *model.PaymentFilterOption) (int64, []*model.Payment, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.PaymentStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.FilterByOption", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerPaymentStore) PaymentOwnedByUser(userID string, paymentID string) (bool, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.PaymentOwnedByUser(userID, paymentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.PaymentOwnedByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) Save(tx boil.ContextTransactor, model *model.Payment) (*model.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.Save(tx, model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) Update(tx boil.ContextTransactor, model *model.Payment) (*model.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.Update(tx, model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) UpdatePaymentsOfCheckout(tx boil.ContextTransactor, checkoutToken string, option *model.PaymentPatch) error {
	start := timemodule.Now()

	err := s.PaymentStore.UpdatePaymentsOfCheckout(tx, checkoutToken, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.UpdatePaymentsOfCheckout", success, elapsed)
	}
	return err
}

func (s *TimerLayerPaymentTransactionStore) FilterByOption(option *model.PaymentTransactionFilterOpts) ([]*model.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Get(id string) (*model.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Save(tx boil.ContextTransactor, paymentTransaction *model.PaymentTransaction) (*model.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Save(tx, paymentTransaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Update(transaction *model.PaymentTransaction) (*model.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Update(transaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.CompareAndDelete(keyVal, oldValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndDelete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.CompareAndSet(keyVal, oldValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndSet", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) Delete(pluginID string, key string) error {
	start := timemodule.Now()

	err := s.PluginStore.Delete(pluginID, key)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllExpired() error {
	start := timemodule.Now()

	err := s.PluginStore.DeleteAllExpired()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllExpired", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllForPlugin(PluginID string) error {
	start := timemodule.Now()

	err := s.PluginStore.DeleteAllForPlugin(PluginID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllForPlugin", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) Get(pluginID string, key string) (*model.PluginKeyValue, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.Get(pluginID, key)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) List(pluginID string, page int, perPage int) ([]string, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.List(pluginID, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.List", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.SaveOrUpdate(keyVal)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SaveOrUpdate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SetWithOptions(pluginID string, key string, value []byte, options model.PluginKVSetOptions) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.SetWithOptions(pluginID, key, value, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginConfigurationStore) FilterPluginConfigurations(options model.PluginConfigurationFilterOptions) (model.PluginConfigurationSlice, error) {
	start := timemodule.Now()

	result, err := s.PluginConfigurationStore.FilterPluginConfigurations(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginConfigurationStore.FilterPluginConfigurations", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginConfigurationStore) Get(id string) (*model.PluginConfiguration, error) {
	start := timemodule.Now()

	result, err := s.PluginConfigurationStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginConfigurationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginConfigurationStore) GetByOptions(options model.PluginConfigurationFilterOptions) (*model.PluginConfiguration, error) {
	start := timemodule.Now()

	result, err := s.PluginConfigurationStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginConfigurationStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginConfigurationStore) Upsert(config model.PluginConfiguration) (*model.PluginConfiguration, error) {
	start := timemodule.Now()

	result, err := s.PluginConfigurationStore.Upsert(config)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginConfigurationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.CleanupFlagsBatch(limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.CleanupFlagsBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) Delete(userID string, category string, name string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.Delete(userID, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategory(userID string, category string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.DeleteCategory(userID, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategory", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategoryAndName(category string, name string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.DeleteCategoryAndName(category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategoryAndName", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteUnusedFeatures() {
	start := timemodule.Now()

	s.PreferenceStore.DeleteUnusedFeatures()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteUnusedFeatures", success, elapsed)
	}
}

func (s *TimerLayerPreferenceStore) Get(userID string, category string, name string) (*model.Preference, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.Get(userID, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetAll(userID string) (model.PreferenceSlice, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.GetAll(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetCategory(userID string, category string) (model.PreferenceSlice, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.GetCategory(userID, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetCategory", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) PermanentDeleteByUser(userID string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) Save(preferences model.PreferenceSlice) error {
	start := timemodule.Now()

	err := s.PreferenceStore.Save(preferences)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreorderAllocationStore) BulkCreate(tx boil.ContextTransactor, preorderAllocations model.PreorderAllocationSlice) (model.PreorderAllocationSlice, error) {
	start := timemodule.Now()

	result, err := s.PreorderAllocationStore.BulkCreate(tx, preorderAllocations)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreorderAllocationStore.BulkCreate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreorderAllocationStore) Delete(tx boil.ContextTransactor, preorderAllocationIDs ...string) error {
	start := timemodule.Now()

	err := s.PreorderAllocationStore.Delete(tx, preorderAllocationIDs...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreorderAllocationStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreorderAllocationStore) FilterByOption(options model.PreorderAllocationFilterOption) (model.PreorderAllocationSlice, error) {
	start := timemodule.Now()

	result, err := s.PreorderAllocationStore.FilterByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreorderAllocationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) AdvancedFilterQueryBuilder(input *model.ExportProductsFilterOptions) squirrel.SelectBuilder {
	start := timemodule.Now()

	result := s.ProductStore.AdvancedFilterQueryBuilder(input)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.AdvancedFilterQueryBuilder", success, elapsed)
	}
	return result
}

func (s *TimerLayerProductStore) CountByCategoryIDs(categoryIDs []string) ([]*model.ProductCountByCategoryID, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.CountByCategoryIDs(categoryIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.CountByCategoryIDs", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) FilterByOption(option *model.ProductFilterOption) (model.ProductSlice, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) FilterByQuery(query squirrel.SelectBuilder) (model.Products, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.FilterByQuery(query)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.FilterByQuery", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) GetByOption(option *model.ProductFilterOption) (*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) NotPublishedProducts(channelID string) (model.Products, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.NotPublishedProducts(channelID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.NotPublishedProducts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) PublishedProducts(channelSlug string) (model.ProductSlice, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.PublishedProducts(channelSlug)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.PublishedProducts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) PublishedWithVariants(channelIdOrSlug string) squirrel.SelectBuilder {
	start := timemodule.Now()

	result := s.ProductStore.PublishedWithVariants(channelIdOrSlug)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.PublishedWithVariants", success, elapsed)
	}
	return result
}

func (s *TimerLayerProductStore) Save(tx boil.ContextTransactor, product *model.Product) (*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.Save(tx, product)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) SelectForUpdateDiscountedPricesOfCatalogues(tx boil.ContextTransactor, productIDs []string, categoryIDs []string, collectionIDs []string, variantIDs []string) (model.ProductSlice, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.SelectForUpdateDiscountedPricesOfCatalogues(tx, productIDs, categoryIDs, collectionIDs, variantIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.SelectForUpdateDiscountedPricesOfCatalogues", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) VisibleToUserProductsQuery(channelIdOrSlug string, userHasOneOfProductpermissions bool) squirrel.SelectBuilder {
	start := timemodule.Now()

	result := s.ProductStore.VisibleToUserProductsQuery(channelIdOrSlug, userHasOneOfProductpermissions)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.VisibleToUserProductsQuery", success, elapsed)
	}
	return result
}

func (s *TimerLayerProductChannelListingStore) BulkUpsert(tx boil.ContextTransactor, listings []*model.ProductChannelListing) ([]*model.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.BulkUpsert(tx, listings)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductChannelListingStore) FilterByOption(option *model.ProductChannelListingFilterOption) ([]*model.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductChannelListingStore) Get(channelListingID string) (*model.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.Get(channelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductMediaStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.ProductMediaStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductMediaStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductMediaStore) FilterByOption(option *model.ProductMediaFilterOption) ([]*model.ProductMedia, error) {
	start := timemodule.Now()

	result, err := s.ProductMediaStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductMediaStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductMediaStore) Get(id string) (*model.ProductMedia, error) {
	start := timemodule.Now()

	result, err := s.ProductMediaStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductMediaStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductMediaStore) Upsert(tx boil.ContextTransactor, medias model.ProductMedias) (model.ProductMedias, error) {
	start := timemodule.Now()

	result, err := s.ProductMediaStore.Upsert(tx, medias)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductMediaStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTranslationStore) FilterByOption(option *model.ProductTranslationFilterOption) ([]*model.ProductTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductTranslationStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTranslationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTranslationStore) Get(translationID string) (*model.ProductTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductTranslationStore.Get(translationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTranslationStore) Upsert(translation *model.ProductTranslation) (*model.ProductTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductTranslationStore.Upsert(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTranslationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) FilterProductTypesByCheckoutToken(checkoutToken string) ([]*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.FilterProductTypesByCheckoutToken(checkoutToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.FilterProductTypesByCheckoutToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) FilterbyOption(options *model.ProductTypeFilterOption) (int64, []*model.ProductType, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.ProductTypeStore.FilterbyOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.FilterbyOption", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerProductTypeStore) GetByOption(options *model.ProductTypeFilterOption) (*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.GetByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) ProductTypeByProductVariantID(variantID string) (*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.ProductTypeByProductVariantID(variantID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.ProductTypeByProductVariantID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) ProductTypesByProductIDs(productIDs []string) ([]*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.ProductTypesByProductIDs(productIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.ProductTypesByProductIDs", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) Save(tx boil.ContextTransactor, productType *model.ProductType) (*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.Save(tx, productType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) ToggleProductTypeRelations(tx boil.ContextTransactor, productTypeID string, productAttributes model.AttributeSlice, variantAttributes model.AttributeSlice, isDelete bool) error {
	start := timemodule.Now()

	err := s.ProductTypeStore.ToggleProductTypeRelations(tx, productTypeID, productAttributes, variantAttributes, isDelete)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.ToggleProductTypeRelations", success, elapsed)
	}
	return err
}

func (s *TimerLayerProductVariantStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) FilterByOption(option *model.ProductVariantFilterOption) (model.ProductVariantSlice, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) FindVariantsAvailableForPurchase(variantIds []string, channelID string) (model.ProductVariants, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.FindVariantsAvailableForPurchase(variantIds, channelID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.FindVariantsAvailableForPurchase", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) Get(id string) (*model.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) GetByOrderLineID(orderLineID string) (*model.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.GetByOrderLineID(orderLineID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.GetByOrderLineID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) GetWeight(productVariantID string) (*measurement.Weight, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.GetWeight(productVariantID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.GetWeight", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) Save(tx boil.ContextTransactor, variant *model.ProductVariant) (*model.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.Save(tx, variant)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) ToggleProductVariantRelations(tx boil.ContextTransactor, variants model.ProductVariants, medias model.ProductMedias, sales model.Sales, vouchers model.Vouchers, wishlistItems model.WishlistItems, isDelete bool) error {
	start := timemodule.Now()

	err := s.ProductVariantStore.ToggleProductVariantRelations(tx, variants, medias, sales, vouchers, wishlistItems, isDelete)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.ToggleProductVariantRelations", success, elapsed)
	}
	return err
}

func (s *TimerLayerProductVariantChannelListingStore) BulkUpsert(tx boil.ContextTransactor, variantChannelListings []*model.ProductVariantChannelListing) ([]*model.ProductVariantChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantChannelListingStore.BulkUpsert(tx, variantChannelListings)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantChannelListingStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantChannelListingStore) FilterbyOption(option *model.ProductVariantChannelListingFilterOption) ([]*model.ProductVariantChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantChannelListingStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantChannelListingStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantChannelListingStore) Get(variantChannelListingID string) (*model.ProductVariantChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantChannelListingStore.Get(variantChannelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantChannelListingStore) Save(variantChannelListing *model.ProductVariantChannelListing) (*model.ProductVariantChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantChannelListingStore.Save(variantChannelListing)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantChannelListingStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantTranslationStore) FilterByOption(option *model.ProductVariantTranslationFilterOption) ([]*model.ProductVariantTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantTranslationStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantTranslationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantTranslationStore) Get(translationID string) (*model.ProductVariantTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantTranslationStore.Get(translationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantTranslationStore) Upsert(translation *model.ProductVariantTranslation) (*model.ProductVariantTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantTranslationStore.Upsert(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantTranslationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Delete(roleID string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Delete(roleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Get(roleID string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Get(roleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetAll() (model.RoleSlice, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByName(ctx context.Context, name string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetByName(ctx, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByNames(names []string) (model.RoleSlice, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetByNames(names)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByNames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) PermanentDeleteAll() error {
	start := timemodule.Now()

	err := s.RoleStore.PermanentDeleteAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.PermanentDeleteAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerRoleStore) Upsert(role model.Role) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Upsert(role)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) AnalyticsSessionCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.AnalyticsSessionCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.AnalyticsSessionCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {
	start := timemodule.Now()

	s.SessionStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerSessionStore) Get(ctx context.Context, sessionIDOrToken string) (*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.Get(ctx, sessionIDOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessions(userID string) (model.SessionSlice, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessions(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) (model.SessionSlice, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsExpired", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsWithActiveDeviceIds(userID string) (model.SessionSlice, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessionsWithActiveDeviceIds(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsWithActiveDeviceIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) PermanentDeleteSessionsByUser(userID string) error {
	start := timemodule.Now()

	err := s.SessionStore.PermanentDeleteSessionsByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.PermanentDeleteSessionsByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Remove(sessionIDOrToken string) error {
	start := timemodule.Now()

	err := s.SessionStore.Remove(sessionIDOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Remove", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) RemoveAllSessions() error {
	start := timemodule.Now()

	err := s.SessionStore.RemoveAllSessions()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.RemoveAllSessions", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Save(session model.Session) (*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.Save(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateDeviceId(id string, deviceID string, expiresAt int64) (string, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.UpdateDeviceId(id, deviceID, expiresAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateDeviceId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateExpiredNotify(sessionid, notified)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiredNotify", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateExpiresAt(sessionID string, time int64) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateExpiresAt(sessionID, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiresAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateLastActivityAt(sessionID string, time int64) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateLastActivityAt(sessionID, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateProps(session model.Session) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateProps(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateProps", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateRoles(userID string, roles string) (string, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.UpdateRoles(userID, roles)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateRoles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) ApplicableShippingMethods(price *goprices.Money, channelID string, weight *measurement.Weight, countryCode model.CountryCode, productIDs []string) (model.ShippingMethodSlice, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.ApplicableShippingMethods(price, channelID, weight, countryCode, productIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.ApplicableShippingMethods", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.ShippingMethodStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerShippingMethodStore) FilterByOptions(options model.ShippingMethodFilterOption) (model.ShippingMethodSlice, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) Get(id string) (*model.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) GetbyOption(options model.ShippingMethodFilterOption) (*model.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.GetbyOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.GetbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) Upsert(tx boil.ContextTransactor, method model.ShippingMethod) (*model.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.Upsert(tx, method)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodChannelListingStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.ShippingMethodChannelListingStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodChannelListingStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerShippingMethodChannelListingStore) FilterByOption(option model.ShippingMethodChannelListingFilterOption) (model.ShippingMethodChannelListingSlice, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodChannelListingStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodChannelListingStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodChannelListingStore) Get(id string) (*model.ShippingMethodChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodChannelListingStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodChannelListingStore) Upsert(tx boil.ContextTransactor, listings model.ShippingMethodChannelListingSlice) (model.ShippingMethodChannelListingSlice, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodChannelListingStore.Upsert(tx, listings)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodChannelListingStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodPostalCodeRuleStore) Delete(tx boil.ContextTransactor, ids ...string) error {
	start := timemodule.Now()

	err := s.ShippingMethodPostalCodeRuleStore.Delete(tx, ids...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodPostalCodeRuleStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerShippingMethodPostalCodeRuleStore) FilterByOptions(options model.ShippingMethodPostalCodeRuleFilterOptions) (model.ShippingMethodPostalCodeRuleSlice, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodPostalCodeRuleStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodPostalCodeRuleStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodPostalCodeRuleStore) Save(tx boil.ContextTransactor, rules model.ShippingMethodPostalCodeRuleSlice) (model.ShippingMethodPostalCodeRuleSlice, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodPostalCodeRuleStore.Save(tx, rules)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodPostalCodeRuleStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) CountByOptions(options model_helper.ShippingZoneFilterOption) (int64, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.CountByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.CountByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) FilterByOption(option model_helper.ShippingZoneFilterOption) (model.ShippingZoneSlice, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) Get(id string) (*model.ShippingZone, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) Upsert(tx boil.ContextTransactor, shippingZone model.ShippingZone) (*model.ShippingZone, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.Upsert(tx, shippingZone)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) FilterByOptions(options model_helper.ShopStaffFilterOptions) (model.ShopStaffSlice, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) Get(shopStaffID string) (*model.ShopStaff, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.Get(shopStaffID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) GetByOptions(options model_helper.ShopStaffFilterOptions) (*model.ShopStaff, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) Upsert(shopStaff model.ShopStaff) (*model.ShopStaff, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.Upsert(shopStaff)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopTranslationStore) Get(id string) (*model.ShopTranslation, error) {
	start := timemodule.Now()

	result, err := s.ShopTranslationStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopTranslationStore) Upsert(translation model.ShopTranslation) (*model.ShopTranslation, error) {
	start := timemodule.Now()

	result, err := s.ShopTranslationStore.Upsert(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopTranslationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStaffNotificationRecipientStore) FilterByOptions(options ...qm.QueryMod) (model.StaffNotificationRecipientSlice, error) {
	start := timemodule.Now()

	result, err := s.StaffNotificationRecipientStore.FilterByOptions(options...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StaffNotificationRecipientStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStaffNotificationRecipientStore) Save(notificationRecipient model.StaffNotificationRecipient) (*model.StaffNotificationRecipient, error) {
	start := timemodule.Now()

	result, err := s.StaffNotificationRecipientStore.Save(notificationRecipient)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StaffNotificationRecipientStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) Get(userID string) (*model.Status, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.Get(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetByIds(userIds []string) (model.StatusSlice, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.GetByIds(userIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetTotalActiveUsersCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.GetTotalActiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetTotalActiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) ResetAll() error {
	start := timemodule.Now()

	err := s.StatusStore.ResetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.ResetAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) UpdateLastActivityAt(userID string, lastActivityAt int64) error {
	start := timemodule.Now()

	err := s.StatusStore.UpdateLastActivityAt(userID, lastActivityAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) Upsert(status model.Status) (*model.Status, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.Upsert(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) BulkUpsert(tx boil.ContextTransactor, stocks model.StockSlice) (model.StockSlice, error) {
	start := timemodule.Now()

	result, err := s.StockStore.BulkUpsert(tx, stocks)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) ChangeQuantity(stockID string, quantity int) error {
	start := timemodule.Now()

	err := s.StockStore.ChangeQuantity(stockID, quantity)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.ChangeQuantity", success, elapsed)
	}
	return err
}

func (s *TimerLayerStockStore) Delete(tx boil.ContextTransactor, options model.StockFilterOption) (int64, error) {
	start := timemodule.Now()

	result, err := s.StockStore.Delete(tx, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) FilterByOption(options model.StockFilterOption) (int64, model.StockSlice, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.StockStore.FilterByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterByOption", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerStockStore) FilterForChannel(options model.StockFilterForChannelOption) (squirrel.Sqlizer, model.StockSlice, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.StockStore.FilterForChannel(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterForChannel", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerStockStore) FilterForCountryAndChannel(options model.StockFilterOptionsForCountryAndChannel) (model.StockSlice, error) {
	start := timemodule.Now()

	result, err := s.StockStore.FilterForCountryAndChannel(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterForCountryAndChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) FilterProductStocksForCountryAndChannel(options model.StockFilterOptionsForCountryAndChannel) (model.StockSlice, error) {
	start := timemodule.Now()

	result, err := s.StockStore.FilterProductStocksForCountryAndChannel(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterProductStocksForCountryAndChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) FilterVariantStocksForCountry(options model.StockFilterOptionsForCountryAndChannel) (model.StockSlice, error) {
	start := timemodule.Now()

	result, err := s.StockStore.FilterVariantStocksForCountry(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterVariantStocksForCountry", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) Get(stockID string) (*model.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.Get(stockID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) Get() (map[string]string, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.Get()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) GetByName(name string) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) InsertIfExists(system model.System) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.InsertIfExists(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.InsertIfExists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) PermanentDeleteByName(name string) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.PermanentDeleteByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.PermanentDeleteByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) Save(system model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.Save(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdate(system model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.SaveOrUpdate(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdateWithWarnMetricHandling(system model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.SaveOrUpdateWithWarnMetricHandling(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdateWithWarnMetricHandling", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) Update(system model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.Update(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.Get(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.GetLatest(allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.GetLatest", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) Save(termsOfService model.TermsOfService) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.Save(termsOfService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) Cleanup() error {
	start := timemodule.Now()

	err := s.TokenStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Cleanup", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) Delete(token string) error {
	start := timemodule.Now()

	err := s.TokenStore.Delete(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) GetAllTokensByType(tokenType model_helper.TokenType) (model.TokenSlice, error) {
	start := timemodule.Now()

	result, err := s.TokenStore.GetAllTokensByType(tokenType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetAllTokensByType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) GetByToken(token string) (*model.Token, error) {
	start := timemodule.Now()

	result, err := s.TokenStore.GetByToken(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) Save(token model.Token) (*model.Token, error) {
	start := timemodule.Now()

	result, err := s.TokenStore.Save(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Delete(id string) error {
	start := timemodule.Now()

	err := s.UploadSessionStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) FindAll(options model_helper.UploadSessionFilterOption) (model.UploadSessionSlice, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.FindAll(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.FindAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Get(id string) (*model.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Upsert(session model.UploadSession) (*model.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.Upsert(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsActiveCount(time int64, options model_helper.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsActiveCount(time, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsActiveCountForPeriod(startTime int64, endTime int64, options model_helper.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsActiveCountForPeriod(startTime, endTime, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCountForPeriod", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetExternalUsers(hostDomain string) (bool, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetExternalUsers(hostDomain)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetExternalUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetGuestCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetGuestCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetGuestCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetInactiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetInactiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetSystemAdminCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetSystemAdminCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetSystemAdminCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ClearAllCustomRoleAssignments() error {
	start := timemodule.Now()

	err := s.UserStore.ClearAllCustomRoleAssignments()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ClearCaches() {
	start := timemodule.Now()

	s.UserStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerUserStore) Count(options model_helper.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Count(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Find(options model_helper.UserFilterOptions) (model.UserSlice, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Find(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Find", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Get(ctx context.Context, id string) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Get(ctx, id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllProfiles(options model_helper.UserGetOptions) (model.UserSlice, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetEtagForAllProfiles() string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForAllProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForAllProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetEtagForProfiles() string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetForLogin(loginID string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetForLogin(loginID, allowSignInWithUsername, allowSignInWithEmail)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetForLogin", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfileByIds(ctx context.Context, userIds []string, options store.UserGetByIdsOpts, allowFromCache bool) (model.UserSlice, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfileByIds(ctx, userIds, options, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfileByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetSystemAdminProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetSystemAdminProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model_helper.UserForIndexing, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUsersBatchForIndexing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InferSystemInstallDate() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.InferSystemInstallDate()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InferSystemInstallDate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InvalidateProfileCacheForUser(userID string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfileCacheForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfileCacheForUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) IsEmpty() (bool, error) {
	start := timemodule.Now()

	result, err := s.UserStore.IsEmpty()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.IsEmpty", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) PermanentDelete(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.PermanentDelete(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ResetAuthDataToEmailForUsers(service string, userIDs []string, includeDeleted bool, dryRun bool) (int, error) {
	start := timemodule.Now()

	result, err := s.UserStore.ResetAuthDataToEmailForUsers(service, userIDs, includeDeleted, dryRun)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetAuthDataToEmailForUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ResetLastPictureUpdate(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.ResetLastPictureUpdate(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) Save(user model.User) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Save(user)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Search(term string, options *model_helper.UserSearchOptions) (model.UserSlice, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Search(term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Update(user model.User, allowRoleUpdate bool) (*model_helper.UserUpdate, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Update(user, allowRoleUpdate)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateAuthData(userID string, service string, authData *string, email string, resetMfa bool) (string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.UpdateAuthData(userID, service, authData, email, resetMfa)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateFailedPasswordAttempts(userID string, attempts int) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateFailedPasswordAttempts(userID, attempts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateFailedPasswordAttempts", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateLastPictureUpdate(userID string, updateMillis int64) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateLastPictureUpdate(userID, updateMillis)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaActive(userID string, active bool) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateMfaActive(userID, active)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaActive", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaSecret(userID string, secret string) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateMfaSecret(userID, secret)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaSecret", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdatePassword(userID string, newPassword string) error {
	start := timemodule.Now()

	err := s.UserStore.UpdatePassword(userID, newPassword)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdatePassword", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateUpdateAt(userID string) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.UpdateUpdateAt(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateUpdateAt", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) VerifyEmail(userID string, email string) (string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.VerifyEmail(userID, email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.VerifyEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Delete(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.Delete(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) DeleteAllForUser(userID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.DeleteAllForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.DeleteAllForUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) Get(tokenID string) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Get(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetAll(conds ...qm.QueryMod) (model.UserAccessTokenSlice, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetAll(conds...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetByToken(tokenString)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Save(token model.UserAccessToken) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Save(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Search(term string) (model.UserAccessTokenSlice, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Search(term)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenDisable(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.UpdateTokenDisable(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenDisable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenEnable(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.UpdateTokenEnable(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenEnable", success, elapsed)
	}
	return err
}

func (s *TimerLayerVatStore) FilterByOptions(options ...qm.QueryMod) (model.VatSlice, error) {
	start := timemodule.Now()

	result, err := s.VatStore.FilterByOptions(options...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VatStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVatStore) Upsert(tx boil.ContextTransactor, vats model.VatSlice) (model.VatSlice, error) {
	start := timemodule.Now()

	result, err := s.VatStore.Upsert(tx, vats)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VatStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.VoucherChannelListingStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerVoucherChannelListingStore) FilterbyOption(option model_helper.VoucherChannelListingFilterOption) (model.VoucherChannelListingSlice, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) Get(voucherChannelListingID string) (*model.VoucherChannelListing, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.Get(voucherChannelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) Upsert(tx boil.ContextTransactor, voucherChannelListings model.VoucherChannelListingSlice) (model.VoucherChannelListingSlice, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.Upsert(tx, voucherChannelListings)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) Delete(ids []string) error {
	start := timemodule.Now()

	err := s.VoucherCustomerStore.Delete(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerVoucherCustomerStore) FilterByOptions(options model_helper.VoucherCustomerFilterOption) (model.VoucherCustomerSlice, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) GetByOption(options model_helper.VoucherCustomerFilterOption) (*model.VoucherCustomer, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.GetByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) Save(voucherCustomer model.VoucherCustomer) (*model.VoucherCustomer, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.Save(voucherCustomer)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherTranslationStore) FilterByOption(option model_helper.VoucherTranslationFilterOption) (model.VoucherTranslationSlice, error) {
	start := timemodule.Now()

	result, err := s.VoucherTranslationStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherTranslationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherTranslationStore) Get(id string) (*model.VoucherTranslation, error) {
	start := timemodule.Now()

	result, err := s.VoucherTranslationStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherTranslationStore) GetByOption(option model_helper.VoucherTranslationFilterOption) (*model.VoucherTranslation, error) {
	start := timemodule.Now()

	result, err := s.VoucherTranslationStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherTranslationStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherTranslationStore) Upsert(translation model.VoucherTranslation) (*model.VoucherTranslation, error) {
	start := timemodule.Now()

	result, err := s.VoucherTranslationStore.Upsert(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherTranslationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) ApplicableForClickAndCollectCheckoutLines(checkoutLines model.CheckoutLineSlice, country model.CountryCode) (model.WarehouseSlice, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.ApplicableForClickAndCollectCheckoutLines(checkoutLines, country)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.ApplicableForClickAndCollectCheckoutLines", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) ApplicableForClickAndCollectNoQuantityCheck(checkoutLines model.CheckoutLineSlice, country model.CountryCode) (model.WarehouseSlice, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.ApplicableForClickAndCollectNoQuantityCheck(checkoutLines, country)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.ApplicableForClickAndCollectNoQuantityCheck", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) ApplicableForClickAndCollectOrderLines(orderLines model.OrderLineSlice, country model.CountryCode) (model.WarehouseSlice, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.ApplicableForClickAndCollectOrderLines(orderLines, country)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.ApplicableForClickAndCollectOrderLines", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) Delete(tx boil.ContextTransactor, ids []string) error {
	start := timemodule.Now()

	err := s.WarehouseStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerWarehouseStore) FilterByOprion(option model_helper.WarehouseFilterOption) (model.WarehouseSlice, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.FilterByOprion(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.FilterByOprion", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) GetByOption(option model_helper.WarehouseFilterOption) (*model.Warehouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) Upsert(model model.Warehouse) (*model.Warehouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.Upsert(model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) WarehouseByStockID(stockID string) (*model.Warehouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.WarehouseByStockID(stockID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.WarehouseByStockID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) WarehouseShipingZonesByCountryCodeAndChannelID(countryCode string, channelID string) (model.WarehouseShippingZoneSlice, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.WarehouseShipingZonesByCountryCodeAndChannelID(countryCode, channelID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.WarehouseShipingZonesByCountryCodeAndChannelID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistStore) GetByOption(option model_helper.WishlistFilterOption) (*model.Wishlist, error) {
	start := timemodule.Now()

	result, err := s.WishlistStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistStore) Upsert(wishList model.Wishlist) (*model.Wishlist, error) {
	start := timemodule.Now()

	result, err := s.WishlistStore.Upsert(wishList)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) BulkUpsert(tx boil.ContextTransactor, wishlistItems model.WishlistItemSlice) (model.WishlistItemSlice, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.BulkUpsert(tx, wishlistItems)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) Delete(tx boil.ContextTransactor, ids []string) (int64, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.Delete(tx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) FilterByOption(option model_helper.WishlistItemFilterOption) (model.WishlistItemSlice, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) GetById(id string) (*model.WishlistItem, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) GetByOption(option model_helper.WishlistItemFilterOption) (*model.WishlistItem, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayer) Close() {
	s.Store.Close()
}

func (s *TimerLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *TimerLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *TimerLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *TimerLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *TimerLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func New(childStore store.Store, metrics einterfaces.MetricsInterface) *TimerLayer {
	newStore := TimerLayer{
		Store:   childStore,
		Metrics: metrics,
	}

	newStore.AddressStore = &TimerLayerAddressStore{AddressStore: childStore.Address(), Root: &newStore}
	newStore.AllocationStore = &TimerLayerAllocationStore{AllocationStore: childStore.Allocation(), Root: &newStore}
	newStore.AppStore = &TimerLayerAppStore{AppStore: childStore.App(), Root: &newStore}
	newStore.AppTokenStore = &TimerLayerAppTokenStore{AppTokenStore: childStore.AppToken(), Root: &newStore}
	newStore.AssignedPageAttributeStore = &TimerLayerAssignedPageAttributeStore{AssignedPageAttributeStore: childStore.AssignedPageAttribute(), Root: &newStore}
	newStore.AssignedPageAttributeValueStore = &TimerLayerAssignedPageAttributeValueStore{AssignedPageAttributeValueStore: childStore.AssignedPageAttributeValue(), Root: &newStore}
	newStore.AssignedProductAttributeStore = &TimerLayerAssignedProductAttributeStore{AssignedProductAttributeStore: childStore.AssignedProductAttribute(), Root: &newStore}
	newStore.AssignedProductAttributeValueStore = &TimerLayerAssignedProductAttributeValueStore{AssignedProductAttributeValueStore: childStore.AssignedProductAttributeValue(), Root: &newStore}
	newStore.AttributeStore = &TimerLayerAttributeStore{AttributeStore: childStore.Attribute(), Root: &newStore}
	newStore.AttributePageStore = &TimerLayerAttributePageStore{AttributePageStore: childStore.AttributePage(), Root: &newStore}
	newStore.AttributeTranslationStore = &TimerLayerAttributeTranslationStore{AttributeTranslationStore: childStore.AttributeTranslation(), Root: &newStore}
	newStore.AttributeValueStore = &TimerLayerAttributeValueStore{AttributeValueStore: childStore.AttributeValue(), Root: &newStore}
	newStore.AttributeValueTranslationStore = &TimerLayerAttributeValueTranslationStore{AttributeValueTranslationStore: childStore.AttributeValueTranslation(), Root: &newStore}
	newStore.AuditStore = &TimerLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.CategoryStore = &TimerLayerCategoryStore{CategoryStore: childStore.Category(), Root: &newStore}
	newStore.CategoryTranslationStore = &TimerLayerCategoryTranslationStore{CategoryTranslationStore: childStore.CategoryTranslation(), Root: &newStore}
	newStore.ChannelStore = &TimerLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.CheckoutStore = &TimerLayerCheckoutStore{CheckoutStore: childStore.Checkout(), Root: &newStore}
	newStore.CheckoutLineStore = &TimerLayerCheckoutLineStore{CheckoutLineStore: childStore.CheckoutLine(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &TimerLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CollectionStore = &TimerLayerCollectionStore{CollectionStore: childStore.Collection(), Root: &newStore}
	newStore.CollectionChannelListingStore = &TimerLayerCollectionChannelListingStore{CollectionChannelListingStore: childStore.CollectionChannelListing(), Root: &newStore}
	newStore.CollectionProductStore = &TimerLayerCollectionProductStore{CollectionProductStore: childStore.CollectionProduct(), Root: &newStore}
	newStore.CollectionTranslationStore = &TimerLayerCollectionTranslationStore{CollectionTranslationStore: childStore.CollectionTranslation(), Root: &newStore}
	newStore.ComplianceStore = &TimerLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.CsvExportEventStore = &TimerLayerCsvExportEventStore{CsvExportEventStore: childStore.CsvExportEvent(), Root: &newStore}
	newStore.CsvExportFileStore = &TimerLayerCsvExportFileStore{CsvExportFileStore: childStore.CsvExportFile(), Root: &newStore}
	newStore.CustomProductAttributeStore = &TimerLayerCustomProductAttributeStore{CustomProductAttributeStore: childStore.CustomProductAttribute(), Root: &newStore}
	newStore.CustomerEventStore = &TimerLayerCustomerEventStore{CustomerEventStore: childStore.CustomerEvent(), Root: &newStore}
	newStore.CustomerNoteStore = &TimerLayerCustomerNoteStore{CustomerNoteStore: childStore.CustomerNote(), Root: &newStore}
	newStore.DigitalContentStore = &TimerLayerDigitalContentStore{DigitalContentStore: childStore.DigitalContent(), Root: &newStore}
	newStore.DigitalContentUrlStore = &TimerLayerDigitalContentUrlStore{DigitalContentUrlStore: childStore.DigitalContentUrl(), Root: &newStore}
	newStore.DiscountSaleStore = &TimerLayerDiscountSaleStore{DiscountSaleStore: childStore.DiscountSale(), Root: &newStore}
	newStore.DiscountSaleChannelListingStore = &TimerLayerDiscountSaleChannelListingStore{DiscountSaleChannelListingStore: childStore.DiscountSaleChannelListing(), Root: &newStore}
	newStore.DiscountSaleTranslationStore = &TimerLayerDiscountSaleTranslationStore{DiscountSaleTranslationStore: childStore.DiscountSaleTranslation(), Root: &newStore}
	newStore.DiscountVoucherStore = &TimerLayerDiscountVoucherStore{DiscountVoucherStore: childStore.DiscountVoucher(), Root: &newStore}
	newStore.FileInfoStore = &TimerLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.FulfillmentStore = &TimerLayerFulfillmentStore{FulfillmentStore: childStore.Fulfillment(), Root: &newStore}
	newStore.FulfillmentLineStore = &TimerLayerFulfillmentLineStore{FulfillmentLineStore: childStore.FulfillmentLine(), Root: &newStore}
	newStore.GiftCardStore = &TimerLayerGiftCardStore{GiftCardStore: childStore.GiftCard(), Root: &newStore}
	newStore.GiftcardEventStore = &TimerLayerGiftcardEventStore{GiftcardEventStore: childStore.GiftcardEvent(), Root: &newStore}
	newStore.InvoiceStore = &TimerLayerInvoiceStore{InvoiceStore: childStore.Invoice(), Root: &newStore}
	newStore.InvoiceEventStore = &TimerLayerInvoiceEventStore{InvoiceEventStore: childStore.InvoiceEvent(), Root: &newStore}
	newStore.JobStore = &TimerLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.MenuStore = &TimerLayerMenuStore{MenuStore: childStore.Menu(), Root: &newStore}
	newStore.MenuItemStore = &TimerLayerMenuItemStore{MenuItemStore: childStore.MenuItem(), Root: &newStore}
	newStore.MenuItemTranslationStore = &TimerLayerMenuItemTranslationStore{MenuItemTranslationStore: childStore.MenuItemTranslation(), Root: &newStore}
	newStore.OpenExchangeRateStore = &TimerLayerOpenExchangeRateStore{OpenExchangeRateStore: childStore.OpenExchangeRate(), Root: &newStore}
	newStore.OrderStore = &TimerLayerOrderStore{OrderStore: childStore.Order(), Root: &newStore}
	newStore.OrderDiscountStore = &TimerLayerOrderDiscountStore{OrderDiscountStore: childStore.OrderDiscount(), Root: &newStore}
	newStore.OrderEventStore = &TimerLayerOrderEventStore{OrderEventStore: childStore.OrderEvent(), Root: &newStore}
	newStore.OrderLineStore = &TimerLayerOrderLineStore{OrderLineStore: childStore.OrderLine(), Root: &newStore}
	newStore.PageStore = &TimerLayerPageStore{PageStore: childStore.Page(), Root: &newStore}
	newStore.PageTranslationStore = &TimerLayerPageTranslationStore{PageTranslationStore: childStore.PageTranslation(), Root: &newStore}
	newStore.PageTypeStore = &TimerLayerPageTypeStore{PageTypeStore: childStore.PageType(), Root: &newStore}
	newStore.PaymentStore = &TimerLayerPaymentStore{PaymentStore: childStore.Payment(), Root: &newStore}
	newStore.PaymentTransactionStore = &TimerLayerPaymentTransactionStore{PaymentTransactionStore: childStore.PaymentTransaction(), Root: &newStore}
	newStore.PluginStore = &TimerLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PluginConfigurationStore = &TimerLayerPluginConfigurationStore{PluginConfigurationStore: childStore.PluginConfiguration(), Root: &newStore}
	newStore.PreferenceStore = &TimerLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.PreorderAllocationStore = &TimerLayerPreorderAllocationStore{PreorderAllocationStore: childStore.PreorderAllocation(), Root: &newStore}
	newStore.ProductStore = &TimerLayerProductStore{ProductStore: childStore.Product(), Root: &newStore}
	newStore.ProductChannelListingStore = &TimerLayerProductChannelListingStore{ProductChannelListingStore: childStore.ProductChannelListing(), Root: &newStore}
	newStore.ProductMediaStore = &TimerLayerProductMediaStore{ProductMediaStore: childStore.ProductMedia(), Root: &newStore}
	newStore.ProductTranslationStore = &TimerLayerProductTranslationStore{ProductTranslationStore: childStore.ProductTranslation(), Root: &newStore}
	newStore.ProductTypeStore = &TimerLayerProductTypeStore{ProductTypeStore: childStore.ProductType(), Root: &newStore}
	newStore.ProductVariantStore = &TimerLayerProductVariantStore{ProductVariantStore: childStore.ProductVariant(), Root: &newStore}
	newStore.ProductVariantChannelListingStore = &TimerLayerProductVariantChannelListingStore{ProductVariantChannelListingStore: childStore.ProductVariantChannelListing(), Root: &newStore}
	newStore.ProductVariantTranslationStore = &TimerLayerProductVariantTranslationStore{ProductVariantTranslationStore: childStore.ProductVariantTranslation(), Root: &newStore}
	newStore.RoleStore = &TimerLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SessionStore = &TimerLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.ShippingMethodStore = &TimerLayerShippingMethodStore{ShippingMethodStore: childStore.ShippingMethod(), Root: &newStore}
	newStore.ShippingMethodChannelListingStore = &TimerLayerShippingMethodChannelListingStore{ShippingMethodChannelListingStore: childStore.ShippingMethodChannelListing(), Root: &newStore}
	newStore.ShippingMethodPostalCodeRuleStore = &TimerLayerShippingMethodPostalCodeRuleStore{ShippingMethodPostalCodeRuleStore: childStore.ShippingMethodPostalCodeRule(), Root: &newStore}
	newStore.ShippingMethodTranslationStore = &TimerLayerShippingMethodTranslationStore{ShippingMethodTranslationStore: childStore.ShippingMethodTranslation(), Root: &newStore}
	newStore.ShippingZoneStore = &TimerLayerShippingZoneStore{ShippingZoneStore: childStore.ShippingZone(), Root: &newStore}
	newStore.ShopStaffStore = &TimerLayerShopStaffStore{ShopStaffStore: childStore.ShopStaff(), Root: &newStore}
	newStore.ShopTranslationStore = &TimerLayerShopTranslationStore{ShopTranslationStore: childStore.ShopTranslation(), Root: &newStore}
	newStore.StaffNotificationRecipientStore = &TimerLayerStaffNotificationRecipientStore{StaffNotificationRecipientStore: childStore.StaffNotificationRecipient(), Root: &newStore}
	newStore.StatusStore = &TimerLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.StockStore = &TimerLayerStockStore{StockStore: childStore.Stock(), Root: &newStore}
	newStore.SystemStore = &TimerLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TermsOfServiceStore = &TimerLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &TimerLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UploadSessionStore = &TimerLayerUploadSessionStore{UploadSessionStore: childStore.UploadSession(), Root: &newStore}
	newStore.UserStore = &TimerLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &TimerLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.VatStore = &TimerLayerVatStore{VatStore: childStore.Vat(), Root: &newStore}
	newStore.VoucherChannelListingStore = &TimerLayerVoucherChannelListingStore{VoucherChannelListingStore: childStore.VoucherChannelListing(), Root: &newStore}
	newStore.VoucherCustomerStore = &TimerLayerVoucherCustomerStore{VoucherCustomerStore: childStore.VoucherCustomer(), Root: &newStore}
	newStore.VoucherTranslationStore = &TimerLayerVoucherTranslationStore{VoucherTranslationStore: childStore.VoucherTranslation(), Root: &newStore}
	newStore.WarehouseStore = &TimerLayerWarehouseStore{WarehouseStore: childStore.Warehouse(), Root: &newStore}
	newStore.WishlistStore = &TimerLayerWishlistStore{WishlistStore: childStore.Wishlist(), Root: &newStore}
	newStore.WishlistItemStore = &TimerLayerWishlistItemStore{WishlistItemStore: childStore.WishlistItem(), Root: &newStore}
	return &newStore
}
