// Code generated by "make store-layers"
// DO NOT EDIT

package timerlayer

import (
	"context"
	timemodule "time"

	"github.com/Masterminds/squirrel"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/einterfaces"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/modules/measurement"
	"github.com/sitename/sitename/store"
	"github.com/sitename/sitename/store/store_iface"
)

type TimerLayer struct {
	store.Store
	Metrics                            einterfaces.MetricsInterface
	AddressStore                       store.AddressStore
	AllocationStore                    store.AllocationStore
	AppStore                           store.AppStore
	AppTokenStore                      store.AppTokenStore
	AssignedPageAttributeStore         store.AssignedPageAttributeStore
	AssignedPageAttributeValueStore    store.AssignedPageAttributeValueStore
	AssignedProductAttributeStore      store.AssignedProductAttributeStore
	AssignedProductAttributeValueStore store.AssignedProductAttributeValueStore
	AssignedVariantAttributeStore      store.AssignedVariantAttributeStore
	AssignedVariantAttributeValueStore store.AssignedVariantAttributeValueStore
	AttributeStore                     store.AttributeStore
	AttributePageStore                 store.AttributePageStore
	AttributeProductStore              store.AttributeProductStore
	AttributeTranslationStore          store.AttributeTranslationStore
	AttributeValueStore                store.AttributeValueStore
	AttributeValueTranslationStore     store.AttributeValueTranslationStore
	AttributeVariantStore              store.AttributeVariantStore
	AuditStore                         store.AuditStore
	CategoryStore                      store.CategoryStore
	CategoryTranslationStore           store.CategoryTranslationStore
	ChannelStore                       store.ChannelStore
	CheckoutStore                      store.CheckoutStore
	CheckoutLineStore                  store.CheckoutLineStore
	ClusterDiscoveryStore              store.ClusterDiscoveryStore
	CollectionStore                    store.CollectionStore
	CollectionChannelListingStore      store.CollectionChannelListingStore
	CollectionProductStore             store.CollectionProductStore
	CollectionTranslationStore         store.CollectionTranslationStore
	ComplianceStore                    store.ComplianceStore
	CsvExportEventStore                store.CsvExportEventStore
	CsvExportFileStore                 store.CsvExportFileStore
	CustomerEventStore                 store.CustomerEventStore
	CustomerNoteStore                  store.CustomerNoteStore
	DigitalContentStore                store.DigitalContentStore
	DigitalContentUrlStore             store.DigitalContentUrlStore
	DiscountSaleStore                  store.DiscountSaleStore
	DiscountSaleChannelListingStore    store.DiscountSaleChannelListingStore
	DiscountSaleTranslationStore       store.DiscountSaleTranslationStore
	DiscountVoucherStore               store.DiscountVoucherStore
	FileInfoStore                      store.FileInfoStore
	FulfillmentStore                   store.FulfillmentStore
	FulfillmentLineStore               store.FulfillmentLineStore
	GiftCardStore                      store.GiftCardStore
	GiftCardCheckoutStore              store.GiftCardCheckoutStore
	GiftCardOrderStore                 store.GiftCardOrderStore
	GiftcardEventStore                 store.GiftcardEventStore
	InvoiceStore                       store.InvoiceStore
	InvoiceEventStore                  store.InvoiceEventStore
	JobStore                           store.JobStore
	MenuStore                          store.MenuStore
	MenuItemStore                      store.MenuItemStore
	MenuItemTranslationStore           store.MenuItemTranslationStore
	OpenExchangeRateStore              store.OpenExchangeRateStore
	OrderStore                         store.OrderStore
	OrderDiscountStore                 store.OrderDiscountStore
	OrderEventStore                    store.OrderEventStore
	OrderLineStore                     store.OrderLineStore
	PageStore                          store.PageStore
	PageTranslationStore               store.PageTranslationStore
	PageTypeStore                      store.PageTypeStore
	PaymentStore                       store.PaymentStore
	PaymentTransactionStore            store.PaymentTransactionStore
	PluginStore                        store.PluginStore
	PluginConfigurationStore           store.PluginConfigurationStore
	PreferenceStore                    store.PreferenceStore
	PreorderAllocationStore            store.PreorderAllocationStore
	ProductStore                       store.ProductStore
	ProductChannelListingStore         store.ProductChannelListingStore
	ProductMediaStore                  store.ProductMediaStore
	ProductTranslationStore            store.ProductTranslationStore
	ProductTypeStore                   store.ProductTypeStore
	ProductVariantStore                store.ProductVariantStore
	ProductVariantChannelListingStore  store.ProductVariantChannelListingStore
	ProductVariantTranslationStore     store.ProductVariantTranslationStore
	RoleStore                          store.RoleStore
	SaleCategoryRelationStore          store.SaleCategoryRelationStore
	SaleCollectionRelationStore        store.SaleCollectionRelationStore
	SaleProductRelationStore           store.SaleProductRelationStore
	SaleProductVariantStore            store.SaleProductVariantStore
	SessionStore                       store.SessionStore
	ShippingMethodStore                store.ShippingMethodStore
	ShippingMethodChannelListingStore  store.ShippingMethodChannelListingStore
	ShippingMethodExcludedProductStore store.ShippingMethodExcludedProductStore
	ShippingMethodPostalCodeRuleStore  store.ShippingMethodPostalCodeRuleStore
	ShippingMethodTranslationStore     store.ShippingMethodTranslationStore
	ShippingZoneStore                  store.ShippingZoneStore
	ShippingZoneChannelStore           store.ShippingZoneChannelStore
	ShopStore                          store.ShopStore
	ShopStaffStore                     store.ShopStaffStore
	ShopTranslationStore               store.ShopTranslationStore
	StaffNotificationRecipientStore    store.StaffNotificationRecipientStore
	StatusStore                        store.StatusStore
	StockStore                         store.StockStore
	SystemStore                        store.SystemStore
	TermsOfServiceStore                store.TermsOfServiceStore
	TokenStore                         store.TokenStore
	UploadSessionStore                 store.UploadSessionStore
	UserStore                          store.UserStore
	UserAccessTokenStore               store.UserAccessTokenStore
	UserAddressStore                   store.UserAddressStore
	VariantMediaStore                  store.VariantMediaStore
	VoucherCategoryStore               store.VoucherCategoryStore
	VoucherChannelListingStore         store.VoucherChannelListingStore
	VoucherCollectionStore             store.VoucherCollectionStore
	VoucherCustomerStore               store.VoucherCustomerStore
	VoucherProductStore                store.VoucherProductStore
	VoucherProductVariantStore         store.VoucherProductVariantStore
	VoucherTranslationStore            store.VoucherTranslationStore
	WarehouseStore                     store.WarehouseStore
	WarehouseShippingZoneStore         store.WarehouseShippingZoneStore
	WishlistStore                      store.WishlistStore
	WishlistItemStore                  store.WishlistItemStore
	WishlistItemProductVariantStore    store.WishlistItemProductVariantStore
}

func (s *TimerLayer) Address() store.AddressStore {
	return s.AddressStore
}

func (s *TimerLayer) Allocation() store.AllocationStore {
	return s.AllocationStore
}

func (s *TimerLayer) App() store.AppStore {
	return s.AppStore
}

func (s *TimerLayer) AppToken() store.AppTokenStore {
	return s.AppTokenStore
}

func (s *TimerLayer) AssignedPageAttribute() store.AssignedPageAttributeStore {
	return s.AssignedPageAttributeStore
}

func (s *TimerLayer) AssignedPageAttributeValue() store.AssignedPageAttributeValueStore {
	return s.AssignedPageAttributeValueStore
}

func (s *TimerLayer) AssignedProductAttribute() store.AssignedProductAttributeStore {
	return s.AssignedProductAttributeStore
}

func (s *TimerLayer) AssignedProductAttributeValue() store.AssignedProductAttributeValueStore {
	return s.AssignedProductAttributeValueStore
}

func (s *TimerLayer) AssignedVariantAttribute() store.AssignedVariantAttributeStore {
	return s.AssignedVariantAttributeStore
}

func (s *TimerLayer) AssignedVariantAttributeValue() store.AssignedVariantAttributeValueStore {
	return s.AssignedVariantAttributeValueStore
}

func (s *TimerLayer) Attribute() store.AttributeStore {
	return s.AttributeStore
}

func (s *TimerLayer) AttributePage() store.AttributePageStore {
	return s.AttributePageStore
}

func (s *TimerLayer) AttributeProduct() store.AttributeProductStore {
	return s.AttributeProductStore
}

func (s *TimerLayer) AttributeTranslation() store.AttributeTranslationStore {
	return s.AttributeTranslationStore
}

func (s *TimerLayer) AttributeValue() store.AttributeValueStore {
	return s.AttributeValueStore
}

func (s *TimerLayer) AttributeValueTranslation() store.AttributeValueTranslationStore {
	return s.AttributeValueTranslationStore
}

func (s *TimerLayer) AttributeVariant() store.AttributeVariantStore {
	return s.AttributeVariantStore
}

func (s *TimerLayer) Audit() store.AuditStore {
	return s.AuditStore
}

func (s *TimerLayer) Category() store.CategoryStore {
	return s.CategoryStore
}

func (s *TimerLayer) CategoryTranslation() store.CategoryTranslationStore {
	return s.CategoryTranslationStore
}

func (s *TimerLayer) Channel() store.ChannelStore {
	return s.ChannelStore
}

func (s *TimerLayer) Checkout() store.CheckoutStore {
	return s.CheckoutStore
}

func (s *TimerLayer) CheckoutLine() store.CheckoutLineStore {
	return s.CheckoutLineStore
}

func (s *TimerLayer) ClusterDiscovery() store.ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *TimerLayer) Collection() store.CollectionStore {
	return s.CollectionStore
}

func (s *TimerLayer) CollectionChannelListing() store.CollectionChannelListingStore {
	return s.CollectionChannelListingStore
}

func (s *TimerLayer) CollectionProduct() store.CollectionProductStore {
	return s.CollectionProductStore
}

func (s *TimerLayer) CollectionTranslation() store.CollectionTranslationStore {
	return s.CollectionTranslationStore
}

func (s *TimerLayer) Compliance() store.ComplianceStore {
	return s.ComplianceStore
}

func (s *TimerLayer) CsvExportEvent() store.CsvExportEventStore {
	return s.CsvExportEventStore
}

func (s *TimerLayer) CsvExportFile() store.CsvExportFileStore {
	return s.CsvExportFileStore
}

func (s *TimerLayer) CustomerEvent() store.CustomerEventStore {
	return s.CustomerEventStore
}

func (s *TimerLayer) CustomerNote() store.CustomerNoteStore {
	return s.CustomerNoteStore
}

func (s *TimerLayer) DigitalContent() store.DigitalContentStore {
	return s.DigitalContentStore
}

func (s *TimerLayer) DigitalContentUrl() store.DigitalContentUrlStore {
	return s.DigitalContentUrlStore
}

func (s *TimerLayer) DiscountSale() store.DiscountSaleStore {
	return s.DiscountSaleStore
}

func (s *TimerLayer) DiscountSaleChannelListing() store.DiscountSaleChannelListingStore {
	return s.DiscountSaleChannelListingStore
}

func (s *TimerLayer) DiscountSaleTranslation() store.DiscountSaleTranslationStore {
	return s.DiscountSaleTranslationStore
}

func (s *TimerLayer) DiscountVoucher() store.DiscountVoucherStore {
	return s.DiscountVoucherStore
}

func (s *TimerLayer) FileInfo() store.FileInfoStore {
	return s.FileInfoStore
}

func (s *TimerLayer) Fulfillment() store.FulfillmentStore {
	return s.FulfillmentStore
}

func (s *TimerLayer) FulfillmentLine() store.FulfillmentLineStore {
	return s.FulfillmentLineStore
}

func (s *TimerLayer) GiftCard() store.GiftCardStore {
	return s.GiftCardStore
}

func (s *TimerLayer) GiftCardCheckout() store.GiftCardCheckoutStore {
	return s.GiftCardCheckoutStore
}

func (s *TimerLayer) GiftCardOrder() store.GiftCardOrderStore {
	return s.GiftCardOrderStore
}

func (s *TimerLayer) GiftcardEvent() store.GiftcardEventStore {
	return s.GiftcardEventStore
}

func (s *TimerLayer) Invoice() store.InvoiceStore {
	return s.InvoiceStore
}

func (s *TimerLayer) InvoiceEvent() store.InvoiceEventStore {
	return s.InvoiceEventStore
}

func (s *TimerLayer) Job() store.JobStore {
	return s.JobStore
}

func (s *TimerLayer) Menu() store.MenuStore {
	return s.MenuStore
}

func (s *TimerLayer) MenuItem() store.MenuItemStore {
	return s.MenuItemStore
}

func (s *TimerLayer) MenuItemTranslation() store.MenuItemTranslationStore {
	return s.MenuItemTranslationStore
}

func (s *TimerLayer) OpenExchangeRate() store.OpenExchangeRateStore {
	return s.OpenExchangeRateStore
}

func (s *TimerLayer) Order() store.OrderStore {
	return s.OrderStore
}

func (s *TimerLayer) OrderDiscount() store.OrderDiscountStore {
	return s.OrderDiscountStore
}

func (s *TimerLayer) OrderEvent() store.OrderEventStore {
	return s.OrderEventStore
}

func (s *TimerLayer) OrderLine() store.OrderLineStore {
	return s.OrderLineStore
}

func (s *TimerLayer) Page() store.PageStore {
	return s.PageStore
}

func (s *TimerLayer) PageTranslation() store.PageTranslationStore {
	return s.PageTranslationStore
}

func (s *TimerLayer) PageType() store.PageTypeStore {
	return s.PageTypeStore
}

func (s *TimerLayer) Payment() store.PaymentStore {
	return s.PaymentStore
}

func (s *TimerLayer) PaymentTransaction() store.PaymentTransactionStore {
	return s.PaymentTransactionStore
}

func (s *TimerLayer) Plugin() store.PluginStore {
	return s.PluginStore
}

func (s *TimerLayer) PluginConfiguration() store.PluginConfigurationStore {
	return s.PluginConfigurationStore
}

func (s *TimerLayer) Preference() store.PreferenceStore {
	return s.PreferenceStore
}

func (s *TimerLayer) PreorderAllocation() store.PreorderAllocationStore {
	return s.PreorderAllocationStore
}

func (s *TimerLayer) Product() store.ProductStore {
	return s.ProductStore
}

func (s *TimerLayer) ProductChannelListing() store.ProductChannelListingStore {
	return s.ProductChannelListingStore
}

func (s *TimerLayer) ProductMedia() store.ProductMediaStore {
	return s.ProductMediaStore
}

func (s *TimerLayer) ProductTranslation() store.ProductTranslationStore {
	return s.ProductTranslationStore
}

func (s *TimerLayer) ProductType() store.ProductTypeStore {
	return s.ProductTypeStore
}

func (s *TimerLayer) ProductVariant() store.ProductVariantStore {
	return s.ProductVariantStore
}

func (s *TimerLayer) ProductVariantChannelListing() store.ProductVariantChannelListingStore {
	return s.ProductVariantChannelListingStore
}

func (s *TimerLayer) ProductVariantTranslation() store.ProductVariantTranslationStore {
	return s.ProductVariantTranslationStore
}

func (s *TimerLayer) Role() store.RoleStore {
	return s.RoleStore
}

func (s *TimerLayer) SaleCategoryRelation() store.SaleCategoryRelationStore {
	return s.SaleCategoryRelationStore
}

func (s *TimerLayer) SaleCollectionRelation() store.SaleCollectionRelationStore {
	return s.SaleCollectionRelationStore
}

func (s *TimerLayer) SaleProductRelation() store.SaleProductRelationStore {
	return s.SaleProductRelationStore
}

func (s *TimerLayer) SaleProductVariant() store.SaleProductVariantStore {
	return s.SaleProductVariantStore
}

func (s *TimerLayer) Session() store.SessionStore {
	return s.SessionStore
}

func (s *TimerLayer) ShippingMethod() store.ShippingMethodStore {
	return s.ShippingMethodStore
}

func (s *TimerLayer) ShippingMethodChannelListing() store.ShippingMethodChannelListingStore {
	return s.ShippingMethodChannelListingStore
}

func (s *TimerLayer) ShippingMethodExcludedProduct() store.ShippingMethodExcludedProductStore {
	return s.ShippingMethodExcludedProductStore
}

func (s *TimerLayer) ShippingMethodPostalCodeRule() store.ShippingMethodPostalCodeRuleStore {
	return s.ShippingMethodPostalCodeRuleStore
}

func (s *TimerLayer) ShippingMethodTranslation() store.ShippingMethodTranslationStore {
	return s.ShippingMethodTranslationStore
}

func (s *TimerLayer) ShippingZone() store.ShippingZoneStore {
	return s.ShippingZoneStore
}

func (s *TimerLayer) ShippingZoneChannel() store.ShippingZoneChannelStore {
	return s.ShippingZoneChannelStore
}

func (s *TimerLayer) Shop() store.ShopStore {
	return s.ShopStore
}

func (s *TimerLayer) ShopStaff() store.ShopStaffStore {
	return s.ShopStaffStore
}

func (s *TimerLayer) ShopTranslation() store.ShopTranslationStore {
	return s.ShopTranslationStore
}

func (s *TimerLayer) StaffNotificationRecipient() store.StaffNotificationRecipientStore {
	return s.StaffNotificationRecipientStore
}

func (s *TimerLayer) Status() store.StatusStore {
	return s.StatusStore
}

func (s *TimerLayer) Stock() store.StockStore {
	return s.StockStore
}

func (s *TimerLayer) System() store.SystemStore {
	return s.SystemStore
}

func (s *TimerLayer) TermsOfService() store.TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *TimerLayer) Token() store.TokenStore {
	return s.TokenStore
}

func (s *TimerLayer) UploadSession() store.UploadSessionStore {
	return s.UploadSessionStore
}

func (s *TimerLayer) User() store.UserStore {
	return s.UserStore
}

func (s *TimerLayer) UserAccessToken() store.UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *TimerLayer) UserAddress() store.UserAddressStore {
	return s.UserAddressStore
}

func (s *TimerLayer) VariantMedia() store.VariantMediaStore {
	return s.VariantMediaStore
}

func (s *TimerLayer) VoucherCategory() store.VoucherCategoryStore {
	return s.VoucherCategoryStore
}

func (s *TimerLayer) VoucherChannelListing() store.VoucherChannelListingStore {
	return s.VoucherChannelListingStore
}

func (s *TimerLayer) VoucherCollection() store.VoucherCollectionStore {
	return s.VoucherCollectionStore
}

func (s *TimerLayer) VoucherCustomer() store.VoucherCustomerStore {
	return s.VoucherCustomerStore
}

func (s *TimerLayer) VoucherProduct() store.VoucherProductStore {
	return s.VoucherProductStore
}

func (s *TimerLayer) VoucherProductVariant() store.VoucherProductVariantStore {
	return s.VoucherProductVariantStore
}

func (s *TimerLayer) VoucherTranslation() store.VoucherTranslationStore {
	return s.VoucherTranslationStore
}

func (s *TimerLayer) Warehouse() store.WarehouseStore {
	return s.WarehouseStore
}

func (s *TimerLayer) WarehouseShippingZone() store.WarehouseShippingZoneStore {
	return s.WarehouseShippingZoneStore
}

func (s *TimerLayer) Wishlist() store.WishlistStore {
	return s.WishlistStore
}

func (s *TimerLayer) WishlistItem() store.WishlistItemStore {
	return s.WishlistItemStore
}

func (s *TimerLayer) WishlistItemProductVariant() store.WishlistItemProductVariantStore {
	return s.WishlistItemProductVariantStore
}

type TimerLayerAddressStore struct {
	store.AddressStore
	Root *TimerLayer
}

type TimerLayerAllocationStore struct {
	store.AllocationStore
	Root *TimerLayer
}

type TimerLayerAppStore struct {
	store.AppStore
	Root *TimerLayer
}

type TimerLayerAppTokenStore struct {
	store.AppTokenStore
	Root *TimerLayer
}

type TimerLayerAssignedPageAttributeStore struct {
	store.AssignedPageAttributeStore
	Root *TimerLayer
}

type TimerLayerAssignedPageAttributeValueStore struct {
	store.AssignedPageAttributeValueStore
	Root *TimerLayer
}

type TimerLayerAssignedProductAttributeStore struct {
	store.AssignedProductAttributeStore
	Root *TimerLayer
}

type TimerLayerAssignedProductAttributeValueStore struct {
	store.AssignedProductAttributeValueStore
	Root *TimerLayer
}

type TimerLayerAssignedVariantAttributeStore struct {
	store.AssignedVariantAttributeStore
	Root *TimerLayer
}

type TimerLayerAssignedVariantAttributeValueStore struct {
	store.AssignedVariantAttributeValueStore
	Root *TimerLayer
}

type TimerLayerAttributeStore struct {
	store.AttributeStore
	Root *TimerLayer
}

type TimerLayerAttributePageStore struct {
	store.AttributePageStore
	Root *TimerLayer
}

type TimerLayerAttributeProductStore struct {
	store.AttributeProductStore
	Root *TimerLayer
}

type TimerLayerAttributeTranslationStore struct {
	store.AttributeTranslationStore
	Root *TimerLayer
}

type TimerLayerAttributeValueStore struct {
	store.AttributeValueStore
	Root *TimerLayer
}

type TimerLayerAttributeValueTranslationStore struct {
	store.AttributeValueTranslationStore
	Root *TimerLayer
}

type TimerLayerAttributeVariantStore struct {
	store.AttributeVariantStore
	Root *TimerLayer
}

type TimerLayerAuditStore struct {
	store.AuditStore
	Root *TimerLayer
}

type TimerLayerCategoryStore struct {
	store.CategoryStore
	Root *TimerLayer
}

type TimerLayerCategoryTranslationStore struct {
	store.CategoryTranslationStore
	Root *TimerLayer
}

type TimerLayerChannelStore struct {
	store.ChannelStore
	Root *TimerLayer
}

type TimerLayerCheckoutStore struct {
	store.CheckoutStore
	Root *TimerLayer
}

type TimerLayerCheckoutLineStore struct {
	store.CheckoutLineStore
	Root *TimerLayer
}

type TimerLayerClusterDiscoveryStore struct {
	store.ClusterDiscoveryStore
	Root *TimerLayer
}

type TimerLayerCollectionStore struct {
	store.CollectionStore
	Root *TimerLayer
}

type TimerLayerCollectionChannelListingStore struct {
	store.CollectionChannelListingStore
	Root *TimerLayer
}

type TimerLayerCollectionProductStore struct {
	store.CollectionProductStore
	Root *TimerLayer
}

type TimerLayerCollectionTranslationStore struct {
	store.CollectionTranslationStore
	Root *TimerLayer
}

type TimerLayerComplianceStore struct {
	store.ComplianceStore
	Root *TimerLayer
}

type TimerLayerCsvExportEventStore struct {
	store.CsvExportEventStore
	Root *TimerLayer
}

type TimerLayerCsvExportFileStore struct {
	store.CsvExportFileStore
	Root *TimerLayer
}

type TimerLayerCustomerEventStore struct {
	store.CustomerEventStore
	Root *TimerLayer
}

type TimerLayerCustomerNoteStore struct {
	store.CustomerNoteStore
	Root *TimerLayer
}

type TimerLayerDigitalContentStore struct {
	store.DigitalContentStore
	Root *TimerLayer
}

type TimerLayerDigitalContentUrlStore struct {
	store.DigitalContentUrlStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleStore struct {
	store.DiscountSaleStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleChannelListingStore struct {
	store.DiscountSaleChannelListingStore
	Root *TimerLayer
}

type TimerLayerDiscountSaleTranslationStore struct {
	store.DiscountSaleTranslationStore
	Root *TimerLayer
}

type TimerLayerDiscountVoucherStore struct {
	store.DiscountVoucherStore
	Root *TimerLayer
}

type TimerLayerFileInfoStore struct {
	store.FileInfoStore
	Root *TimerLayer
}

type TimerLayerFulfillmentStore struct {
	store.FulfillmentStore
	Root *TimerLayer
}

type TimerLayerFulfillmentLineStore struct {
	store.FulfillmentLineStore
	Root *TimerLayer
}

type TimerLayerGiftCardStore struct {
	store.GiftCardStore
	Root *TimerLayer
}

type TimerLayerGiftCardCheckoutStore struct {
	store.GiftCardCheckoutStore
	Root *TimerLayer
}

type TimerLayerGiftCardOrderStore struct {
	store.GiftCardOrderStore
	Root *TimerLayer
}

type TimerLayerGiftcardEventStore struct {
	store.GiftcardEventStore
	Root *TimerLayer
}

type TimerLayerInvoiceStore struct {
	store.InvoiceStore
	Root *TimerLayer
}

type TimerLayerInvoiceEventStore struct {
	store.InvoiceEventStore
	Root *TimerLayer
}

type TimerLayerJobStore struct {
	store.JobStore
	Root *TimerLayer
}

type TimerLayerMenuStore struct {
	store.MenuStore
	Root *TimerLayer
}

type TimerLayerMenuItemStore struct {
	store.MenuItemStore
	Root *TimerLayer
}

type TimerLayerMenuItemTranslationStore struct {
	store.MenuItemTranslationStore
	Root *TimerLayer
}

type TimerLayerOpenExchangeRateStore struct {
	store.OpenExchangeRateStore
	Root *TimerLayer
}

type TimerLayerOrderStore struct {
	store.OrderStore
	Root *TimerLayer
}

type TimerLayerOrderDiscountStore struct {
	store.OrderDiscountStore
	Root *TimerLayer
}

type TimerLayerOrderEventStore struct {
	store.OrderEventStore
	Root *TimerLayer
}

type TimerLayerOrderLineStore struct {
	store.OrderLineStore
	Root *TimerLayer
}

type TimerLayerPageStore struct {
	store.PageStore
	Root *TimerLayer
}

type TimerLayerPageTranslationStore struct {
	store.PageTranslationStore
	Root *TimerLayer
}

type TimerLayerPageTypeStore struct {
	store.PageTypeStore
	Root *TimerLayer
}

type TimerLayerPaymentStore struct {
	store.PaymentStore
	Root *TimerLayer
}

type TimerLayerPaymentTransactionStore struct {
	store.PaymentTransactionStore
	Root *TimerLayer
}

type TimerLayerPluginStore struct {
	store.PluginStore
	Root *TimerLayer
}

type TimerLayerPluginConfigurationStore struct {
	store.PluginConfigurationStore
	Root *TimerLayer
}

type TimerLayerPreferenceStore struct {
	store.PreferenceStore
	Root *TimerLayer
}

type TimerLayerPreorderAllocationStore struct {
	store.PreorderAllocationStore
	Root *TimerLayer
}

type TimerLayerProductStore struct {
	store.ProductStore
	Root *TimerLayer
}

type TimerLayerProductChannelListingStore struct {
	store.ProductChannelListingStore
	Root *TimerLayer
}

type TimerLayerProductMediaStore struct {
	store.ProductMediaStore
	Root *TimerLayer
}

type TimerLayerProductTranslationStore struct {
	store.ProductTranslationStore
	Root *TimerLayer
}

type TimerLayerProductTypeStore struct {
	store.ProductTypeStore
	Root *TimerLayer
}

type TimerLayerProductVariantStore struct {
	store.ProductVariantStore
	Root *TimerLayer
}

type TimerLayerProductVariantChannelListingStore struct {
	store.ProductVariantChannelListingStore
	Root *TimerLayer
}

type TimerLayerProductVariantTranslationStore struct {
	store.ProductVariantTranslationStore
	Root *TimerLayer
}

type TimerLayerRoleStore struct {
	store.RoleStore
	Root *TimerLayer
}

type TimerLayerSaleCategoryRelationStore struct {
	store.SaleCategoryRelationStore
	Root *TimerLayer
}

type TimerLayerSaleCollectionRelationStore struct {
	store.SaleCollectionRelationStore
	Root *TimerLayer
}

type TimerLayerSaleProductRelationStore struct {
	store.SaleProductRelationStore
	Root *TimerLayer
}

type TimerLayerSaleProductVariantStore struct {
	store.SaleProductVariantStore
	Root *TimerLayer
}

type TimerLayerSessionStore struct {
	store.SessionStore
	Root *TimerLayer
}

type TimerLayerShippingMethodStore struct {
	store.ShippingMethodStore
	Root *TimerLayer
}

type TimerLayerShippingMethodChannelListingStore struct {
	store.ShippingMethodChannelListingStore
	Root *TimerLayer
}

type TimerLayerShippingMethodExcludedProductStore struct {
	store.ShippingMethodExcludedProductStore
	Root *TimerLayer
}

type TimerLayerShippingMethodPostalCodeRuleStore struct {
	store.ShippingMethodPostalCodeRuleStore
	Root *TimerLayer
}

type TimerLayerShippingMethodTranslationStore struct {
	store.ShippingMethodTranslationStore
	Root *TimerLayer
}

type TimerLayerShippingZoneStore struct {
	store.ShippingZoneStore
	Root *TimerLayer
}

type TimerLayerShippingZoneChannelStore struct {
	store.ShippingZoneChannelStore
	Root *TimerLayer
}

type TimerLayerShopStore struct {
	store.ShopStore
	Root *TimerLayer
}

type TimerLayerShopStaffStore struct {
	store.ShopStaffStore
	Root *TimerLayer
}

type TimerLayerShopTranslationStore struct {
	store.ShopTranslationStore
	Root *TimerLayer
}

type TimerLayerStaffNotificationRecipientStore struct {
	store.StaffNotificationRecipientStore
	Root *TimerLayer
}

type TimerLayerStatusStore struct {
	store.StatusStore
	Root *TimerLayer
}

type TimerLayerStockStore struct {
	store.StockStore
	Root *TimerLayer
}

type TimerLayerSystemStore struct {
	store.SystemStore
	Root *TimerLayer
}

type TimerLayerTermsOfServiceStore struct {
	store.TermsOfServiceStore
	Root *TimerLayer
}

type TimerLayerTokenStore struct {
	store.TokenStore
	Root *TimerLayer
}

type TimerLayerUploadSessionStore struct {
	store.UploadSessionStore
	Root *TimerLayer
}

type TimerLayerUserStore struct {
	store.UserStore
	Root *TimerLayer
}

type TimerLayerUserAccessTokenStore struct {
	store.UserAccessTokenStore
	Root *TimerLayer
}

type TimerLayerUserAddressStore struct {
	store.UserAddressStore
	Root *TimerLayer
}

type TimerLayerVariantMediaStore struct {
	store.VariantMediaStore
	Root *TimerLayer
}

type TimerLayerVoucherCategoryStore struct {
	store.VoucherCategoryStore
	Root *TimerLayer
}

type TimerLayerVoucherChannelListingStore struct {
	store.VoucherChannelListingStore
	Root *TimerLayer
}

type TimerLayerVoucherCollectionStore struct {
	store.VoucherCollectionStore
	Root *TimerLayer
}

type TimerLayerVoucherCustomerStore struct {
	store.VoucherCustomerStore
	Root *TimerLayer
}

type TimerLayerVoucherProductStore struct {
	store.VoucherProductStore
	Root *TimerLayer
}

type TimerLayerVoucherProductVariantStore struct {
	store.VoucherProductVariantStore
	Root *TimerLayer
}

type TimerLayerVoucherTranslationStore struct {
	store.VoucherTranslationStore
	Root *TimerLayer
}

type TimerLayerWarehouseStore struct {
	store.WarehouseStore
	Root *TimerLayer
}

type TimerLayerWarehouseShippingZoneStore struct {
	store.WarehouseShippingZoneStore
	Root *TimerLayer
}

type TimerLayerWishlistStore struct {
	store.WishlistStore
	Root *TimerLayer
}

type TimerLayerWishlistItemStore struct {
	store.WishlistItemStore
	Root *TimerLayer
}

type TimerLayerWishlistItemProductVariantStore struct {
	store.WishlistItemProductVariantStore
	Root *TimerLayer
}

func (s *TimerLayerAddressStore) DeleteAddresses(addressIDs []string) error {
	start := timemodule.Now()

	err := s.AddressStore.DeleteAddresses(addressIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.DeleteAddresses", success, elapsed)
	}
	return err
}

func (s *TimerLayerAddressStore) FilterByOption(option *model.AddressFilterOption) ([]*model.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAddressStore) Get(addressID string) (*model.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.Get(addressID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAddressStore) Upsert(transaction store_iface.SqlxTxExecutor, address *model.Address) (*model.Address, error) {
	start := timemodule.Now()

	result, err := s.AddressStore.Upsert(transaction, address)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AddressStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) BulkDelete(transaction store_iface.SqlxTxExecutor, allocationIDs []string) error {
	start := timemodule.Now()

	err := s.AllocationStore.BulkDelete(transaction, allocationIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.BulkDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerAllocationStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, allocations []*model.Allocation) ([]*model.Allocation, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.BulkUpsert(transaction, allocations)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) CountAvailableQuantityForStock(stock *model.Stock) (int, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.CountAvailableQuantityForStock(stock)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.CountAvailableQuantityForStock", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) FilterByOption(transaction store_iface.SqlxTxExecutor, option *model.AllocationFilterOption) ([]*model.Allocation, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.FilterByOption(transaction, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAllocationStore) Get(allocationID string) (*model.Allocation, error) {
	start := timemodule.Now()

	result, err := s.AllocationStore.Get(allocationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AllocationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAppStore) Save(app *model.App) (*model.App, error) {
	start := timemodule.Now()

	result, err := s.AppStore.Save(app)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AppStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAppTokenStore) Save(appToken *model.AppToken) (*model.AppToken, error) {
	start := timemodule.Now()

	result, err := s.AppTokenStore.Save(appToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AppTokenStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) Get(id string) (*model.AssignedPageAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) GetByOption(option *model.AssignedPageAttributeFilterOption) (*model.AssignedPageAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeStore) Save(assignedPageAttr *model.AssignedPageAttribute) (*model.AssignedPageAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeStore.Save(assignedPageAttr)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) Get(assignedPageAttrValueID string) (*model.AssignedPageAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeValueStore.Get(assignedPageAttrValueID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) Save(assignedPageAttrValue *model.AssignedPageAttributeValue) (*model.AssignedPageAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeValueStore.Save(assignedPageAttrValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*model.AssignedPageAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedPageAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.SaveInBulk", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) SelectForSort(assignmentID string) ([]*model.AssignedPageAttributeValue, []*model.AttributeValue, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.AssignedPageAttributeValueStore.SelectForSort(assignmentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.SelectForSort", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAssignedPageAttributeValueStore) UpdateInBulk(attributeValues []*model.AssignedPageAttributeValue) error {
	start := timemodule.Now()

	err := s.AssignedPageAttributeValueStore.UpdateInBulk(attributeValues)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedPageAttributeValueStore.UpdateInBulk", success, elapsed)
	}
	return err
}

func (s *TimerLayerAssignedProductAttributeStore) FilterByOptions(options *model.AssignedProductAttributeFilterOption) ([]*model.AssignedProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeStore) Get(id string) (*model.AssignedProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeStore) GetWithOption(option *model.AssignedProductAttributeFilterOption) (*model.AssignedProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.GetWithOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.GetWithOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeStore) Save(assignedProductAttribute *model.AssignedProductAttribute) (*model.AssignedProductAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeStore.Save(assignedProductAttribute)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) Get(assignedProductAttrValueID string) (*model.AssignedProductAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.Get(assignedProductAttrValueID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) Save(assignedProductAttrValue *model.AssignedProductAttributeValue) (*model.AssignedProductAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.Save(assignedProductAttrValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*model.AssignedProductAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedProductAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.SaveInBulk", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) SelectForSort(assignmentID string) ([]*model.AssignedProductAttributeValue, []*model.AttributeValue, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.AssignedProductAttributeValueStore.SelectForSort(assignmentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.SelectForSort", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAssignedProductAttributeValueStore) UpdateInBulk(attributeValues []*model.AssignedProductAttributeValue) error {
	start := timemodule.Now()

	err := s.AssignedProductAttributeValueStore.UpdateInBulk(attributeValues)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedProductAttributeValueStore.UpdateInBulk", success, elapsed)
	}
	return err
}

func (s *TimerLayerAssignedVariantAttributeStore) FilterByOption(option *model.AssignedVariantAttributeFilterOption) ([]*model.AssignedVariantAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeStore) Get(id string) (*model.AssignedVariantAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeStore) GetWithOption(option *model.AssignedVariantAttributeFilterOption) (*model.AssignedVariantAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeStore.GetWithOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeStore.GetWithOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeStore) Save(assignedVariantAttribute *model.AssignedVariantAttribute) (*model.AssignedVariantAttribute, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeStore.Save(assignedVariantAttribute)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) Get(assignedVariantAttrValueID string) (*model.AssignedVariantAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeValueStore.Get(assignedVariantAttrValueID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) Save(assignedVariantAttrValue *model.AssignedVariantAttributeValue) (*model.AssignedVariantAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeValueStore.Save(assignedVariantAttrValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*model.AssignedVariantAttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AssignedVariantAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.SaveInBulk", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) SelectForSort(assignmentID string) ([]*model.AssignedVariantAttributeValue, []*model.AttributeValue, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.AssignedVariantAttributeValueStore.SelectForSort(assignmentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.SelectForSort", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerAssignedVariantAttributeValueStore) UpdateInBulk(attributeValues []*model.AssignedVariantAttributeValue) error {
	start := timemodule.Now()

	err := s.AssignedVariantAttributeValueStore.UpdateInBulk(attributeValues)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AssignedVariantAttributeValueStore.UpdateInBulk", success, elapsed)
	}
	return err
}

func (s *TimerLayerAttributeStore) Delete(ids ...string) (int64, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.Delete(ids...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) FilterbyOption(option *model.AttributeFilterOption) (model.Attributes, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) GetByOption(option *model.AttributeFilterOption) (*model.Attribute, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeStore) Upsert(attr *model.Attribute) (*model.Attribute, error) {
	start := timemodule.Now()

	result, err := s.AttributeStore.Upsert(attr)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) Get(pageID string) (*model.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.Get(pageID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) GetByOption(option *model.AttributePageFilterOption) (*model.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributePageStore) Save(page *model.AttributePage) (*model.AttributePage, error) {
	start := timemodule.Now()

	result, err := s.AttributePageStore.Save(page)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributePageStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeProductStore) Get(attributeProductID string) (*model.AttributeProduct, error) {
	start := timemodule.Now()

	result, err := s.AttributeProductStore.Get(attributeProductID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeProductStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeProductStore) GetByOption(option *model.AttributeProductFilterOption) (*model.AttributeProduct, error) {
	start := timemodule.Now()

	result, err := s.AttributeProductStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeProductStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeProductStore) Save(attributeProduct *model.AttributeProduct) (*model.AttributeProduct, error) {
	start := timemodule.Now()

	result, err := s.AttributeProductStore.Save(attributeProduct)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeProductStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, values model.AttributeValues) (model.AttributeValues, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.BulkUpsert(transaction, values)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Count(options *model.AttributeValueFilterOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Count(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Delete(ids ...string) (int64, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Delete(ids...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) FilterByOptions(options model.AttributeValueFilterOptions) (model.AttributeValues, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Get(attributeID string) (*model.AttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Get(attributeID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeValueStore) Upsert(av *model.AttributeValue) (*model.AttributeValue, error) {
	start := timemodule.Now()

	result, err := s.AttributeValueStore.Upsert(av)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeValueStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeVariantStore) Get(attributeVariantID string) (*model.AttributeVariant, error) {
	start := timemodule.Now()

	result, err := s.AttributeVariantStore.Get(attributeVariantID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeVariantStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeVariantStore) GetByOption(option *model.AttributeVariantFilterOption) (*model.AttributeVariant, error) {
	start := timemodule.Now()

	result, err := s.AttributeVariantStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeVariantStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAttributeVariantStore) Save(attributeVariant *model.AttributeVariant) (*model.AttributeVariant, error) {
	start := timemodule.Now()

	result, err := s.AttributeVariantStore.Save(attributeVariant)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AttributeVariantStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAuditStore) Get(userID string, offset int, limit int) (model.Audits, error) {
	start := timemodule.Now()

	result, err := s.AuditStore.Get(userID, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerAuditStore) PermanentDeleteByUser(userID string) error {
	start := timemodule.Now()

	err := s.AuditStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerAuditStore) Save(audit *model.Audit) error {
	start := timemodule.Now()

	err := s.AuditStore.Save(audit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("AuditStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerCategoryStore) FilterByOption(option *model.CategoryFilterOption) ([]*model.Category, error) {
	start := timemodule.Now()

	result, err := s.CategoryStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CategoryStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCategoryStore) Get(categoryID string) (*model.Category, error) {
	start := timemodule.Now()

	result, err := s.CategoryStore.Get(categoryID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CategoryStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCategoryStore) GetByOption(option *model.CategoryFilterOption) (*model.Category, error) {
	start := timemodule.Now()

	result, err := s.CategoryStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CategoryStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCategoryStore) Upsert(category *model.Category) (*model.Category, error) {
	start := timemodule.Now()

	result, err := s.CategoryStore.Upsert(category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CategoryStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) FilterByOption(option *model.ChannelFilterOption) ([]*model.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) Get(id string) (*model.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) GetbyOption(option *model.ChannelFilterOption) (*model.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.GetbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.GetbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerChannelStore) Save(ch *model.Channel) (*model.Channel, error) {
	start := timemodule.Now()

	result, err := s.ChannelStore.Save(ch)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ChannelStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) CountCheckouts(options *model.CheckoutFilterOption) (int64, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.CountCheckouts(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.CountCheckouts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) DeleteCheckoutsByOption(transaction store_iface.SqlxTxExecutor, option *model.CheckoutFilterOption) error {
	start := timemodule.Now()

	err := s.CheckoutStore.DeleteCheckoutsByOption(transaction, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.DeleteCheckoutsByOption", success, elapsed)
	}
	return err
}

func (s *TimerLayerCheckoutStore) FetchCheckoutLinesAndPrefetchRelatedValue(ckout *model.Checkout) ([]*model.CheckoutLineInfo, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.FetchCheckoutLinesAndPrefetchRelatedValue(ckout)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.FetchCheckoutLinesAndPrefetchRelatedValue", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) FilterByOption(option *model.CheckoutFilterOption) ([]*model.Checkout, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) Get(token string) (*model.Checkout, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.Get(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) GetByOption(option *model.CheckoutFilterOption) (*model.Checkout, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutStore) Upsert(ckout *model.Checkout) (*model.Checkout, error) {
	start := timemodule.Now()

	result, err := s.CheckoutStore.Upsert(ckout)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) BulkCreate(checkoutLines []*model.CheckoutLine) ([]*model.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.BulkCreate(checkoutLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.BulkCreate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) BulkUpdate(checkoutLines []*model.CheckoutLine) error {
	start := timemodule.Now()

	err := s.CheckoutLineStore.BulkUpdate(checkoutLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.BulkUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerCheckoutLineStore) CheckoutLinesByCheckoutID(checkoutID string) ([]*model.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.CheckoutLinesByCheckoutID(checkoutID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.CheckoutLinesByCheckoutID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) CheckoutLinesByCheckoutWithPrefetch(checkoutID string) ([]*model.CheckoutLine, []*model.ProductVariant, []*model.Product, error) {
	start := timemodule.Now()

	result, resultVar1, resultVar2, err := s.CheckoutLineStore.CheckoutLinesByCheckoutWithPrefetch(checkoutID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.CheckoutLinesByCheckoutWithPrefetch", success, elapsed)
	}
	return result, resultVar1, resultVar2, err
}

func (s *TimerLayerCheckoutLineStore) CheckoutLinesByOption(option *model.CheckoutLineFilterOption) ([]*model.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.CheckoutLinesByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.CheckoutLinesByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) DeleteLines(transaction store_iface.SqlxTxExecutor, checkoutLineIDs []string) error {
	start := timemodule.Now()

	err := s.CheckoutLineStore.DeleteLines(transaction, checkoutLineIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.DeleteLines", success, elapsed)
	}
	return err
}

func (s *TimerLayerCheckoutLineStore) Get(id string) (*model.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) TotalWeightForCheckoutLines(checkoutLineIDs []string) (*measurement.Weight, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.TotalWeightForCheckoutLines(checkoutLineIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.TotalWeightForCheckoutLines", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCheckoutLineStore) Upsert(checkoutLine *model.CheckoutLine) (*model.CheckoutLine, error) {
	start := timemodule.Now()

	result, err := s.CheckoutLineStore.Upsert(checkoutLine)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CheckoutLineStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Cleanup() error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Cleanup", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.Delete(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.Exists(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Exists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, error) {
	start := timemodule.Now()

	result, err := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.Save(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) error {
	start := timemodule.Now()

	err := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ClusterDiscoveryStore.SetLastPingAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerCollectionStore) FilterByOption(option *model.CollectionFilterOption) ([]*model.Collection, error) {
	start := timemodule.Now()

	result, err := s.CollectionStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionStore) Get(collectionID string) (*model.Collection, error) {
	start := timemodule.Now()

	result, err := s.CollectionStore.Get(collectionID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionStore) Upsert(collection *model.Collection) (*model.Collection, error) {
	start := timemodule.Now()

	result, err := s.CollectionStore.Upsert(collection)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionChannelListingStore) FilterByOptions(options *model.CollectionChannelListingFilterOptions) ([]*model.CollectionChannelListing, error) {
	start := timemodule.Now()

	result, err := s.CollectionChannelListingStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionChannelListingStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCollectionProductStore) FilterByOptions(options *model.CollectionProductFilterOptions) ([]*model.CollectionProduct, error) {
	start := timemodule.Now()

	result, err := s.CollectionProductStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CollectionProductStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) ComplianceExport(model *model.Compliance, cursor model.ComplianceExportCursor, limit int) ([]*model.CompliancePost, model.ComplianceExportCursor, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.ComplianceStore.ComplianceExport(model, cursor, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.ComplianceExport", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerComplianceStore) Get(id string) (*model.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) MessageExport(cursor model.MessageExportCursor, limit int) ([]*model.MessageExport, model.MessageExportCursor, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.ComplianceStore.MessageExport(cursor, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.MessageExport", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerComplianceStore) Save(model *model.Compliance) (*model.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Save(model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerComplianceStore) Update(model *model.Compliance) (*model.Compliance, error) {
	start := timemodule.Now()

	result, err := s.ComplianceStore.Update(model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ComplianceStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportEventStore) FilterByOption(options *model.ExportEventFilterOption) ([]*model.ExportEvent, error) {
	start := timemodule.Now()

	result, err := s.CsvExportEventStore.FilterByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportEventStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportEventStore) Save(event *model.ExportEvent) (*model.ExportEvent, error) {
	start := timemodule.Now()

	result, err := s.CsvExportEventStore.Save(event)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportEventStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportFileStore) Get(id string) (*model.ExportFile, error) {
	start := timemodule.Now()

	result, err := s.CsvExportFileStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportFileStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCsvExportFileStore) Save(file *model.ExportFile) (*model.ExportFile, error) {
	start := timemodule.Now()

	result, err := s.CsvExportFileStore.Save(file)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CsvExportFileStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Count() (int64, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Count()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) FilterByOptions(options *model.CustomerEventFilterOptions) ([]*model.CustomerEvent, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Get(id string) (*model.CustomerEvent, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerEventStore) Save(customemrEvent *model.CustomerEvent) (*model.CustomerEvent, error) {
	start := timemodule.Now()

	result, err := s.CustomerEventStore.Save(customemrEvent)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerEventStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerNoteStore) Get(id string) (*model.CustomerNote, error) {
	start := timemodule.Now()

	result, err := s.CustomerNoteStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerNoteStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerCustomerNoteStore) Save(note *model.CustomerNote) (*model.CustomerNote, error) {
	start := timemodule.Now()

	result, err := s.CustomerNoteStore.Save(note)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("CustomerNoteStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentStore) FilterByOption(option *model.DigitalContenetFilterOption) ([]*model.DigitalContent, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentStore) GetByOption(option *model.DigitalContenetFilterOption) (*model.DigitalContent, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentStore) Save(content *model.DigitalContent) (*model.DigitalContent, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentStore.Save(content)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentUrlStore) Get(id string) (*model.DigitalContentUrl, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentUrlStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentUrlStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDigitalContentUrlStore) Upsert(contentURL *model.DigitalContentUrl) (*model.DigitalContentUrl, error) {
	start := timemodule.Now()

	result, err := s.DigitalContentUrlStore.Upsert(contentURL)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DigitalContentUrlStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) FilterSalesByOption(option *model.SaleFilterOption) ([]*model.Sale, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.FilterSalesByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.FilterSalesByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) Get(saleID string) (*model.Sale, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.Get(saleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleStore) Upsert(sale *model.Sale) (*model.Sale, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleStore.Upsert(sale)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleChannelListingStore) Get(saleChannelListingID string) (*model.SaleChannelListing, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleChannelListingStore.Get(saleChannelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleChannelListingStore) SaleChannelListingsWithOption(option *model.SaleChannelListingFilterOption) ([]*model.SaleChannelListing, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleChannelListingStore.SaleChannelListingsWithOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleChannelListingStore.SaleChannelListingsWithOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountSaleChannelListingStore) Save(saleChannelListing *model.SaleChannelListing) (*model.SaleChannelListing, error) {
	start := timemodule.Now()

	result, err := s.DiscountSaleChannelListingStore.Save(saleChannelListing)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountSaleChannelListingStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) ExpiredVouchers(date *timemodule.Time) ([]*model.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.ExpiredVouchers(date)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.ExpiredVouchers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) FilterVouchersByOption(option *model.VoucherFilterOption) ([]*model.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.FilterVouchersByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.FilterVouchersByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) Get(voucherID string) (*model.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.Get(voucherID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) GetByOptions(options *model.VoucherFilterOption) (*model.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerDiscountVoucherStore) Upsert(voucher *model.Voucher) (*model.Voucher, error) {
	start := timemodule.Now()

	result, err := s.DiscountVoucherStore.Upsert(voucher)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("DiscountVoucherStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) ClearCaches() {
	start := timemodule.Now()

	s.FileInfoStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) CountAll() (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.CountAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.CountAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) Get(id string) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetByIds(ids []string) ([]*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetByIds(ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetByPath(path)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetByPath", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetForUser(userID string) ([]*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetFromMaster(id string) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetFromMaster(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetFromMaster", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) GetWithOptions(page *int, perPage *int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.GetWithOptions(page, perPage, opt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.GetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) InvalidateFileInfosForPostCache(postID string, deleted bool) {
	start := timemodule.Now()

	s.FileInfoStore.InvalidateFileInfosForPostCache(postID, deleted)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.InvalidateFileInfosForPostCache", success, elapsed)
	}
}

func (s *TimerLayerFileInfoStore) PermanentDelete(fileID string) error {
	start := timemodule.Now()

	err := s.FileInfoStore.PermanentDelete(fileID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) PermanentDeleteByUser(userID string) (int64, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.PermanentDeleteByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFileInfoStore) SetContent(fileID string, content string) error {
	start := timemodule.Now()

	err := s.FileInfoStore.SetContent(fileID, content)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.SetContent", success, elapsed)
	}
	return err
}

func (s *TimerLayerFileInfoStore) Upsert(info *model.FileInfo) (*model.FileInfo, error) {
	start := timemodule.Now()

	result, err := s.FileInfoStore.Upsert(info)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FileInfoStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) BulkDeleteFulfillments(transaction store_iface.SqlxTxExecutor, fulfillments model.Fulfillments) error {
	start := timemodule.Now()

	err := s.FulfillmentStore.BulkDeleteFulfillments(transaction, fulfillments)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.BulkDeleteFulfillments", success, elapsed)
	}
	return err
}

func (s *TimerLayerFulfillmentStore) FilterByOption(transaction store_iface.SqlxTxExecutor, option *model.FulfillmentFilterOption) ([]*model.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.FilterByOption(transaction, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) Get(id string) (*model.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) GetByOption(transaction store_iface.SqlxTxExecutor, option *model.FulfillmentFilterOption) (*model.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.GetByOption(transaction, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentStore) Upsert(transaction store_iface.SqlxTxExecutor, fulfillment *model.Fulfillment) (*model.Fulfillment, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentStore.Upsert(transaction, fulfillment)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, fulfillmentLines []*model.FulfillmentLine) ([]*model.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.BulkUpsert(transaction, fulfillmentLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) DeleteFulfillmentLinesByOption(transaction store_iface.SqlxTxExecutor, option *model.FulfillmentLineFilterOption) error {
	start := timemodule.Now()

	err := s.FulfillmentLineStore.DeleteFulfillmentLinesByOption(transaction, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.DeleteFulfillmentLinesByOption", success, elapsed)
	}
	return err
}

func (s *TimerLayerFulfillmentLineStore) FilterbyOption(option *model.FulfillmentLineFilterOption) ([]*model.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) Get(id string) (*model.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerFulfillmentLineStore) Save(fulfillmentLine *model.FulfillmentLine) (*model.FulfillmentLine, error) {
	start := timemodule.Now()

	result, err := s.FulfillmentLineStore.Save(fulfillmentLine)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("FulfillmentLineStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, giftCards ...*model.GiftCard) ([]*model.GiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.BulkUpsert(transaction, giftCards...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) DeactivateOrderGiftcards(orderID string) ([]string, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.DeactivateOrderGiftcards(orderID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.DeactivateOrderGiftcards", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) FilterByOption(transaction store_iface.SqlxTxExecutor, option *model.GiftCardFilterOption) ([]*model.GiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.FilterByOption(transaction, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardStore) GetById(id string) (*model.GiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardStore.GetById(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardCheckoutStore) Delete(giftcardID string, checkoutID string) error {
	start := timemodule.Now()

	err := s.GiftCardCheckoutStore.Delete(giftcardID, checkoutID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardCheckoutStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerGiftCardCheckoutStore) Get(id string) (*model.GiftCardCheckout, error) {
	start := timemodule.Now()

	result, err := s.GiftCardCheckoutStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardCheckoutStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardCheckoutStore) Save(giftcardOrder *model.GiftCardCheckout) (*model.GiftCardCheckout, error) {
	start := timemodule.Now()

	result, err := s.GiftCardCheckoutStore.Save(giftcardOrder)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardCheckoutStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardOrderStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, orderGiftcards ...*model.OrderGiftCard) ([]*model.OrderGiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardOrderStore.BulkUpsert(transaction, orderGiftcards...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardOrderStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardOrderStore) FilterByOptions(options *model.OrderGiftCardFilterOptions) ([]*model.OrderGiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardOrderStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardOrderStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardOrderStore) Get(id string) (*model.OrderGiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardOrderStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardOrderStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftCardOrderStore) Save(giftcardOrder *model.OrderGiftCard) (*model.OrderGiftCard, error) {
	start := timemodule.Now()

	result, err := s.GiftCardOrderStore.Save(giftcardOrder)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftCardOrderStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftcardEventStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, events ...*model.GiftCardEvent) ([]*model.GiftCardEvent, error) {
	start := timemodule.Now()

	result, err := s.GiftcardEventStore.BulkUpsert(transaction, events...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftcardEventStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftcardEventStore) FilterByOptions(options *model.GiftCardEventFilterOption) ([]*model.GiftCardEvent, error) {
	start := timemodule.Now()

	result, err := s.GiftcardEventStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftcardEventStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftcardEventStore) Get(id string) (*model.GiftCardEvent, error) {
	start := timemodule.Now()

	result, err := s.GiftcardEventStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftcardEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerGiftcardEventStore) Save(event *model.GiftCardEvent) (*model.GiftCardEvent, error) {
	start := timemodule.Now()

	result, err := s.GiftcardEventStore.Save(event)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("GiftcardEventStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceStore) FilterByOptions(options *model.InvoiceFilterOptions) ([]*model.Invoice, error) {
	start := timemodule.Now()

	result, err := s.InvoiceStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceStore) Get(invoiceID string) (*model.Invoice, error) {
	start := timemodule.Now()

	result, err := s.InvoiceStore.Get(invoiceID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceStore) Upsert(invoice *model.Invoice) (*model.Invoice, error) {
	start := timemodule.Now()

	result, err := s.InvoiceStore.Upsert(invoice)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceEventStore) Get(invoiceEventID string) (*model.InvoiceEvent, error) {
	start := timemodule.Now()

	result, err := s.InvoiceEventStore.Get(invoiceEventID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerInvoiceEventStore) Upsert(invoiceEvent *model.InvoiceEvent) (*model.InvoiceEvent, error) {
	start := timemodule.Now()

	result, err := s.InvoiceEventStore.Upsert(invoiceEvent)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("InvoiceEventStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Delete(id string) (string, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Get(id string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByStatus(status string) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByStatus(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByType(jobType string) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByType(jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByTypePage(jobType, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypePage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllByTypesPage(jobTypes []string, offset int, limit int) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllByTypesPage(jobTypes, offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllByTypesPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetAllPage(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetAllPage", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetCountByStatusAndType(status, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetCountByStatusAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetNewestJobByStatusAndType(status, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) GetNewestJobByStatusesAndType(statuses []string, jobType string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.GetNewestJobByStatusesAndType(statuses, jobType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.GetNewestJobByStatusesAndType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) Save(job *model.Job) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.Save(job)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateOptimistically(job, currentStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatus(id string, status string) (*model.Job, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateStatus(id, status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatus", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, error) {
	start := timemodule.Now()

	result, err := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("JobStore.UpdateStatusOptimistically", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) FilterByOptions(options *model.MenuFilterOptions) ([]*model.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) GetByOptions(options *model.MenuFilterOptions) (*model.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuStore) Save(menu *model.Menu) (*model.Menu, error) {
	start := timemodule.Now()

	result, err := s.MenuStore.Save(menu)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) FilterByOptions(options *model.MenuItemFilterOptions) ([]*model.MenuItem, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) GetByOptions(options *model.MenuItemFilterOptions) (*model.MenuItem, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerMenuItemStore) Save(menuItem *model.MenuItem) (*model.MenuItem, error) {
	start := timemodule.Now()

	result, err := s.MenuItemStore.Save(menuItem)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("MenuItemStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOpenExchangeRateStore) BulkUpsert(rates []*model.OpenExchangeRate) ([]*model.OpenExchangeRate, error) {
	start := timemodule.Now()

	result, err := s.OpenExchangeRateStore.BulkUpsert(rates)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OpenExchangeRateStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOpenExchangeRateStore) GetAll() ([]*model.OpenExchangeRate, error) {
	start := timemodule.Now()

	result, err := s.OpenExchangeRateStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OpenExchangeRateStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) BulkUpsert(orders []*model.Order) ([]*model.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.BulkUpsert(orders)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) FilterByOption(option *model.OrderFilterOption) ([]*model.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) Get(id string) (*model.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) Save(transaction store_iface.SqlxTxExecutor, order *model.Order) (*model.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.Save(transaction, order)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderStore) Update(transaction store_iface.SqlxTxExecutor, order *model.Order) (*model.Order, error) {
	start := timemodule.Now()

	result, err := s.OrderStore.Update(transaction, order)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderDiscountStore) BulkDelete(orderDiscountIDs []string) error {
	start := timemodule.Now()

	err := s.OrderDiscountStore.BulkDelete(orderDiscountIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderDiscountStore.BulkDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerOrderDiscountStore) FilterbyOption(option *model.OrderDiscountFilterOption) ([]*model.OrderDiscount, error) {
	start := timemodule.Now()

	result, err := s.OrderDiscountStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderDiscountStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderDiscountStore) Get(orderDiscountID string) (*model.OrderDiscount, error) {
	start := timemodule.Now()

	result, err := s.OrderDiscountStore.Get(orderDiscountID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderDiscountStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderDiscountStore) Upsert(transaction store_iface.SqlxTxExecutor, orderDiscount *model.OrderDiscount) (*model.OrderDiscount, error) {
	start := timemodule.Now()

	result, err := s.OrderDiscountStore.Upsert(transaction, orderDiscount)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderDiscountStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderEventStore) FilterByOptions(options *model.OrderEventFilterOptions) ([]*model.OrderEvent, error) {
	start := timemodule.Now()

	result, err := s.OrderEventStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderEventStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderEventStore) Get(orderEventID string) (*model.OrderEvent, error) {
	start := timemodule.Now()

	result, err := s.OrderEventStore.Get(orderEventID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderEventStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderEventStore) Save(transaction store_iface.SqlxTxExecutor, orderEvent *model.OrderEvent) (*model.OrderEvent, error) {
	start := timemodule.Now()

	result, err := s.OrderEventStore.Save(transaction, orderEvent)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderEventStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) BulkDelete(orderLineIDs []string) error {
	start := timemodule.Now()

	err := s.OrderLineStore.BulkDelete(orderLineIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.BulkDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerOrderLineStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, orderLines []*model.OrderLine) ([]*model.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.BulkUpsert(transaction, orderLines)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) FilterbyOption(option *model.OrderLineFilterOption) ([]*model.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) Get(id string) (*model.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerOrderLineStore) Upsert(transaction store_iface.SqlxTxExecutor, orderLine *model.OrderLine) (*model.OrderLine, error) {
	start := timemodule.Now()

	result, err := s.OrderLineStore.Upsert(transaction, orderLine)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("OrderLineStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPageStore) FilterByOptions(options *model.PageFilterOptions) ([]*model.Page, error) {
	start := timemodule.Now()

	result, err := s.PageStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PageStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) CancelActivePaymentsOfCheckout(checkoutToken string) error {
	start := timemodule.Now()

	err := s.PaymentStore.CancelActivePaymentsOfCheckout(checkoutToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.CancelActivePaymentsOfCheckout", success, elapsed)
	}
	return err
}

func (s *TimerLayerPaymentStore) FilterByOption(option *model.PaymentFilterOption) ([]*model.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) Get(transaction store_iface.SqlxTxExecutor, id string, lockForUpdate bool) (*model.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.Get(transaction, id, lockForUpdate)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) PaymentOwnedByUser(userID string, paymentID string) (bool, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.PaymentOwnedByUser(userID, paymentID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.PaymentOwnedByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) Save(transaction store_iface.SqlxTxExecutor, model *model.Payment) (*model.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.Save(transaction, model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) Update(transaction store_iface.SqlxTxExecutor, model *model.Payment) (*model.Payment, error) {
	start := timemodule.Now()

	result, err := s.PaymentStore.Update(transaction, model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentStore) UpdatePaymentsOfCheckout(transaction store_iface.SqlxTxExecutor, checkoutToken string, option *model.PaymentPatch) error {
	start := timemodule.Now()

	err := s.PaymentStore.UpdatePaymentsOfCheckout(transaction, checkoutToken, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentStore.UpdatePaymentsOfCheckout", success, elapsed)
	}
	return err
}

func (s *TimerLayerPaymentTransactionStore) FilterByOption(option *model.PaymentTransactionFilterOpts) ([]*model.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Get(id string) (*model.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Save(transaction store_iface.SqlxTxExecutor, paymentTransaction *model.PaymentTransaction) (*model.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Save(transaction, paymentTransaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPaymentTransactionStore) Update(transaction *model.PaymentTransaction) (*model.PaymentTransaction, error) {
	start := timemodule.Now()

	result, err := s.PaymentTransactionStore.Update(transaction)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PaymentTransactionStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.CompareAndDelete(keyVal, oldValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndDelete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.CompareAndSet(keyVal, oldValue)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.CompareAndSet", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) Delete(pluginID string, key string) error {
	start := timemodule.Now()

	err := s.PluginStore.Delete(pluginID, key)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllExpired() error {
	start := timemodule.Now()

	err := s.PluginStore.DeleteAllExpired()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllExpired", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) DeleteAllForPlugin(PluginID string) error {
	start := timemodule.Now()

	err := s.PluginStore.DeleteAllForPlugin(PluginID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.DeleteAllForPlugin", success, elapsed)
	}
	return err
}

func (s *TimerLayerPluginStore) Get(pluginID string, key string) (*model.PluginKeyValue, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.Get(pluginID, key)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) List(pluginID string, page int, perPage int) ([]string, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.List(pluginID, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.List", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.SaveOrUpdate(keyVal)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SaveOrUpdate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginStore) SetWithOptions(pluginID string, key string, value []byte, options model.PluginKVSetOptions) (bool, error) {
	start := timemodule.Now()

	result, err := s.PluginStore.SetWithOptions(pluginID, key, value, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginStore.SetWithOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginConfigurationStore) FilterPluginConfigurations(options model.PluginConfigurationFilterOptions) ([]*model.PluginConfiguration, error) {
	start := timemodule.Now()

	result, err := s.PluginConfigurationStore.FilterPluginConfigurations(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginConfigurationStore.FilterPluginConfigurations", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginConfigurationStore) Get(id string) (*model.PluginConfiguration, error) {
	start := timemodule.Now()

	result, err := s.PluginConfigurationStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginConfigurationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginConfigurationStore) GetByOptions(options *model.PluginConfigurationFilterOptions) (*model.PluginConfiguration, error) {
	start := timemodule.Now()

	result, err := s.PluginConfigurationStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginConfigurationStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPluginConfigurationStore) Upsert(config *model.PluginConfiguration) (*model.PluginConfiguration, error) {
	start := timemodule.Now()

	result, err := s.PluginConfigurationStore.Upsert(config)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PluginConfigurationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.CleanupFlagsBatch(limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.CleanupFlagsBatch", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) Delete(userID string, category string, name string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.Delete(userID, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategory(userID string, category string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.DeleteCategory(userID, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategory", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteCategoryAndName(category string, name string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.DeleteCategoryAndName(category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteCategoryAndName", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) DeleteUnusedFeatures() {
	start := timemodule.Now()

	s.PreferenceStore.DeleteUnusedFeatures()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.DeleteUnusedFeatures", success, elapsed)
	}
}

func (s *TimerLayerPreferenceStore) Get(userID string, category string, name string) (*model.Preference, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.Get(userID, category, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetAll(userID string) (model.Preferences, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.GetAll(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) GetCategory(userID string, category string) (model.Preferences, error) {
	start := timemodule.Now()

	result, err := s.PreferenceStore.GetCategory(userID, category)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.GetCategory", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreferenceStore) PermanentDeleteByUser(userID string) error {
	start := timemodule.Now()

	err := s.PreferenceStore.PermanentDeleteByUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.PermanentDeleteByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreferenceStore) Save(preferences model.Preferences) error {
	start := timemodule.Now()

	err := s.PreferenceStore.Save(preferences)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreferenceStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreorderAllocationStore) BulkCreate(transaction store_iface.SqlxTxExecutor, preorderAllocations []*model.PreorderAllocation) ([]*model.PreorderAllocation, error) {
	start := timemodule.Now()

	result, err := s.PreorderAllocationStore.BulkCreate(transaction, preorderAllocations)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreorderAllocationStore.BulkCreate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerPreorderAllocationStore) Delete(transaction store_iface.SqlxTxExecutor, preorderAllocationIDs ...string) error {
	start := timemodule.Now()

	err := s.PreorderAllocationStore.Delete(transaction, preorderAllocationIDs...)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreorderAllocationStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerPreorderAllocationStore) FilterByOption(options *model.PreorderAllocationFilterOption) ([]*model.PreorderAllocation, error) {
	start := timemodule.Now()

	result, err := s.PreorderAllocationStore.FilterByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("PreorderAllocationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) AdvancedFilterQueryBuilder(input *model.ExportProductsFilterOptions) squirrel.SelectBuilder {
	start := timemodule.Now()

	result := s.ProductStore.AdvancedFilterQueryBuilder(input)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.AdvancedFilterQueryBuilder", success, elapsed)
	}
	return result
}

func (s *TimerLayerProductStore) FilterByOption(option *model.ProductFilterOption) ([]*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) FilterByQuery(query squirrel.SelectBuilder) (model.Products, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.FilterByQuery(query)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.FilterByQuery", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) GetByOption(option *model.ProductFilterOption) (*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) NotPublishedProducts(channelSlug string) ([]*struct {
	model.Product
	IsPublished     bool
	PublicationDate *timemodule.Time
}, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.NotPublishedProducts(channelSlug)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.NotPublishedProducts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) PublishedProducts(channelSlug string) ([]*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.PublishedProducts(channelSlug)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.PublishedProducts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) PublishedWithVariants(channelSlug string) ([]*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.PublishedWithVariants(channelSlug)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.PublishedWithVariants", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) Save(prd *model.Product) (*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.Save(prd)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) SelectForUpdateDiscountedPricesOfCatalogues(productIDs []string, categoryIDs []string, collectionIDs []string) ([]*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.SelectForUpdateDiscountedPricesOfCatalogues(productIDs, categoryIDs, collectionIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.SelectForUpdateDiscountedPricesOfCatalogues", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductStore) VisibleToUserProducts(channelSlug string, requesterIsStaff bool) ([]*model.Product, error) {
	start := timemodule.Now()

	result, err := s.ProductStore.VisibleToUserProducts(channelSlug, requesterIsStaff)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductStore.VisibleToUserProducts", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductChannelListingStore) BulkUpsert(listings []*model.ProductChannelListing) ([]*model.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.BulkUpsert(listings)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductChannelListingStore) FilterByOption(option *model.ProductChannelListingFilterOption) ([]*model.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductChannelListingStore) Get(channelListingID string) (*model.ProductChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductChannelListingStore.Get(channelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductMediaStore) FilterByOption(option *model.ProductMediaFilterOption) ([]*model.ProductMedia, error) {
	start := timemodule.Now()

	result, err := s.ProductMediaStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductMediaStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductMediaStore) Get(id string) (*model.ProductMedia, error) {
	start := timemodule.Now()

	result, err := s.ProductMediaStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductMediaStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductMediaStore) Upsert(media *model.ProductMedia) (*model.ProductMedia, error) {
	start := timemodule.Now()

	result, err := s.ProductMediaStore.Upsert(media)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductMediaStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTranslationStore) FilterByOption(option *model.ProductTranslationFilterOption) ([]*model.ProductTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductTranslationStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTranslationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTranslationStore) Get(translationID string) (*model.ProductTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductTranslationStore.Get(translationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTranslationStore) Upsert(translation *model.ProductTranslation) (*model.ProductTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductTranslationStore.Upsert(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTranslationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) Count(options *model.ProductTypeFilterOption) (int64, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.Count(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) FilterProductTypesByCheckoutToken(checkoutToken string) ([]*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.FilterProductTypesByCheckoutToken(checkoutToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.FilterProductTypesByCheckoutToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) FilterbyOption(options *model.ProductTypeFilterOption) ([]*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.FilterbyOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) GetByOption(options *model.ProductTypeFilterOption) (*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.GetByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) ProductTypeByProductVariantID(variantID string) (*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.ProductTypeByProductVariantID(variantID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.ProductTypeByProductVariantID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) ProductTypesByProductIDs(productIDs []string) ([]*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.ProductTypesByProductIDs(productIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.ProductTypesByProductIDs", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductTypeStore) Save(productType *model.ProductType) (*model.ProductType, error) {
	start := timemodule.Now()

	result, err := s.ProductTypeStore.Save(productType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductTypeStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) FilterByOption(option *model.ProductVariantFilterOption) ([]*model.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) Get(id string) (*model.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) GetByOrderLineID(orderLineID string) (*model.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.GetByOrderLineID(orderLineID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.GetByOrderLineID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) GetWeight(productVariantID string) (*measurement.Weight, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.GetWeight(productVariantID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.GetWeight", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) Save(transaction store_iface.SqlxTxExecutor, variant *model.ProductVariant) (*model.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.Save(transaction, variant)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantStore) Update(transaction store_iface.SqlxTxExecutor, variant *model.ProductVariant) (*model.ProductVariant, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantStore.Update(transaction, variant)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantChannelListingStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, variantChannelListings []*model.ProductVariantChannelListing) ([]*model.ProductVariantChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantChannelListingStore.BulkUpsert(transaction, variantChannelListings)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantChannelListingStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantChannelListingStore) FilterbyOption(transaction store_iface.SqlxTxExecutor, option *model.ProductVariantChannelListingFilterOption) ([]*model.ProductVariantChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantChannelListingStore.FilterbyOption(transaction, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantChannelListingStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantChannelListingStore) Get(variantChannelListingID string) (*model.ProductVariantChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantChannelListingStore.Get(variantChannelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantChannelListingStore) Save(variantChannelListing *model.ProductVariantChannelListing) (*model.ProductVariantChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantChannelListingStore.Save(variantChannelListing)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantChannelListingStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantTranslationStore) FilterByOption(option *model.ProductVariantTranslationFilterOption) ([]*model.ProductVariantTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantTranslationStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantTranslationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantTranslationStore) Get(translationID string) (*model.ProductVariantTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantTranslationStore.Get(translationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerProductVariantTranslationStore) Upsert(translation *model.ProductVariantTranslation) (*model.ProductVariantTranslation, error) {
	start := timemodule.Now()

	result, err := s.ProductVariantTranslationStore.Upsert(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ProductVariantTranslationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Delete(roleID string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Delete(roleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Delete", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) Get(roleID string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Get(roleID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetAll() ([]*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByName(ctx context.Context, name string) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetByName(ctx, name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) GetByNames(names []string) ([]*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.GetByNames(names)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.GetByNames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerRoleStore) PermanentDeleteAll() error {
	start := timemodule.Now()

	err := s.RoleStore.PermanentDeleteAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.PermanentDeleteAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerRoleStore) Save(role *model.Role) (*model.Role, error) {
	start := timemodule.Now()

	result, err := s.RoleStore.Save(role)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("RoleStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleCategoryRelationStore) Get(relationID string) (*model.SaleCategoryRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleCategoryRelationStore.Get(relationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleCategoryRelationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleCategoryRelationStore) SaleCategoriesByOption(option *model.SaleCategoryRelationFilterOption) ([]*model.SaleCategoryRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleCategoryRelationStore.SaleCategoriesByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleCategoryRelationStore.SaleCategoriesByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleCategoryRelationStore) Save(relation *model.SaleCategoryRelation) (*model.SaleCategoryRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleCategoryRelationStore.Save(relation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleCategoryRelationStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleCollectionRelationStore) FilterByOption(option *model.SaleCollectionRelationFilterOption) ([]*model.SaleCollectionRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleCollectionRelationStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleCollectionRelationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleCollectionRelationStore) Get(relationID string) (*model.SaleCollectionRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleCollectionRelationStore.Get(relationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleCollectionRelationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleCollectionRelationStore) Save(relation *model.SaleCollectionRelation) (*model.SaleCollectionRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleCollectionRelationStore.Save(relation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleCollectionRelationStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleProductRelationStore) Get(relationID string) (*model.SaleProductRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleProductRelationStore.Get(relationID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleProductRelationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleProductRelationStore) SaleProductsByOption(option *model.SaleProductRelationFilterOption) ([]*model.SaleProductRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleProductRelationStore.SaleProductsByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleProductRelationStore.SaleProductsByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleProductRelationStore) Save(relation *model.SaleProductRelation) (*model.SaleProductRelation, error) {
	start := timemodule.Now()

	result, err := s.SaleProductRelationStore.Save(relation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleProductRelationStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleProductVariantStore) FilterByOption(options *model.SaleProductVariantFilterOption) ([]*model.SaleProductVariant, error) {
	start := timemodule.Now()

	result, err := s.SaleProductVariantStore.FilterByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleProductVariantStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSaleProductVariantStore) Upsert(relation *model.SaleProductVariant) (*model.SaleProductVariant, error) {
	start := timemodule.Now()

	result, err := s.SaleProductVariantStore.Upsert(relation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SaleProductVariantStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) AnalyticsSessionCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.AnalyticsSessionCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.AnalyticsSessionCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {
	start := timemodule.Now()

	s.SessionStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerSessionStore) Get(ctx context.Context, sessionIDOrToken string) (*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.Get(ctx, sessionIDOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessions(userID string) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessions(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsExpired", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) GetSessionsWithActiveDeviceIds(userID string) ([]*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.GetSessionsWithActiveDeviceIds(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.GetSessionsWithActiveDeviceIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) PermanentDeleteSessionsByUser(teamID string) error {
	start := timemodule.Now()

	err := s.SessionStore.PermanentDeleteSessionsByUser(teamID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.PermanentDeleteSessionsByUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Remove(sessionIDOrToken string) error {
	start := timemodule.Now()

	err := s.SessionStore.Remove(sessionIDOrToken)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Remove", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) RemoveAllSessions() error {
	start := timemodule.Now()

	err := s.SessionStore.RemoveAllSessions()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.RemoveAllSessions", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) Save(session *model.Session) (*model.Session, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.Save(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateDeviceId(id string, deviceID string, expiresAt int64) (string, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.UpdateDeviceId(id, deviceID, expiresAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateDeviceId", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateExpiredNotify(sessionid, notified)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiredNotify", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateExpiresAt(sessionID string, time int64) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateExpiresAt(sessionID, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateExpiresAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateLastActivityAt(sessionID string, time int64) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateLastActivityAt(sessionID, time)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateProps(session *model.Session) error {
	start := timemodule.Now()

	err := s.SessionStore.UpdateProps(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateProps", success, elapsed)
	}
	return err
}

func (s *TimerLayerSessionStore) UpdateRoles(userID string, roles string) (string, error) {
	start := timemodule.Now()

	result, err := s.SessionStore.UpdateRoles(userID, roles)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SessionStore.UpdateRoles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) ApplicableShippingMethods(price *goprices.Money, channelID string, weight *measurement.Weight, countryCode string, productIDs []string) ([]*model.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.ApplicableShippingMethods(price, channelID, weight, countryCode, productIDs)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.ApplicableShippingMethods", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) FilterByOptions(options *model.ShippingMethodFilterOption) ([]*model.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) Get(methodID string) (*model.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.Get(methodID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) GetbyOption(options *model.ShippingMethodFilterOption) (*model.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.GetbyOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.GetbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodStore) Upsert(method *model.ShippingMethod) (*model.ShippingMethod, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodStore.Upsert(method)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodChannelListingStore) FilterByOption(option *model.ShippingMethodChannelListingFilterOption) ([]*model.ShippingMethodChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodChannelListingStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodChannelListingStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodChannelListingStore) Get(listingID string) (*model.ShippingMethodChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodChannelListingStore.Get(listingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodChannelListingStore) Upsert(listing *model.ShippingMethodChannelListing) (*model.ShippingMethodChannelListing, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodChannelListingStore.Upsert(listing)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodChannelListingStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodExcludedProductStore) Get(id string) (*model.ShippingMethodExcludedProduct, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodExcludedProductStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodExcludedProductStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodExcludedProductStore) Save(instance *model.ShippingMethodExcludedProduct) (*model.ShippingMethodExcludedProduct, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodExcludedProductStore.Save(instance)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodExcludedProductStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingMethodPostalCodeRuleStore) FilterByOptions(options *model.ShippingMethodPostalCodeRuleFilterOptions) ([]*model.ShippingMethodPostalCodeRule, error) {
	start := timemodule.Now()

	result, err := s.ShippingMethodPostalCodeRuleStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingMethodPostalCodeRuleStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) CountByOptions(options *model.ShippingZoneFilterOption) (int64, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.CountByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.CountByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) FilterByOption(option *model.ShippingZoneFilterOption) ([]*model.ShippingZone, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) Get(shippingZoneID string) (*model.ShippingZone, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.Get(shippingZoneID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneStore) Upsert(shippingZone *model.ShippingZone) (*model.ShippingZone, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneStore.Upsert(shippingZone)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShippingZoneChannelStore) FilterByOptions(options *model.ShippingZoneChannelFilterOptions) ([]*model.ShippingZoneChannel, error) {
	start := timemodule.Now()

	result, err := s.ShippingZoneChannelStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShippingZoneChannelStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStore) FilterByOptions(options *model.ShopFilterOptions) ([]*model.Shop, error) {
	start := timemodule.Now()

	result, err := s.ShopStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStore) Get(shopID string) (*model.Shop, error) {
	start := timemodule.Now()

	result, err := s.ShopStore.Get(shopID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStore) GetByOptions(options *model.ShopFilterOptions) (*model.Shop, error) {
	start := timemodule.Now()

	result, err := s.ShopStore.GetByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStore.GetByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStore) Upsert(shop *model.Shop) (*model.Shop, error) {
	start := timemodule.Now()

	result, err := s.ShopStore.Upsert(shop)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) FilterByShopAndStaff(shopID string, staffID string) (*model.ShopStaffRelation, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.FilterByShopAndStaff(shopID, staffID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.FilterByShopAndStaff", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) Get(shopStaffID string) (*model.ShopStaffRelation, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.Get(shopStaffID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopStaffStore) Save(shopStaff *model.ShopStaffRelation) (*model.ShopStaffRelation, error) {
	start := timemodule.Now()

	result, err := s.ShopStaffStore.Save(shopStaff)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopStaffStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopTranslationStore) Get(id string) (*model.ShopTranslation, error) {
	start := timemodule.Now()

	result, err := s.ShopTranslationStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerShopTranslationStore) Upsert(translation *model.ShopTranslation) (*model.ShopTranslation, error) {
	start := timemodule.Now()

	result, err := s.ShopTranslationStore.Upsert(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("ShopTranslationStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStaffNotificationRecipientStore) Get(id string) (*model.StaffNotificationRecipient, error) {
	start := timemodule.Now()

	result, err := s.StaffNotificationRecipientStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StaffNotificationRecipientStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStaffNotificationRecipientStore) Save(notificationRecipient *model.StaffNotificationRecipient) (*model.StaffNotificationRecipient, error) {
	start := timemodule.Now()

	result, err := s.StaffNotificationRecipientStore.Save(notificationRecipient)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StaffNotificationRecipientStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) Get(userID string) (*model.Status, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.Get(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.GetByIds(userIds)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) GetTotalActiveUsersCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.StatusStore.GetTotalActiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.GetTotalActiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStatusStore) ResetAll() error {
	start := timemodule.Now()

	err := s.StatusStore.ResetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.ResetAll", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) SaveOrUpdate(status *model.Status) error {
	start := timemodule.Now()

	err := s.StatusStore.SaveOrUpdate(status)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerStatusStore) UpdateLastActivityAt(userID string, lastActivityAt int64) error {
	start := timemodule.Now()

	err := s.StatusStore.UpdateLastActivityAt(userID, lastActivityAt)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StatusStore.UpdateLastActivityAt", success, elapsed)
	}
	return err
}

func (s *TimerLayerStockStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, stocks []*model.Stock) ([]*model.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.BulkUpsert(transaction, stocks)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) ChangeQuantity(stockID string, quantity int) error {
	start := timemodule.Now()

	err := s.StockStore.ChangeQuantity(stockID, quantity)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.ChangeQuantity", success, elapsed)
	}
	return err
}

func (s *TimerLayerStockStore) FilterByOption(transaction store_iface.SqlxTxExecutor, options *model.StockFilterOption) ([]*model.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.FilterByOption(transaction, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) FilterForChannel(options *model.StockFilterForChannelOption) (squirrel.Sqlizer, []*model.Stock, error) {
	start := timemodule.Now()

	result, resultVar1, err := s.StockStore.FilterForChannel(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterForChannel", success, elapsed)
	}
	return result, resultVar1, err
}

func (s *TimerLayerStockStore) FilterForCountryAndChannel(transaction store_iface.SqlxTxExecutor, options *model.StockFilterForCountryAndChannel) ([]*model.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.FilterForCountryAndChannel(transaction, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterForCountryAndChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) FilterProductStocksForCountryAndChannel(transaction store_iface.SqlxTxExecutor, options *model.StockFilterForCountryAndChannel) ([]*model.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.FilterProductStocksForCountryAndChannel(transaction, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterProductStocksForCountryAndChannel", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) FilterVariantStocksForCountry(transaction store_iface.SqlxTxExecutor, options *model.StockFilterForCountryAndChannel) ([]*model.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.FilterVariantStocksForCountry(transaction, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.FilterVariantStocksForCountry", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerStockStore) Get(stockID string) (*model.Stock, error) {
	start := timemodule.Now()

	result, err := s.StockStore.Get(stockID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("StockStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) Get() (model.StringMap, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.Get()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) GetByName(name string) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.GetByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.GetByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) InsertIfExists(system *model.System) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.InsertIfExists(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.InsertIfExists", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) PermanentDeleteByName(name string) (*model.System, error) {
	start := timemodule.Now()

	result, err := s.SystemStore.PermanentDeleteByName(name)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.PermanentDeleteByName", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerSystemStore) Save(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.Save(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdate(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.SaveOrUpdate(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) SaveOrUpdateWithWarnMetricHandling(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.SaveOrUpdateWithWarnMetricHandling(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.SaveOrUpdateWithWarnMetricHandling", success, elapsed)
	}
	return err
}

func (s *TimerLayerSystemStore) Update(system *model.System) error {
	start := timemodule.Now()

	err := s.SystemStore.Update(system)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("SystemStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.Get(id, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.GetLatest(allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.GetLatest", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {
	start := timemodule.Now()

	result, err := s.TermsOfServiceStore.Save(termsOfService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TermsOfServiceStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) Cleanup() {
	start := timemodule.Now()

	s.TokenStore.Cleanup()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Cleanup", success, elapsed)
	}
}

func (s *TimerLayerTokenStore) Delete(token string) error {
	start := timemodule.Now()

	err := s.TokenStore.Delete(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) GetAllTokensByType(tokenType string) ([]*model.Token, error) {
	start := timemodule.Now()

	result, err := s.TokenStore.GetAllTokensByType(tokenType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetAllTokensByType", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) GetByToken(token string) (*model.Token, error) {
	start := timemodule.Now()

	result, err := s.TokenStore.GetByToken(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerTokenStore) RemoveAllTokensByType(tokenType string) error {
	start := timemodule.Now()

	err := s.TokenStore.RemoveAllTokensByType(tokenType)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.RemoveAllTokensByType", success, elapsed)
	}
	return err
}

func (s *TimerLayerTokenStore) Save(recovery *model.Token) error {
	start := timemodule.Now()

	err := s.TokenStore.Save(recovery)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("TokenStore.Save", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) Delete(id string) error {
	start := timemodule.Now()

	err := s.UploadSessionStore.Delete(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUploadSessionStore) Get(id string) (*model.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) GetForUser(userID string) ([]*model.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.GetForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.GetForUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Save(session *model.UploadSession) (*model.UploadSession, error) {
	start := timemodule.Now()

	result, err := s.UploadSessionStore.Save(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUploadSessionStore) Update(session *model.UploadSession) error {
	start := timemodule.Now()

	err := s.UploadSessionStore.Update(session)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UploadSessionStore.Update", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) AnalyticsActiveCount(time int64, options model.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsActiveCount(time, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsActiveCountForPeriod(startTime int64, endTime int64, options model.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsActiveCountForPeriod(startTime, endTime, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsActiveCountForPeriod", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetExternalUsers(hostDomain string) (bool, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetExternalUsers(hostDomain)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetExternalUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetGuestCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetGuestCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetGuestCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetInactiveUsersCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetInactiveUsersCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) AnalyticsGetSystemAdminCount() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.AnalyticsGetSystemAdminCount()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.AnalyticsGetSystemAdminCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ClearAllCustomRoleAssignments() error {
	start := timemodule.Now()

	err := s.UserStore.ClearAllCustomRoleAssignments()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearAllCustomRoleAssignments", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ClearCaches() {
	start := timemodule.Now()

	s.UserStore.ClearCaches()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ClearCaches", success, elapsed)
	}
}

func (s *TimerLayerUserStore) Count(options model.UserCountOptions) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Count(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Count", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Get(ctx context.Context, id string) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Get(ctx, id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAll() ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAll()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllAfter(limit int, afterID string) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllAfter(limit, afterID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllAfter", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllNotInAuthService(authServices []string) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllNotInAuthService(authServices)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllNotInAuthService", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetAllUsingAuthService(authService string) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetAllUsingAuthService(authService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetAllUsingAuthService", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByAuth(authData *string, authService string) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByAuth(authData, authService)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByAuth", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByEmail(email string) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByEmail(email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetByUsername(username string) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetByUsername(username)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetByUsername", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetEtagForAllProfiles() string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForAllProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForAllProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetEtagForProfiles(teamID string) string {
	start := timemodule.Now()

	result := s.UserStore.GetEtagForProfiles(teamID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetEtagForProfiles", success, elapsed)
	}
	return result
}

func (s *TimerLayerUserStore) GetForLogin(loginID string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetForLogin(loginID, allowSignInWithUsername, allowSignInWithEmail)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetForLogin", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetKnownUsers(userID string) ([]string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetKnownUsers(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetKnownUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetMany(ctx context.Context, ids []string) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetMany(ctx, ids)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetMany", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfileByIds(ctx context.Context, userIds []string, options *store.UserGetByIdsOpts, allowFromCache bool) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfileByIds(ctx, userIds, options, allowFromCache)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfileByIds", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfiles(options *model.UserGetOptions) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfiles(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetProfilesByUsernames(usernames []string) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetProfilesByUsernames(usernames)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetProfilesByUsernames", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetSystemAdminProfiles()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetSystemAdminProfiles", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUnreadCount(userID string) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetUnreadCount(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUnreadCount", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.UserForIndexing, error) {
	start := timemodule.Now()

	result, err := s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.GetUsersBatchForIndexing", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InferSystemInstallDate() (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.InferSystemInstallDate()

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InferSystemInstallDate", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) InvalidateProfileCacheForUser(userID string) {
	start := timemodule.Now()

	s.UserStore.InvalidateProfileCacheForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if true {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.InvalidateProfileCacheForUser", success, elapsed)
	}
}

func (s *TimerLayerUserStore) PermanentDelete(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.PermanentDelete(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.PermanentDelete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) ResetAuthDataToEmailForUsers(service string, userIDs []string, includeDeleted bool, dryRun bool) (int, error) {
	start := timemodule.Now()

	result, err := s.UserStore.ResetAuthDataToEmailForUsers(service, userIDs, includeDeleted, dryRun)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetAuthDataToEmailForUsers", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) ResetLastPictureUpdate(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.ResetLastPictureUpdate(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.ResetLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) Save(user *model.User) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Save(user)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Search(term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Search(term, options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) Update(user *model.User, allowRoleUpdate bool) (*model.UserUpdate, error) {
	start := timemodule.Now()

	result, err := s.UserStore.Update(user, allowRoleUpdate)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.Update", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateAuthData(userID string, service string, authData *string, email string, resetMfa bool) (string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.UpdateAuthData(userID, service, authData, email, resetMfa)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateAuthData", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UpdateFailedPasswordAttempts(userID string, attempts int) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateFailedPasswordAttempts(userID, attempts)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateFailedPasswordAttempts", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateLastPictureUpdate(userID string) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateLastPictureUpdate(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateLastPictureUpdate", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaActive(userID string, active bool) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateMfaActive(userID, active)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaActive", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateMfaSecret(userID string, secret string) error {
	start := timemodule.Now()

	err := s.UserStore.UpdateMfaSecret(userID, secret)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateMfaSecret", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdatePassword(userID string, newPassword string) error {
	start := timemodule.Now()

	err := s.UserStore.UpdatePassword(userID, newPassword)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdatePassword", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserStore) UpdateUpdateAt(userID string) (int64, error) {
	start := timemodule.Now()

	result, err := s.UserStore.UpdateUpdateAt(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UpdateUpdateAt", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) UserByOrderID(orderID string) (*model.User, error) {
	start := timemodule.Now()

	result, err := s.UserStore.UserByOrderID(orderID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.UserByOrderID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserStore) VerifyEmail(userID string, email string) (string, error) {
	start := timemodule.Now()

	result, err := s.UserStore.VerifyEmail(userID, email)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserStore.VerifyEmail", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Delete(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.Delete(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Delete", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) DeleteAllForUser(userID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.DeleteAllForUser(userID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.DeleteAllForUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) Get(tokenID string) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Get(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetAll(offset, limit)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetAll", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetByToken(tokenString)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByToken", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) GetByUser(userID string, page int, perPage int) ([]*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.GetByUser(userID, page, perPage)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.GetByUser", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Save(token)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, error) {
	start := timemodule.Now()

	result, err := s.UserAccessTokenStore.Search(term)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.Search", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenDisable(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.UpdateTokenDisable(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenDisable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAccessTokenStore) UpdateTokenEnable(tokenID string) error {
	start := timemodule.Now()

	err := s.UserAccessTokenStore.UpdateTokenEnable(tokenID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAccessTokenStore.UpdateTokenEnable", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAddressStore) DeleteForUser(userID string, addressID string) error {
	start := timemodule.Now()

	err := s.UserAddressStore.DeleteForUser(userID, addressID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAddressStore.DeleteForUser", success, elapsed)
	}
	return err
}

func (s *TimerLayerUserAddressStore) FilterByOptions(options *model.UserAddressFilterOptions) ([]*model.UserAddress, error) {
	start := timemodule.Now()

	result, err := s.UserAddressStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAddressStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerUserAddressStore) Save(userAddress *model.UserAddress) (*model.UserAddress, error) {
	start := timemodule.Now()

	result, err := s.UserAddressStore.Save(userAddress)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("UserAddressStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVariantMediaStore) FilterByOptions(options *model.VariantMediaFilterOptions) ([]*model.VariantMedia, error) {
	start := timemodule.Now()

	result, err := s.VariantMediaStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VariantMediaStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCategoryStore) FilterByOptions(options *model.VoucherCategoryFilterOption) ([]*model.VoucherCategory, error) {
	start := timemodule.Now()

	result, err := s.VoucherCategoryStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCategoryStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCategoryStore) Get(voucherCategoryID string) (*model.VoucherCategory, error) {
	start := timemodule.Now()

	result, err := s.VoucherCategoryStore.Get(voucherCategoryID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCategoryStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCategoryStore) Upsert(voucherCategory *model.VoucherCategory) (*model.VoucherCategory, error) {
	start := timemodule.Now()

	result, err := s.VoucherCategoryStore.Upsert(voucherCategory)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCategoryStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) FilterbyOption(option *model.VoucherChannelListingFilterOption) ([]*model.VoucherChannelListing, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.FilterbyOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.FilterbyOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) Get(voucherChannelListingID string) (*model.VoucherChannelListing, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.Get(voucherChannelListingID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherChannelListingStore) Upsert(voucherChannelListing *model.VoucherChannelListing) (*model.VoucherChannelListing, error) {
	start := timemodule.Now()

	result, err := s.VoucherChannelListingStore.Upsert(voucherChannelListing)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherChannelListingStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCollectionStore) FilterByOptions(options *model.VoucherCollectionFilterOptions) ([]*model.VoucherCollection, error) {
	start := timemodule.Now()

	result, err := s.VoucherCollectionStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCollectionStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCollectionStore) Get(voucherCollectionID string) (*model.VoucherCollection, error) {
	start := timemodule.Now()

	result, err := s.VoucherCollectionStore.Get(voucherCollectionID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCollectionStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCollectionStore) Upsert(voucherCollection *model.VoucherCollection) (*model.VoucherCollection, error) {
	start := timemodule.Now()

	result, err := s.VoucherCollectionStore.Upsert(voucherCollection)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCollectionStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) DeleteInBulk(options *model.VoucherCustomerFilterOption) error {
	start := timemodule.Now()

	err := s.VoucherCustomerStore.DeleteInBulk(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.DeleteInBulk", success, elapsed)
	}
	return err
}

func (s *TimerLayerVoucherCustomerStore) FilterByOptions(options *model.VoucherCustomerFilterOption) ([]*model.VoucherCustomer, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) GetByOption(options *model.VoucherCustomerFilterOption) (*model.VoucherCustomer, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.GetByOption(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherCustomerStore) Save(voucherCustomer *model.VoucherCustomer) (*model.VoucherCustomer, error) {
	start := timemodule.Now()

	result, err := s.VoucherCustomerStore.Save(voucherCustomer)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherCustomerStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherProductStore) FilterByOptions(options *model.VoucherProductFilterOptions) ([]*model.VoucherProduct, error) {
	start := timemodule.Now()

	result, err := s.VoucherProductStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherProductStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherProductStore) Get(voucherProductID string) (*model.VoucherProduct, error) {
	start := timemodule.Now()

	result, err := s.VoucherProductStore.Get(voucherProductID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherProductStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherProductStore) Upsert(voucherProduct *model.VoucherProduct) (*model.VoucherProduct, error) {
	start := timemodule.Now()

	result, err := s.VoucherProductStore.Upsert(voucherProduct)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherProductStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherProductVariantStore) FilterByOptions(options *model.VoucherProductVariantFilterOption) ([]*model.VoucherProductVariant, error) {
	start := timemodule.Now()

	result, err := s.VoucherProductVariantStore.FilterByOptions(options)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherProductVariantStore.FilterByOptions", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherTranslationStore) FilterByOption(option *model.VoucherTranslationFilterOption) ([]*model.VoucherTranslation, error) {
	start := timemodule.Now()

	result, err := s.VoucherTranslationStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherTranslationStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherTranslationStore) Get(id string) (*model.VoucherTranslation, error) {
	start := timemodule.Now()

	result, err := s.VoucherTranslationStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherTranslationStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherTranslationStore) GetByOption(option *model.VoucherTranslationFilterOption) (*model.VoucherTranslation, error) {
	start := timemodule.Now()

	result, err := s.VoucherTranslationStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherTranslationStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerVoucherTranslationStore) Save(translation *model.VoucherTranslation) (*model.VoucherTranslation, error) {
	start := timemodule.Now()

	result, err := s.VoucherTranslationStore.Save(translation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("VoucherTranslationStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) ApplicableForClickAndCollect(checkoutLines model.CheckoutLines, country string) (model.Warehouses, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.ApplicableForClickAndCollect(checkoutLines, country)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.ApplicableForClickAndCollect", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) ApplicableForClickAndCollectNoQuantityCheck(checkoutLines model.CheckoutLines, country string) (model.Warehouses, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.ApplicableForClickAndCollectNoQuantityCheck(checkoutLines, country)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.ApplicableForClickAndCollectNoQuantityCheck", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) FilterByOprion(option *model.WarehouseFilterOption) ([]*model.WareHouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.FilterByOprion(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.FilterByOprion", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) Get(id string) (*model.WareHouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.Get(id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.Get", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) GetByOption(option *model.WarehouseFilterOption) (*model.WareHouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) Save(model *model.WareHouse) (*model.WareHouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.Save(model)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseStore) WarehouseByStockID(stockID string) (*model.WareHouse, error) {
	start := timemodule.Now()

	result, err := s.WarehouseStore.WarehouseByStockID(stockID)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseStore.WarehouseByStockID", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWarehouseShippingZoneStore) Save(warehouseShippingZone *model.WarehouseShippingZone) (*model.WarehouseShippingZone, error) {
	start := timemodule.Now()

	result, err := s.WarehouseShippingZoneStore.Save(warehouseShippingZone)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WarehouseShippingZoneStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistStore) GetByOption(option *model.WishlistFilterOption) (*model.Wishlist, error) {
	start := timemodule.Now()

	result, err := s.WishlistStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistStore) Upsert(wishList *model.Wishlist) (*model.Wishlist, error) {
	start := timemodule.Now()

	result, err := s.WishlistStore.Upsert(wishList)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistStore.Upsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, wishlistItems model.WishlistItems) (model.WishlistItems, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.BulkUpsert(transaction, wishlistItems)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) DeleteItemsByOption(transaction store_iface.SqlxTxExecutor, option *model.WishlistItemFilterOption) (int64, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.DeleteItemsByOption(transaction, option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.DeleteItemsByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) FilterByOption(option *model.WishlistItemFilterOption) ([]*model.WishlistItem, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.FilterByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.FilterByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) GetById(selector store_iface.SqlxTxExecutor, id string) (*model.WishlistItem, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.GetById(selector, id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemStore) GetByOption(option *model.WishlistItemFilterOption) (*model.WishlistItem, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemStore.GetByOption(option)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemStore.GetByOption", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemProductVariantStore) BulkUpsert(transaction store_iface.SqlxTxExecutor, relations []*model.WishlistItemProductVariant) ([]*model.WishlistItemProductVariant, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemProductVariantStore.BulkUpsert(transaction, relations)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemProductVariantStore.BulkUpsert", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemProductVariantStore) DeleteRelation(relation *model.WishlistItemProductVariant) (int64, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemProductVariantStore.DeleteRelation(relation)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemProductVariantStore.DeleteRelation", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemProductVariantStore) GetById(selector store_iface.SqlxTxExecutor, id string) (*model.WishlistItemProductVariant, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemProductVariantStore.GetById(selector, id)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemProductVariantStore.GetById", success, elapsed)
	}
	return result, err
}

func (s *TimerLayerWishlistItemProductVariantStore) Save(wishlistVariant *model.WishlistItemProductVariant) (*model.WishlistItemProductVariant, error) {
	start := timemodule.Now()

	result, err := s.WishlistItemProductVariantStore.Save(wishlistVariant)

	elapsed := float64(timemodule.Since(start)) / float64(timemodule.Second)
	if s.Root.Metrics != nil {
		success := "false"
		if err == nil {
			success = "true"
		}
		s.Root.Metrics.ObserveStoreMethodDuration("WishlistItemProductVariantStore.Save", success, elapsed)
	}
	return result, err
}

func (s *TimerLayer) Close() {
	s.Store.Close()
}

func (s *TimerLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *TimerLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *TimerLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *TimerLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *TimerLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func New(childStore store.Store, metrics einterfaces.MetricsInterface) *TimerLayer {
	newStore := TimerLayer{
		Store:   childStore,
		Metrics: metrics,
	}

	newStore.AddressStore = &TimerLayerAddressStore{AddressStore: childStore.Address(), Root: &newStore}
	newStore.AllocationStore = &TimerLayerAllocationStore{AllocationStore: childStore.Allocation(), Root: &newStore}
	newStore.AppStore = &TimerLayerAppStore{AppStore: childStore.App(), Root: &newStore}
	newStore.AppTokenStore = &TimerLayerAppTokenStore{AppTokenStore: childStore.AppToken(), Root: &newStore}
	newStore.AssignedPageAttributeStore = &TimerLayerAssignedPageAttributeStore{AssignedPageAttributeStore: childStore.AssignedPageAttribute(), Root: &newStore}
	newStore.AssignedPageAttributeValueStore = &TimerLayerAssignedPageAttributeValueStore{AssignedPageAttributeValueStore: childStore.AssignedPageAttributeValue(), Root: &newStore}
	newStore.AssignedProductAttributeStore = &TimerLayerAssignedProductAttributeStore{AssignedProductAttributeStore: childStore.AssignedProductAttribute(), Root: &newStore}
	newStore.AssignedProductAttributeValueStore = &TimerLayerAssignedProductAttributeValueStore{AssignedProductAttributeValueStore: childStore.AssignedProductAttributeValue(), Root: &newStore}
	newStore.AssignedVariantAttributeStore = &TimerLayerAssignedVariantAttributeStore{AssignedVariantAttributeStore: childStore.AssignedVariantAttribute(), Root: &newStore}
	newStore.AssignedVariantAttributeValueStore = &TimerLayerAssignedVariantAttributeValueStore{AssignedVariantAttributeValueStore: childStore.AssignedVariantAttributeValue(), Root: &newStore}
	newStore.AttributeStore = &TimerLayerAttributeStore{AttributeStore: childStore.Attribute(), Root: &newStore}
	newStore.AttributePageStore = &TimerLayerAttributePageStore{AttributePageStore: childStore.AttributePage(), Root: &newStore}
	newStore.AttributeProductStore = &TimerLayerAttributeProductStore{AttributeProductStore: childStore.AttributeProduct(), Root: &newStore}
	newStore.AttributeTranslationStore = &TimerLayerAttributeTranslationStore{AttributeTranslationStore: childStore.AttributeTranslation(), Root: &newStore}
	newStore.AttributeValueStore = &TimerLayerAttributeValueStore{AttributeValueStore: childStore.AttributeValue(), Root: &newStore}
	newStore.AttributeValueTranslationStore = &TimerLayerAttributeValueTranslationStore{AttributeValueTranslationStore: childStore.AttributeValueTranslation(), Root: &newStore}
	newStore.AttributeVariantStore = &TimerLayerAttributeVariantStore{AttributeVariantStore: childStore.AttributeVariant(), Root: &newStore}
	newStore.AuditStore = &TimerLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.CategoryStore = &TimerLayerCategoryStore{CategoryStore: childStore.Category(), Root: &newStore}
	newStore.CategoryTranslationStore = &TimerLayerCategoryTranslationStore{CategoryTranslationStore: childStore.CategoryTranslation(), Root: &newStore}
	newStore.ChannelStore = &TimerLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.CheckoutStore = &TimerLayerCheckoutStore{CheckoutStore: childStore.Checkout(), Root: &newStore}
	newStore.CheckoutLineStore = &TimerLayerCheckoutLineStore{CheckoutLineStore: childStore.CheckoutLine(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &TimerLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CollectionStore = &TimerLayerCollectionStore{CollectionStore: childStore.Collection(), Root: &newStore}
	newStore.CollectionChannelListingStore = &TimerLayerCollectionChannelListingStore{CollectionChannelListingStore: childStore.CollectionChannelListing(), Root: &newStore}
	newStore.CollectionProductStore = &TimerLayerCollectionProductStore{CollectionProductStore: childStore.CollectionProduct(), Root: &newStore}
	newStore.CollectionTranslationStore = &TimerLayerCollectionTranslationStore{CollectionTranslationStore: childStore.CollectionTranslation(), Root: &newStore}
	newStore.ComplianceStore = &TimerLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.CsvExportEventStore = &TimerLayerCsvExportEventStore{CsvExportEventStore: childStore.CsvExportEvent(), Root: &newStore}
	newStore.CsvExportFileStore = &TimerLayerCsvExportFileStore{CsvExportFileStore: childStore.CsvExportFile(), Root: &newStore}
	newStore.CustomerEventStore = &TimerLayerCustomerEventStore{CustomerEventStore: childStore.CustomerEvent(), Root: &newStore}
	newStore.CustomerNoteStore = &TimerLayerCustomerNoteStore{CustomerNoteStore: childStore.CustomerNote(), Root: &newStore}
	newStore.DigitalContentStore = &TimerLayerDigitalContentStore{DigitalContentStore: childStore.DigitalContent(), Root: &newStore}
	newStore.DigitalContentUrlStore = &TimerLayerDigitalContentUrlStore{DigitalContentUrlStore: childStore.DigitalContentUrl(), Root: &newStore}
	newStore.DiscountSaleStore = &TimerLayerDiscountSaleStore{DiscountSaleStore: childStore.DiscountSale(), Root: &newStore}
	newStore.DiscountSaleChannelListingStore = &TimerLayerDiscountSaleChannelListingStore{DiscountSaleChannelListingStore: childStore.DiscountSaleChannelListing(), Root: &newStore}
	newStore.DiscountSaleTranslationStore = &TimerLayerDiscountSaleTranslationStore{DiscountSaleTranslationStore: childStore.DiscountSaleTranslation(), Root: &newStore}
	newStore.DiscountVoucherStore = &TimerLayerDiscountVoucherStore{DiscountVoucherStore: childStore.DiscountVoucher(), Root: &newStore}
	newStore.FileInfoStore = &TimerLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.FulfillmentStore = &TimerLayerFulfillmentStore{FulfillmentStore: childStore.Fulfillment(), Root: &newStore}
	newStore.FulfillmentLineStore = &TimerLayerFulfillmentLineStore{FulfillmentLineStore: childStore.FulfillmentLine(), Root: &newStore}
	newStore.GiftCardStore = &TimerLayerGiftCardStore{GiftCardStore: childStore.GiftCard(), Root: &newStore}
	newStore.GiftCardCheckoutStore = &TimerLayerGiftCardCheckoutStore{GiftCardCheckoutStore: childStore.GiftCardCheckout(), Root: &newStore}
	newStore.GiftCardOrderStore = &TimerLayerGiftCardOrderStore{GiftCardOrderStore: childStore.GiftCardOrder(), Root: &newStore}
	newStore.GiftcardEventStore = &TimerLayerGiftcardEventStore{GiftcardEventStore: childStore.GiftcardEvent(), Root: &newStore}
	newStore.InvoiceStore = &TimerLayerInvoiceStore{InvoiceStore: childStore.Invoice(), Root: &newStore}
	newStore.InvoiceEventStore = &TimerLayerInvoiceEventStore{InvoiceEventStore: childStore.InvoiceEvent(), Root: &newStore}
	newStore.JobStore = &TimerLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.MenuStore = &TimerLayerMenuStore{MenuStore: childStore.Menu(), Root: &newStore}
	newStore.MenuItemStore = &TimerLayerMenuItemStore{MenuItemStore: childStore.MenuItem(), Root: &newStore}
	newStore.MenuItemTranslationStore = &TimerLayerMenuItemTranslationStore{MenuItemTranslationStore: childStore.MenuItemTranslation(), Root: &newStore}
	newStore.OpenExchangeRateStore = &TimerLayerOpenExchangeRateStore{OpenExchangeRateStore: childStore.OpenExchangeRate(), Root: &newStore}
	newStore.OrderStore = &TimerLayerOrderStore{OrderStore: childStore.Order(), Root: &newStore}
	newStore.OrderDiscountStore = &TimerLayerOrderDiscountStore{OrderDiscountStore: childStore.OrderDiscount(), Root: &newStore}
	newStore.OrderEventStore = &TimerLayerOrderEventStore{OrderEventStore: childStore.OrderEvent(), Root: &newStore}
	newStore.OrderLineStore = &TimerLayerOrderLineStore{OrderLineStore: childStore.OrderLine(), Root: &newStore}
	newStore.PageStore = &TimerLayerPageStore{PageStore: childStore.Page(), Root: &newStore}
	newStore.PageTranslationStore = &TimerLayerPageTranslationStore{PageTranslationStore: childStore.PageTranslation(), Root: &newStore}
	newStore.PageTypeStore = &TimerLayerPageTypeStore{PageTypeStore: childStore.PageType(), Root: &newStore}
	newStore.PaymentStore = &TimerLayerPaymentStore{PaymentStore: childStore.Payment(), Root: &newStore}
	newStore.PaymentTransactionStore = &TimerLayerPaymentTransactionStore{PaymentTransactionStore: childStore.PaymentTransaction(), Root: &newStore}
	newStore.PluginStore = &TimerLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PluginConfigurationStore = &TimerLayerPluginConfigurationStore{PluginConfigurationStore: childStore.PluginConfiguration(), Root: &newStore}
	newStore.PreferenceStore = &TimerLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.PreorderAllocationStore = &TimerLayerPreorderAllocationStore{PreorderAllocationStore: childStore.PreorderAllocation(), Root: &newStore}
	newStore.ProductStore = &TimerLayerProductStore{ProductStore: childStore.Product(), Root: &newStore}
	newStore.ProductChannelListingStore = &TimerLayerProductChannelListingStore{ProductChannelListingStore: childStore.ProductChannelListing(), Root: &newStore}
	newStore.ProductMediaStore = &TimerLayerProductMediaStore{ProductMediaStore: childStore.ProductMedia(), Root: &newStore}
	newStore.ProductTranslationStore = &TimerLayerProductTranslationStore{ProductTranslationStore: childStore.ProductTranslation(), Root: &newStore}
	newStore.ProductTypeStore = &TimerLayerProductTypeStore{ProductTypeStore: childStore.ProductType(), Root: &newStore}
	newStore.ProductVariantStore = &TimerLayerProductVariantStore{ProductVariantStore: childStore.ProductVariant(), Root: &newStore}
	newStore.ProductVariantChannelListingStore = &TimerLayerProductVariantChannelListingStore{ProductVariantChannelListingStore: childStore.ProductVariantChannelListing(), Root: &newStore}
	newStore.ProductVariantTranslationStore = &TimerLayerProductVariantTranslationStore{ProductVariantTranslationStore: childStore.ProductVariantTranslation(), Root: &newStore}
	newStore.RoleStore = &TimerLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SaleCategoryRelationStore = &TimerLayerSaleCategoryRelationStore{SaleCategoryRelationStore: childStore.SaleCategoryRelation(), Root: &newStore}
	newStore.SaleCollectionRelationStore = &TimerLayerSaleCollectionRelationStore{SaleCollectionRelationStore: childStore.SaleCollectionRelation(), Root: &newStore}
	newStore.SaleProductRelationStore = &TimerLayerSaleProductRelationStore{SaleProductRelationStore: childStore.SaleProductRelation(), Root: &newStore}
	newStore.SaleProductVariantStore = &TimerLayerSaleProductVariantStore{SaleProductVariantStore: childStore.SaleProductVariant(), Root: &newStore}
	newStore.SessionStore = &TimerLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.ShippingMethodStore = &TimerLayerShippingMethodStore{ShippingMethodStore: childStore.ShippingMethod(), Root: &newStore}
	newStore.ShippingMethodChannelListingStore = &TimerLayerShippingMethodChannelListingStore{ShippingMethodChannelListingStore: childStore.ShippingMethodChannelListing(), Root: &newStore}
	newStore.ShippingMethodExcludedProductStore = &TimerLayerShippingMethodExcludedProductStore{ShippingMethodExcludedProductStore: childStore.ShippingMethodExcludedProduct(), Root: &newStore}
	newStore.ShippingMethodPostalCodeRuleStore = &TimerLayerShippingMethodPostalCodeRuleStore{ShippingMethodPostalCodeRuleStore: childStore.ShippingMethodPostalCodeRule(), Root: &newStore}
	newStore.ShippingMethodTranslationStore = &TimerLayerShippingMethodTranslationStore{ShippingMethodTranslationStore: childStore.ShippingMethodTranslation(), Root: &newStore}
	newStore.ShippingZoneStore = &TimerLayerShippingZoneStore{ShippingZoneStore: childStore.ShippingZone(), Root: &newStore}
	newStore.ShippingZoneChannelStore = &TimerLayerShippingZoneChannelStore{ShippingZoneChannelStore: childStore.ShippingZoneChannel(), Root: &newStore}
	newStore.ShopStore = &TimerLayerShopStore{ShopStore: childStore.Shop(), Root: &newStore}
	newStore.ShopStaffStore = &TimerLayerShopStaffStore{ShopStaffStore: childStore.ShopStaff(), Root: &newStore}
	newStore.ShopTranslationStore = &TimerLayerShopTranslationStore{ShopTranslationStore: childStore.ShopTranslation(), Root: &newStore}
	newStore.StaffNotificationRecipientStore = &TimerLayerStaffNotificationRecipientStore{StaffNotificationRecipientStore: childStore.StaffNotificationRecipient(), Root: &newStore}
	newStore.StatusStore = &TimerLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.StockStore = &TimerLayerStockStore{StockStore: childStore.Stock(), Root: &newStore}
	newStore.SystemStore = &TimerLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TermsOfServiceStore = &TimerLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &TimerLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UploadSessionStore = &TimerLayerUploadSessionStore{UploadSessionStore: childStore.UploadSession(), Root: &newStore}
	newStore.UserStore = &TimerLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &TimerLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserAddressStore = &TimerLayerUserAddressStore{UserAddressStore: childStore.UserAddress(), Root: &newStore}
	newStore.VariantMediaStore = &TimerLayerVariantMediaStore{VariantMediaStore: childStore.VariantMedia(), Root: &newStore}
	newStore.VoucherCategoryStore = &TimerLayerVoucherCategoryStore{VoucherCategoryStore: childStore.VoucherCategory(), Root: &newStore}
	newStore.VoucherChannelListingStore = &TimerLayerVoucherChannelListingStore{VoucherChannelListingStore: childStore.VoucherChannelListing(), Root: &newStore}
	newStore.VoucherCollectionStore = &TimerLayerVoucherCollectionStore{VoucherCollectionStore: childStore.VoucherCollection(), Root: &newStore}
	newStore.VoucherCustomerStore = &TimerLayerVoucherCustomerStore{VoucherCustomerStore: childStore.VoucherCustomer(), Root: &newStore}
	newStore.VoucherProductStore = &TimerLayerVoucherProductStore{VoucherProductStore: childStore.VoucherProduct(), Root: &newStore}
	newStore.VoucherProductVariantStore = &TimerLayerVoucherProductVariantStore{VoucherProductVariantStore: childStore.VoucherProductVariant(), Root: &newStore}
	newStore.VoucherTranslationStore = &TimerLayerVoucherTranslationStore{VoucherTranslationStore: childStore.VoucherTranslation(), Root: &newStore}
	newStore.WarehouseStore = &TimerLayerWarehouseStore{WarehouseStore: childStore.Warehouse(), Root: &newStore}
	newStore.WarehouseShippingZoneStore = &TimerLayerWarehouseShippingZoneStore{WarehouseShippingZoneStore: childStore.WarehouseShippingZone(), Root: &newStore}
	newStore.WishlistStore = &TimerLayerWishlistStore{WishlistStore: childStore.Wishlist(), Root: &newStore}
	newStore.WishlistItemStore = &TimerLayerWishlistItemStore{WishlistItemStore: childStore.WishlistItem(), Root: &newStore}
	newStore.WishlistItemProductVariantStore = &TimerLayerWishlistItemProductVariantStore{WishlistItemProductVariantStore: childStore.WishlistItemProductVariant(), Root: &newStore}
	return &newStore
}
