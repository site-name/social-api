// Code generated by "make store-layers"
// DO NOT EDIT

package retrylayer

import (
	"context"
	timemodule "time"

	"github.com/Masterminds/squirrel"
	"github.com/lib/pq"
	"github.com/pkg/errors"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/modules/measurement"
	"github.com/sitename/sitename/store"
	"github.com/sitename/sitename/store/store_iface"
	"gorm.io/gorm"
)

type RetryLayer struct {
	store.Store
	AddressStore                       store.AddressStore
	AllocationStore                    store.AllocationStore
	AppStore                           store.AppStore
	AppTokenStore                      store.AppTokenStore
	AssignedPageAttributeStore         store.AssignedPageAttributeStore
	AssignedPageAttributeValueStore    store.AssignedPageAttributeValueStore
	AssignedProductAttributeStore      store.AssignedProductAttributeStore
	AssignedProductAttributeValueStore store.AssignedProductAttributeValueStore
	AssignedVariantAttributeStore      store.AssignedVariantAttributeStore
	AssignedVariantAttributeValueStore store.AssignedVariantAttributeValueStore
	AttributeStore                     store.AttributeStore
	AttributePageStore                 store.AttributePageStore
	AttributeProductStore              store.AttributeProductStore
	AttributeTranslationStore          store.AttributeTranslationStore
	AttributeValueStore                store.AttributeValueStore
	AttributeValueTranslationStore     store.AttributeValueTranslationStore
	AttributeVariantStore              store.AttributeVariantStore
	AuditStore                         store.AuditStore
	CategoryStore                      store.CategoryStore
	CategoryTranslationStore           store.CategoryTranslationStore
	ChannelStore                       store.ChannelStore
	ChannelShopStore                   store.ChannelShopStore
	CheckoutStore                      store.CheckoutStore
	CheckoutLineStore                  store.CheckoutLineStore
	ClusterDiscoveryStore              store.ClusterDiscoveryStore
	CollectionStore                    store.CollectionStore
	CollectionChannelListingStore      store.CollectionChannelListingStore
	CollectionProductStore             store.CollectionProductStore
	CollectionTranslationStore         store.CollectionTranslationStore
	ComplianceStore                    store.ComplianceStore
	CsvExportEventStore                store.CsvExportEventStore
	CsvExportFileStore                 store.CsvExportFileStore
	CustomerEventStore                 store.CustomerEventStore
	CustomerNoteStore                  store.CustomerNoteStore
	DigitalContentStore                store.DigitalContentStore
	DigitalContentUrlStore             store.DigitalContentUrlStore
	DiscountSaleStore                  store.DiscountSaleStore
	DiscountSaleChannelListingStore    store.DiscountSaleChannelListingStore
	DiscountSaleTranslationStore       store.DiscountSaleTranslationStore
	DiscountVoucherStore               store.DiscountVoucherStore
	FileInfoStore                      store.FileInfoStore
	FulfillmentStore                   store.FulfillmentStore
	FulfillmentLineStore               store.FulfillmentLineStore
	GiftCardStore                      store.GiftCardStore
	GiftCardCheckoutStore              store.GiftCardCheckoutStore
	GiftCardOrderStore                 store.GiftCardOrderStore
	GiftcardEventStore                 store.GiftcardEventStore
	InvoiceStore                       store.InvoiceStore
	InvoiceEventStore                  store.InvoiceEventStore
	JobStore                           store.JobStore
	MenuStore                          store.MenuStore
	MenuItemStore                      store.MenuItemStore
	MenuItemTranslationStore           store.MenuItemTranslationStore
	OpenExchangeRateStore              store.OpenExchangeRateStore
	OrderStore                         store.OrderStore
	OrderDiscountStore                 store.OrderDiscountStore
	OrderEventStore                    store.OrderEventStore
	OrderLineStore                     store.OrderLineStore
	PageStore                          store.PageStore
	PageTranslationStore               store.PageTranslationStore
	PageTypeStore                      store.PageTypeStore
	PaymentStore                       store.PaymentStore
	PaymentTransactionStore            store.PaymentTransactionStore
	PluginStore                        store.PluginStore
	PluginConfigurationStore           store.PluginConfigurationStore
	PreferenceStore                    store.PreferenceStore
	PreorderAllocationStore            store.PreorderAllocationStore
	ProductStore                       store.ProductStore
	ProductChannelListingStore         store.ProductChannelListingStore
	ProductMediaStore                  store.ProductMediaStore
	ProductTranslationStore            store.ProductTranslationStore
	ProductTypeStore                   store.ProductTypeStore
	ProductVariantStore                store.ProductVariantStore
	ProductVariantChannelListingStore  store.ProductVariantChannelListingStore
	ProductVariantTranslationStore     store.ProductVariantTranslationStore
	RoleStore                          store.RoleStore
	SessionStore                       store.SessionStore
	ShippingMethodStore                store.ShippingMethodStore
	ShippingMethodChannelListingStore  store.ShippingMethodChannelListingStore
	ShippingMethodExcludedProductStore store.ShippingMethodExcludedProductStore
	ShippingMethodPostalCodeRuleStore  store.ShippingMethodPostalCodeRuleStore
	ShippingMethodTranslationStore     store.ShippingMethodTranslationStore
	ShippingZoneStore                  store.ShippingZoneStore
	ShippingZoneChannelStore           store.ShippingZoneChannelStore
	ShopStore                          store.ShopStore
	ShopStaffStore                     store.ShopStaffStore
	ShopTranslationStore               store.ShopTranslationStore
	StaffNotificationRecipientStore    store.StaffNotificationRecipientStore
	StatusStore                        store.StatusStore
	StockStore                         store.StockStore
	SystemStore                        store.SystemStore
	TermsOfServiceStore                store.TermsOfServiceStore
	TokenStore                         store.TokenStore
	UploadSessionStore                 store.UploadSessionStore
	UserStore                          store.UserStore
	UserAccessTokenStore               store.UserAccessTokenStore
	VatStore                           store.VatStore
	VoucherChannelListingStore         store.VoucherChannelListingStore
	VoucherCustomerStore               store.VoucherCustomerStore
	VoucherTranslationStore            store.VoucherTranslationStore
	WarehouseStore                     store.WarehouseStore
	WarehouseShippingZoneStore         store.WarehouseShippingZoneStore
	WishlistStore                      store.WishlistStore
	WishlistItemStore                  store.WishlistItemStore
	WishlistItemProductVariantStore    store.WishlistItemProductVariantStore
}

func (s *RetryLayer) Address() store.AddressStore {
	return s.AddressStore
}

func (s *RetryLayer) Allocation() store.AllocationStore {
	return s.AllocationStore
}

func (s *RetryLayer) App() store.AppStore {
	return s.AppStore
}

func (s *RetryLayer) AppToken() store.AppTokenStore {
	return s.AppTokenStore
}

func (s *RetryLayer) AssignedPageAttribute() store.AssignedPageAttributeStore {
	return s.AssignedPageAttributeStore
}

func (s *RetryLayer) AssignedPageAttributeValue() store.AssignedPageAttributeValueStore {
	return s.AssignedPageAttributeValueStore
}

func (s *RetryLayer) AssignedProductAttribute() store.AssignedProductAttributeStore {
	return s.AssignedProductAttributeStore
}

func (s *RetryLayer) AssignedProductAttributeValue() store.AssignedProductAttributeValueStore {
	return s.AssignedProductAttributeValueStore
}

func (s *RetryLayer) AssignedVariantAttribute() store.AssignedVariantAttributeStore {
	return s.AssignedVariantAttributeStore
}

func (s *RetryLayer) AssignedVariantAttributeValue() store.AssignedVariantAttributeValueStore {
	return s.AssignedVariantAttributeValueStore
}

func (s *RetryLayer) Attribute() store.AttributeStore {
	return s.AttributeStore
}

func (s *RetryLayer) AttributePage() store.AttributePageStore {
	return s.AttributePageStore
}

func (s *RetryLayer) AttributeProduct() store.AttributeProductStore {
	return s.AttributeProductStore
}

func (s *RetryLayer) AttributeTranslation() store.AttributeTranslationStore {
	return s.AttributeTranslationStore
}

func (s *RetryLayer) AttributeValue() store.AttributeValueStore {
	return s.AttributeValueStore
}

func (s *RetryLayer) AttributeValueTranslation() store.AttributeValueTranslationStore {
	return s.AttributeValueTranslationStore
}

func (s *RetryLayer) AttributeVariant() store.AttributeVariantStore {
	return s.AttributeVariantStore
}

func (s *RetryLayer) Audit() store.AuditStore {
	return s.AuditStore
}

func (s *RetryLayer) Category() store.CategoryStore {
	return s.CategoryStore
}

func (s *RetryLayer) CategoryTranslation() store.CategoryTranslationStore {
	return s.CategoryTranslationStore
}

func (s *RetryLayer) Channel() store.ChannelStore {
	return s.ChannelStore
}

func (s *RetryLayer) ChannelShop() store.ChannelShopStore {
	return s.ChannelShopStore
}

func (s *RetryLayer) Checkout() store.CheckoutStore {
	return s.CheckoutStore
}

func (s *RetryLayer) CheckoutLine() store.CheckoutLineStore {
	return s.CheckoutLineStore
}

func (s *RetryLayer) ClusterDiscovery() store.ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *RetryLayer) Collection() store.CollectionStore {
	return s.CollectionStore
}

func (s *RetryLayer) CollectionChannelListing() store.CollectionChannelListingStore {
	return s.CollectionChannelListingStore
}

func (s *RetryLayer) CollectionProduct() store.CollectionProductStore {
	return s.CollectionProductStore
}

func (s *RetryLayer) CollectionTranslation() store.CollectionTranslationStore {
	return s.CollectionTranslationStore
}

func (s *RetryLayer) Compliance() store.ComplianceStore {
	return s.ComplianceStore
}

func (s *RetryLayer) CsvExportEvent() store.CsvExportEventStore {
	return s.CsvExportEventStore
}

func (s *RetryLayer) CsvExportFile() store.CsvExportFileStore {
	return s.CsvExportFileStore
}

func (s *RetryLayer) CustomerEvent() store.CustomerEventStore {
	return s.CustomerEventStore
}

func (s *RetryLayer) CustomerNote() store.CustomerNoteStore {
	return s.CustomerNoteStore
}

func (s *RetryLayer) DigitalContent() store.DigitalContentStore {
	return s.DigitalContentStore
}

func (s *RetryLayer) DigitalContentUrl() store.DigitalContentUrlStore {
	return s.DigitalContentUrlStore
}

func (s *RetryLayer) DiscountSale() store.DiscountSaleStore {
	return s.DiscountSaleStore
}

func (s *RetryLayer) DiscountSaleChannelListing() store.DiscountSaleChannelListingStore {
	return s.DiscountSaleChannelListingStore
}

func (s *RetryLayer) DiscountSaleTranslation() store.DiscountSaleTranslationStore {
	return s.DiscountSaleTranslationStore
}

func (s *RetryLayer) DiscountVoucher() store.DiscountVoucherStore {
	return s.DiscountVoucherStore
}

func (s *RetryLayer) FileInfo() store.FileInfoStore {
	return s.FileInfoStore
}

func (s *RetryLayer) Fulfillment() store.FulfillmentStore {
	return s.FulfillmentStore
}

func (s *RetryLayer) FulfillmentLine() store.FulfillmentLineStore {
	return s.FulfillmentLineStore
}

func (s *RetryLayer) GiftCard() store.GiftCardStore {
	return s.GiftCardStore
}

func (s *RetryLayer) GiftCardCheckout() store.GiftCardCheckoutStore {
	return s.GiftCardCheckoutStore
}

func (s *RetryLayer) GiftCardOrder() store.GiftCardOrderStore {
	return s.GiftCardOrderStore
}

func (s *RetryLayer) GiftcardEvent() store.GiftcardEventStore {
	return s.GiftcardEventStore
}

func (s *RetryLayer) Invoice() store.InvoiceStore {
	return s.InvoiceStore
}

func (s *RetryLayer) InvoiceEvent() store.InvoiceEventStore {
	return s.InvoiceEventStore
}

func (s *RetryLayer) Job() store.JobStore {
	return s.JobStore
}

func (s *RetryLayer) Menu() store.MenuStore {
	return s.MenuStore
}

func (s *RetryLayer) MenuItem() store.MenuItemStore {
	return s.MenuItemStore
}

func (s *RetryLayer) MenuItemTranslation() store.MenuItemTranslationStore {
	return s.MenuItemTranslationStore
}

func (s *RetryLayer) OpenExchangeRate() store.OpenExchangeRateStore {
	return s.OpenExchangeRateStore
}

func (s *RetryLayer) Order() store.OrderStore {
	return s.OrderStore
}

func (s *RetryLayer) OrderDiscount() store.OrderDiscountStore {
	return s.OrderDiscountStore
}

func (s *RetryLayer) OrderEvent() store.OrderEventStore {
	return s.OrderEventStore
}

func (s *RetryLayer) OrderLine() store.OrderLineStore {
	return s.OrderLineStore
}

func (s *RetryLayer) Page() store.PageStore {
	return s.PageStore
}

func (s *RetryLayer) PageTranslation() store.PageTranslationStore {
	return s.PageTranslationStore
}

func (s *RetryLayer) PageType() store.PageTypeStore {
	return s.PageTypeStore
}

func (s *RetryLayer) Payment() store.PaymentStore {
	return s.PaymentStore
}

func (s *RetryLayer) PaymentTransaction() store.PaymentTransactionStore {
	return s.PaymentTransactionStore
}

func (s *RetryLayer) Plugin() store.PluginStore {
	return s.PluginStore
}

func (s *RetryLayer) PluginConfiguration() store.PluginConfigurationStore {
	return s.PluginConfigurationStore
}

func (s *RetryLayer) Preference() store.PreferenceStore {
	return s.PreferenceStore
}

func (s *RetryLayer) PreorderAllocation() store.PreorderAllocationStore {
	return s.PreorderAllocationStore
}

func (s *RetryLayer) Product() store.ProductStore {
	return s.ProductStore
}

func (s *RetryLayer) ProductChannelListing() store.ProductChannelListingStore {
	return s.ProductChannelListingStore
}

func (s *RetryLayer) ProductMedia() store.ProductMediaStore {
	return s.ProductMediaStore
}

func (s *RetryLayer) ProductTranslation() store.ProductTranslationStore {
	return s.ProductTranslationStore
}

func (s *RetryLayer) ProductType() store.ProductTypeStore {
	return s.ProductTypeStore
}

func (s *RetryLayer) ProductVariant() store.ProductVariantStore {
	return s.ProductVariantStore
}

func (s *RetryLayer) ProductVariantChannelListing() store.ProductVariantChannelListingStore {
	return s.ProductVariantChannelListingStore
}

func (s *RetryLayer) ProductVariantTranslation() store.ProductVariantTranslationStore {
	return s.ProductVariantTranslationStore
}

func (s *RetryLayer) Role() store.RoleStore {
	return s.RoleStore
}

func (s *RetryLayer) Session() store.SessionStore {
	return s.SessionStore
}

func (s *RetryLayer) ShippingMethod() store.ShippingMethodStore {
	return s.ShippingMethodStore
}

func (s *RetryLayer) ShippingMethodChannelListing() store.ShippingMethodChannelListingStore {
	return s.ShippingMethodChannelListingStore
}

func (s *RetryLayer) ShippingMethodExcludedProduct() store.ShippingMethodExcludedProductStore {
	return s.ShippingMethodExcludedProductStore
}

func (s *RetryLayer) ShippingMethodPostalCodeRule() store.ShippingMethodPostalCodeRuleStore {
	return s.ShippingMethodPostalCodeRuleStore
}

func (s *RetryLayer) ShippingMethodTranslation() store.ShippingMethodTranslationStore {
	return s.ShippingMethodTranslationStore
}

func (s *RetryLayer) ShippingZone() store.ShippingZoneStore {
	return s.ShippingZoneStore
}

func (s *RetryLayer) ShippingZoneChannel() store.ShippingZoneChannelStore {
	return s.ShippingZoneChannelStore
}

func (s *RetryLayer) Shop() store.ShopStore {
	return s.ShopStore
}

func (s *RetryLayer) ShopStaff() store.ShopStaffStore {
	return s.ShopStaffStore
}

func (s *RetryLayer) ShopTranslation() store.ShopTranslationStore {
	return s.ShopTranslationStore
}

func (s *RetryLayer) StaffNotificationRecipient() store.StaffNotificationRecipientStore {
	return s.StaffNotificationRecipientStore
}

func (s *RetryLayer) Status() store.StatusStore {
	return s.StatusStore
}

func (s *RetryLayer) Stock() store.StockStore {
	return s.StockStore
}

func (s *RetryLayer) System() store.SystemStore {
	return s.SystemStore
}

func (s *RetryLayer) TermsOfService() store.TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *RetryLayer) Token() store.TokenStore {
	return s.TokenStore
}

func (s *RetryLayer) UploadSession() store.UploadSessionStore {
	return s.UploadSessionStore
}

func (s *RetryLayer) User() store.UserStore {
	return s.UserStore
}

func (s *RetryLayer) UserAccessToken() store.UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *RetryLayer) Vat() store.VatStore {
	return s.VatStore
}

func (s *RetryLayer) VoucherChannelListing() store.VoucherChannelListingStore {
	return s.VoucherChannelListingStore
}

func (s *RetryLayer) VoucherCustomer() store.VoucherCustomerStore {
	return s.VoucherCustomerStore
}

func (s *RetryLayer) VoucherTranslation() store.VoucherTranslationStore {
	return s.VoucherTranslationStore
}

func (s *RetryLayer) Warehouse() store.WarehouseStore {
	return s.WarehouseStore
}

func (s *RetryLayer) WarehouseShippingZone() store.WarehouseShippingZoneStore {
	return s.WarehouseShippingZoneStore
}

func (s *RetryLayer) Wishlist() store.WishlistStore {
	return s.WishlistStore
}

func (s *RetryLayer) WishlistItem() store.WishlistItemStore {
	return s.WishlistItemStore
}

func (s *RetryLayer) WishlistItemProductVariant() store.WishlistItemProductVariantStore {
	return s.WishlistItemProductVariantStore
}

type RetryLayerAddressStore struct {
	store.AddressStore
	Root *RetryLayer
}

type RetryLayerAllocationStore struct {
	store.AllocationStore
	Root *RetryLayer
}

type RetryLayerAppStore struct {
	store.AppStore
	Root *RetryLayer
}

type RetryLayerAppTokenStore struct {
	store.AppTokenStore
	Root *RetryLayer
}

type RetryLayerAssignedPageAttributeStore struct {
	store.AssignedPageAttributeStore
	Root *RetryLayer
}

type RetryLayerAssignedPageAttributeValueStore struct {
	store.AssignedPageAttributeValueStore
	Root *RetryLayer
}

type RetryLayerAssignedProductAttributeStore struct {
	store.AssignedProductAttributeStore
	Root *RetryLayer
}

type RetryLayerAssignedProductAttributeValueStore struct {
	store.AssignedProductAttributeValueStore
	Root *RetryLayer
}

type RetryLayerAssignedVariantAttributeStore struct {
	store.AssignedVariantAttributeStore
	Root *RetryLayer
}

type RetryLayerAssignedVariantAttributeValueStore struct {
	store.AssignedVariantAttributeValueStore
	Root *RetryLayer
}

type RetryLayerAttributeStore struct {
	store.AttributeStore
	Root *RetryLayer
}

type RetryLayerAttributePageStore struct {
	store.AttributePageStore
	Root *RetryLayer
}

type RetryLayerAttributeProductStore struct {
	store.AttributeProductStore
	Root *RetryLayer
}

type RetryLayerAttributeTranslationStore struct {
	store.AttributeTranslationStore
	Root *RetryLayer
}

type RetryLayerAttributeValueStore struct {
	store.AttributeValueStore
	Root *RetryLayer
}

type RetryLayerAttributeValueTranslationStore struct {
	store.AttributeValueTranslationStore
	Root *RetryLayer
}

type RetryLayerAttributeVariantStore struct {
	store.AttributeVariantStore
	Root *RetryLayer
}

type RetryLayerAuditStore struct {
	store.AuditStore
	Root *RetryLayer
}

type RetryLayerCategoryStore struct {
	store.CategoryStore
	Root *RetryLayer
}

type RetryLayerCategoryTranslationStore struct {
	store.CategoryTranslationStore
	Root *RetryLayer
}

type RetryLayerChannelStore struct {
	store.ChannelStore
	Root *RetryLayer
}

type RetryLayerChannelShopStore struct {
	store.ChannelShopStore
	Root *RetryLayer
}

type RetryLayerCheckoutStore struct {
	store.CheckoutStore
	Root *RetryLayer
}

type RetryLayerCheckoutLineStore struct {
	store.CheckoutLineStore
	Root *RetryLayer
}

type RetryLayerClusterDiscoveryStore struct {
	store.ClusterDiscoveryStore
	Root *RetryLayer
}

type RetryLayerCollectionStore struct {
	store.CollectionStore
	Root *RetryLayer
}

type RetryLayerCollectionChannelListingStore struct {
	store.CollectionChannelListingStore
	Root *RetryLayer
}

type RetryLayerCollectionProductStore struct {
	store.CollectionProductStore
	Root *RetryLayer
}

type RetryLayerCollectionTranslationStore struct {
	store.CollectionTranslationStore
	Root *RetryLayer
}

type RetryLayerComplianceStore struct {
	store.ComplianceStore
	Root *RetryLayer
}

type RetryLayerCsvExportEventStore struct {
	store.CsvExportEventStore
	Root *RetryLayer
}

type RetryLayerCsvExportFileStore struct {
	store.CsvExportFileStore
	Root *RetryLayer
}

type RetryLayerCustomerEventStore struct {
	store.CustomerEventStore
	Root *RetryLayer
}

type RetryLayerCustomerNoteStore struct {
	store.CustomerNoteStore
	Root *RetryLayer
}

type RetryLayerDigitalContentStore struct {
	store.DigitalContentStore
	Root *RetryLayer
}

type RetryLayerDigitalContentUrlStore struct {
	store.DigitalContentUrlStore
	Root *RetryLayer
}

type RetryLayerDiscountSaleStore struct {
	store.DiscountSaleStore
	Root *RetryLayer
}

type RetryLayerDiscountSaleChannelListingStore struct {
	store.DiscountSaleChannelListingStore
	Root *RetryLayer
}

type RetryLayerDiscountSaleTranslationStore struct {
	store.DiscountSaleTranslationStore
	Root *RetryLayer
}

type RetryLayerDiscountVoucherStore struct {
	store.DiscountVoucherStore
	Root *RetryLayer
}

type RetryLayerFileInfoStore struct {
	store.FileInfoStore
	Root *RetryLayer
}

type RetryLayerFulfillmentStore struct {
	store.FulfillmentStore
	Root *RetryLayer
}

type RetryLayerFulfillmentLineStore struct {
	store.FulfillmentLineStore
	Root *RetryLayer
}

type RetryLayerGiftCardStore struct {
	store.GiftCardStore
	Root *RetryLayer
}

type RetryLayerGiftCardCheckoutStore struct {
	store.GiftCardCheckoutStore
	Root *RetryLayer
}

type RetryLayerGiftCardOrderStore struct {
	store.GiftCardOrderStore
	Root *RetryLayer
}

type RetryLayerGiftcardEventStore struct {
	store.GiftcardEventStore
	Root *RetryLayer
}

type RetryLayerInvoiceStore struct {
	store.InvoiceStore
	Root *RetryLayer
}

type RetryLayerInvoiceEventStore struct {
	store.InvoiceEventStore
	Root *RetryLayer
}

type RetryLayerJobStore struct {
	store.JobStore
	Root *RetryLayer
}

type RetryLayerMenuStore struct {
	store.MenuStore
	Root *RetryLayer
}

type RetryLayerMenuItemStore struct {
	store.MenuItemStore
	Root *RetryLayer
}

type RetryLayerMenuItemTranslationStore struct {
	store.MenuItemTranslationStore
	Root *RetryLayer
}

type RetryLayerOpenExchangeRateStore struct {
	store.OpenExchangeRateStore
	Root *RetryLayer
}

type RetryLayerOrderStore struct {
	store.OrderStore
	Root *RetryLayer
}

type RetryLayerOrderDiscountStore struct {
	store.OrderDiscountStore
	Root *RetryLayer
}

type RetryLayerOrderEventStore struct {
	store.OrderEventStore
	Root *RetryLayer
}

type RetryLayerOrderLineStore struct {
	store.OrderLineStore
	Root *RetryLayer
}

type RetryLayerPageStore struct {
	store.PageStore
	Root *RetryLayer
}

type RetryLayerPageTranslationStore struct {
	store.PageTranslationStore
	Root *RetryLayer
}

type RetryLayerPageTypeStore struct {
	store.PageTypeStore
	Root *RetryLayer
}

type RetryLayerPaymentStore struct {
	store.PaymentStore
	Root *RetryLayer
}

type RetryLayerPaymentTransactionStore struct {
	store.PaymentTransactionStore
	Root *RetryLayer
}

type RetryLayerPluginStore struct {
	store.PluginStore
	Root *RetryLayer
}

type RetryLayerPluginConfigurationStore struct {
	store.PluginConfigurationStore
	Root *RetryLayer
}

type RetryLayerPreferenceStore struct {
	store.PreferenceStore
	Root *RetryLayer
}

type RetryLayerPreorderAllocationStore struct {
	store.PreorderAllocationStore
	Root *RetryLayer
}

type RetryLayerProductStore struct {
	store.ProductStore
	Root *RetryLayer
}

type RetryLayerProductChannelListingStore struct {
	store.ProductChannelListingStore
	Root *RetryLayer
}

type RetryLayerProductMediaStore struct {
	store.ProductMediaStore
	Root *RetryLayer
}

type RetryLayerProductTranslationStore struct {
	store.ProductTranslationStore
	Root *RetryLayer
}

type RetryLayerProductTypeStore struct {
	store.ProductTypeStore
	Root *RetryLayer
}

type RetryLayerProductVariantStore struct {
	store.ProductVariantStore
	Root *RetryLayer
}

type RetryLayerProductVariantChannelListingStore struct {
	store.ProductVariantChannelListingStore
	Root *RetryLayer
}

type RetryLayerProductVariantTranslationStore struct {
	store.ProductVariantTranslationStore
	Root *RetryLayer
}

type RetryLayerRoleStore struct {
	store.RoleStore
	Root *RetryLayer
}

type RetryLayerSessionStore struct {
	store.SessionStore
	Root *RetryLayer
}

type RetryLayerShippingMethodStore struct {
	store.ShippingMethodStore
	Root *RetryLayer
}

type RetryLayerShippingMethodChannelListingStore struct {
	store.ShippingMethodChannelListingStore
	Root *RetryLayer
}

type RetryLayerShippingMethodExcludedProductStore struct {
	store.ShippingMethodExcludedProductStore
	Root *RetryLayer
}

type RetryLayerShippingMethodPostalCodeRuleStore struct {
	store.ShippingMethodPostalCodeRuleStore
	Root *RetryLayer
}

type RetryLayerShippingMethodTranslationStore struct {
	store.ShippingMethodTranslationStore
	Root *RetryLayer
}

type RetryLayerShippingZoneStore struct {
	store.ShippingZoneStore
	Root *RetryLayer
}

type RetryLayerShippingZoneChannelStore struct {
	store.ShippingZoneChannelStore
	Root *RetryLayer
}

type RetryLayerShopStore struct {
	store.ShopStore
	Root *RetryLayer
}

type RetryLayerShopStaffStore struct {
	store.ShopStaffStore
	Root *RetryLayer
}

type RetryLayerShopTranslationStore struct {
	store.ShopTranslationStore
	Root *RetryLayer
}

type RetryLayerStaffNotificationRecipientStore struct {
	store.StaffNotificationRecipientStore
	Root *RetryLayer
}

type RetryLayerStatusStore struct {
	store.StatusStore
	Root *RetryLayer
}

type RetryLayerStockStore struct {
	store.StockStore
	Root *RetryLayer
}

type RetryLayerSystemStore struct {
	store.SystemStore
	Root *RetryLayer
}

type RetryLayerTermsOfServiceStore struct {
	store.TermsOfServiceStore
	Root *RetryLayer
}

type RetryLayerTokenStore struct {
	store.TokenStore
	Root *RetryLayer
}

type RetryLayerUploadSessionStore struct {
	store.UploadSessionStore
	Root *RetryLayer
}

type RetryLayerUserStore struct {
	store.UserStore
	Root *RetryLayer
}

type RetryLayerUserAccessTokenStore struct {
	store.UserAccessTokenStore
	Root *RetryLayer
}

type RetryLayerVatStore struct {
	store.VatStore
	Root *RetryLayer
}

type RetryLayerVoucherChannelListingStore struct {
	store.VoucherChannelListingStore
	Root *RetryLayer
}

type RetryLayerVoucherCustomerStore struct {
	store.VoucherCustomerStore
	Root *RetryLayer
}

type RetryLayerVoucherTranslationStore struct {
	store.VoucherTranslationStore
	Root *RetryLayer
}

type RetryLayerWarehouseStore struct {
	store.WarehouseStore
	Root *RetryLayer
}

type RetryLayerWarehouseShippingZoneStore struct {
	store.WarehouseShippingZoneStore
	Root *RetryLayer
}

type RetryLayerWishlistStore struct {
	store.WishlistStore
	Root *RetryLayer
}

type RetryLayerWishlistItemStore struct {
	store.WishlistItemStore
	Root *RetryLayer
}

type RetryLayerWishlistItemProductVariantStore struct {
	store.WishlistItemProductVariantStore
	Root *RetryLayer
}

func isRepeatableError(err error) bool {
	var pqErr *pq.Error
	switch {
	case errors.As(errors.Cause(err), &pqErr):
		if pqErr.Code == "40001" || pqErr.Code == "40P01" {
			return true
		}
	}
	return false
}

func (s *RetryLayerAddressStore) DeleteAddresses(transaction *gorm.DB, addressIDs []string) *model.AppError {

	return s.AddressStore.DeleteAddresses(transaction, addressIDs)

}

func (s *RetryLayerAddressStore) FilterByOption(option *model.AddressFilterOption) ([]*model.Address, error) {

	tries := 0
	for {
		result, err := s.AddressStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAddressStore) Get(addressID string) (*model.Address, error) {

	tries := 0
	for {
		result, err := s.AddressStore.Get(addressID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAddressStore) Upsert(transaction *gorm.DB, address *model.Address) (*model.Address, error) {

	tries := 0
	for {
		result, err := s.AddressStore.Upsert(transaction, address)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAllocationStore) BulkDelete(transaction store_iface.SqlxExecutor, allocationIDs []string) error {

	tries := 0
	for {
		err := s.AllocationStore.BulkDelete(transaction, allocationIDs)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerAllocationStore) BulkUpsert(transaction store_iface.SqlxExecutor, allocations []*model.Allocation) ([]*model.Allocation, error) {

	tries := 0
	for {
		result, err := s.AllocationStore.BulkUpsert(transaction, allocations)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAllocationStore) CountAvailableQuantityForStock(stock *model.Stock) (int, error) {

	tries := 0
	for {
		result, err := s.AllocationStore.CountAvailableQuantityForStock(stock)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAllocationStore) FilterByOption(option *model.AllocationFilterOption) ([]*model.Allocation, error) {

	tries := 0
	for {
		result, err := s.AllocationStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAllocationStore) Get(allocationID string) (*model.Allocation, error) {

	tries := 0
	for {
		result, err := s.AllocationStore.Get(allocationID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAppStore) Save(app *model.App) (*model.App, error) {

	tries := 0
	for {
		result, err := s.AppStore.Save(app)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAppTokenStore) Save(appToken *model.AppToken) (*model.AppToken, error) {

	tries := 0
	for {
		result, err := s.AppTokenStore.Save(appToken)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedPageAttributeStore) Get(id string) (*model.AssignedPageAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedPageAttributeStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedPageAttributeStore) GetByOption(option *model.AssignedPageAttributeFilterOption) (*model.AssignedPageAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedPageAttributeStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedPageAttributeStore) Save(assignedPageAttr *model.AssignedPageAttribute) (*model.AssignedPageAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedPageAttributeStore.Save(assignedPageAttr)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedPageAttributeValueStore) Get(assignedPageAttrValueID string) (*model.AssignedPageAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedPageAttributeValueStore.Get(assignedPageAttrValueID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedPageAttributeValueStore) Save(assignedPageAttrValue *model.AssignedPageAttributeValue) (*model.AssignedPageAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedPageAttributeValueStore.Save(assignedPageAttrValue)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedPageAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*model.AssignedPageAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedPageAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedPageAttributeValueStore) SelectForSort(assignmentID string) ([]*model.AssignedPageAttributeValue, []*model.AttributeValue, error) {

	tries := 0
	for {
		result, resultVar1, err := s.AssignedPageAttributeValueStore.SelectForSort(assignmentID)
		if err == nil {
			return result, resultVar1, nil
		}
		if !isRepeatableError(err) {
			return result, resultVar1, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, resultVar1, err
		}
	}

}

func (s *RetryLayerAssignedPageAttributeValueStore) UpdateInBulk(attributeValues []*model.AssignedPageAttributeValue) error {

	tries := 0
	for {
		err := s.AssignedPageAttributeValueStore.UpdateInBulk(attributeValues)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeStore) FilterByOptions(options *model.AssignedProductAttributeFilterOption) ([]*model.AssignedProductAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedProductAttributeStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeStore) Get(id string) (*model.AssignedProductAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedProductAttributeStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeStore) GetWithOption(option *model.AssignedProductAttributeFilterOption) (*model.AssignedProductAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedProductAttributeStore.GetWithOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeStore) Save(assignedProductAttribute *model.AssignedProductAttribute) (*model.AssignedProductAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedProductAttributeStore.Save(assignedProductAttribute)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeValueStore) FilterByOptions(options *model.AssignedProductAttributeValueFilterOptions) ([]*model.AssignedProductAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedProductAttributeValueStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeValueStore) Get(assignedProductAttrValueID string) (*model.AssignedProductAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedProductAttributeValueStore.Get(assignedProductAttrValueID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeValueStore) Save(assignedProductAttrValue *model.AssignedProductAttributeValue) (*model.AssignedProductAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedProductAttributeValueStore.Save(assignedProductAttrValue)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*model.AssignedProductAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedProductAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeValueStore) SelectForSort(assignmentID string) ([]*model.AssignedProductAttributeValue, []*model.AttributeValue, error) {

	tries := 0
	for {
		result, resultVar1, err := s.AssignedProductAttributeValueStore.SelectForSort(assignmentID)
		if err == nil {
			return result, resultVar1, nil
		}
		if !isRepeatableError(err) {
			return result, resultVar1, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, resultVar1, err
		}
	}

}

func (s *RetryLayerAssignedProductAttributeValueStore) UpdateInBulk(attributeValues []*model.AssignedProductAttributeValue) error {

	tries := 0
	for {
		err := s.AssignedProductAttributeValueStore.UpdateInBulk(attributeValues)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeStore) FilterByOption(option *model.AssignedVariantAttributeFilterOption) ([]*model.AssignedVariantAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedVariantAttributeStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeStore) Get(id string) (*model.AssignedVariantAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedVariantAttributeStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeStore) GetWithOption(option *model.AssignedVariantAttributeFilterOption) (*model.AssignedVariantAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedVariantAttributeStore.GetWithOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeStore) Save(assignedVariantAttribute *model.AssignedVariantAttribute) (*model.AssignedVariantAttribute, error) {

	tries := 0
	for {
		result, err := s.AssignedVariantAttributeStore.Save(assignedVariantAttribute)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeValueStore) FilterByOptions(options *model.AssignedVariantAttributeValueFilterOptions) ([]*model.AssignedVariantAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedVariantAttributeValueStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeValueStore) Get(id string) (*model.AssignedVariantAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedVariantAttributeValueStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeValueStore) Save(assignedVariantAttrValue *model.AssignedVariantAttributeValue) (*model.AssignedVariantAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedVariantAttributeValueStore.Save(assignedVariantAttrValue)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeValueStore) SaveInBulk(assignmentID string, attributeValueIDs []string) ([]*model.AssignedVariantAttributeValue, error) {

	tries := 0
	for {
		result, err := s.AssignedVariantAttributeValueStore.SaveInBulk(assignmentID, attributeValueIDs)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeValueStore) SelectForSort(assignmentID string) ([]*model.AssignedVariantAttributeValue, []*model.AttributeValue, error) {

	tries := 0
	for {
		result, resultVar1, err := s.AssignedVariantAttributeValueStore.SelectForSort(assignmentID)
		if err == nil {
			return result, resultVar1, nil
		}
		if !isRepeatableError(err) {
			return result, resultVar1, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, resultVar1, err
		}
	}

}

func (s *RetryLayerAssignedVariantAttributeValueStore) UpdateInBulk(attributeValues []*model.AssignedVariantAttributeValue) error {

	tries := 0
	for {
		err := s.AssignedVariantAttributeValueStore.UpdateInBulk(attributeValues)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerAttributeStore) Delete(ids ...string) (int64, error) {

	tries := 0
	for {
		result, err := s.AttributeStore.Delete(ids...)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeStore) FilterbyOption(option *model.AttributeFilterOption) (model.Attributes, error) {

	tries := 0
	for {
		result, err := s.AttributeStore.FilterbyOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeStore) GetByOption(option *model.AttributeFilterOption) (*model.Attribute, error) {

	tries := 0
	for {
		result, err := s.AttributeStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeStore) GetPageTypeAttributes(pageTypeID string, unassigned bool) (model.Attributes, error) {

	tries := 0
	for {
		result, err := s.AttributeStore.GetPageTypeAttributes(pageTypeID, unassigned)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeStore) GetProductTypeAttributes(productTypeID string, unassigned bool, filter *model.AttributeFilterOption) (model.Attributes, error) {

	tries := 0
	for {
		result, err := s.AttributeStore.GetProductTypeAttributes(productTypeID, unassigned, filter)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeStore) Upsert(attr *model.Attribute) (*model.Attribute, error) {

	tries := 0
	for {
		result, err := s.AttributeStore.Upsert(attr)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributePageStore) Get(pageID string) (*model.AttributePage, error) {

	tries := 0
	for {
		result, err := s.AttributePageStore.Get(pageID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributePageStore) GetByOption(option *model.AttributePageFilterOption) (*model.AttributePage, error) {

	tries := 0
	for {
		result, err := s.AttributePageStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributePageStore) Save(page *model.AttributePage) (*model.AttributePage, error) {

	tries := 0
	for {
		result, err := s.AttributePageStore.Save(page)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeProductStore) FilterByOptions(option *model.AttributeProductFilterOption) ([]*model.AttributeProduct, error) {

	tries := 0
	for {
		result, err := s.AttributeProductStore.FilterByOptions(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeProductStore) Get(attributeProductID string) (*model.AttributeProduct, error) {

	tries := 0
	for {
		result, err := s.AttributeProductStore.Get(attributeProductID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeProductStore) GetByOption(option *model.AttributeProductFilterOption) (*model.AttributeProduct, error) {

	tries := 0
	for {
		result, err := s.AttributeProductStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeProductStore) Save(attributeProduct *model.AttributeProduct) (*model.AttributeProduct, error) {

	tries := 0
	for {
		result, err := s.AttributeProductStore.Save(attributeProduct)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeValueStore) BulkUpsert(transaction store_iface.SqlxExecutor, values model.AttributeValues) (model.AttributeValues, error) {

	tries := 0
	for {
		result, err := s.AttributeValueStore.BulkUpsert(transaction, values)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeValueStore) Count(options *model.AttributeValueFilterOptions) (int64, error) {

	tries := 0
	for {
		result, err := s.AttributeValueStore.Count(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeValueStore) Delete(ids ...string) (int64, error) {

	tries := 0
	for {
		result, err := s.AttributeValueStore.Delete(ids...)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeValueStore) FilterByOptions(options model.AttributeValueFilterOptions) (model.AttributeValues, error) {

	tries := 0
	for {
		result, err := s.AttributeValueStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeValueStore) Get(attributeID string) (*model.AttributeValue, error) {

	tries := 0
	for {
		result, err := s.AttributeValueStore.Get(attributeID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeValueStore) Upsert(av *model.AttributeValue) (*model.AttributeValue, error) {

	tries := 0
	for {
		result, err := s.AttributeValueStore.Upsert(av)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeVariantStore) FilterByOptions(options *model.AttributeVariantFilterOption) ([]*model.AttributeVariant, error) {

	tries := 0
	for {
		result, err := s.AttributeVariantStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeVariantStore) Get(attributeVariantID string) (*model.AttributeVariant, error) {

	tries := 0
	for {
		result, err := s.AttributeVariantStore.Get(attributeVariantID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeVariantStore) GetByOption(option *model.AttributeVariantFilterOption) (*model.AttributeVariant, error) {

	tries := 0
	for {
		result, err := s.AttributeVariantStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAttributeVariantStore) Save(attributeVariant *model.AttributeVariant) (*model.AttributeVariant, error) {

	tries := 0
	for {
		result, err := s.AttributeVariantStore.Save(attributeVariant)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAuditStore) Get(userID string, offset int, limit int) (model.Audits, error) {

	tries := 0
	for {
		result, err := s.AuditStore.Get(userID, offset, limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAuditStore) PermanentDeleteByUser(userID string) error {

	tries := 0
	for {
		err := s.AuditStore.PermanentDeleteByUser(userID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerAuditStore) Save(audit *model.Audit) error {

	tries := 0
	for {
		err := s.AuditStore.Save(audit)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerCategoryStore) FilterByOption(option *model.CategoryFilterOption) ([]*model.Category, error) {

	tries := 0
	for {
		result, err := s.CategoryStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCategoryStore) Get(ctx context.Context, categoryID string, allowFromCache bool) (*model.Category, error) {

	tries := 0
	for {
		result, err := s.CategoryStore.Get(ctx, categoryID, allowFromCache)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCategoryStore) GetByOption(option *model.CategoryFilterOption) (*model.Category, error) {

	tries := 0
	for {
		result, err := s.CategoryStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCategoryStore) Upsert(category *model.Category) (*model.Category, error) {

	tries := 0
	for {
		result, err := s.CategoryStore.Upsert(category)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) DeleteChannels(transaction store_iface.SqlxExecutor, ids []string) error {

	tries := 0
	for {
		err := s.ChannelStore.DeleteChannels(transaction, ids)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelStore) FilterByOption(option *model.ChannelFilterOption) ([]*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) Get(id string) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetbyOption(option *model.ChannelFilterOption) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetbyOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) Upsert(transaction store_iface.SqlxExecutor, channel *model.Channel) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.Upsert(transaction, channel)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutStore) CountCheckouts(options *model.CheckoutFilterOption) (int64, error) {

	tries := 0
	for {
		result, err := s.CheckoutStore.CountCheckouts(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutStore) DeleteCheckoutsByOption(transaction store_iface.SqlxExecutor, option *model.CheckoutFilterOption) error {

	tries := 0
	for {
		err := s.CheckoutStore.DeleteCheckoutsByOption(transaction, option)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerCheckoutStore) FetchCheckoutLinesAndPrefetchRelatedValue(ckout *model.Checkout) ([]*model.CheckoutLineInfo, error) {

	tries := 0
	for {
		result, err := s.CheckoutStore.FetchCheckoutLinesAndPrefetchRelatedValue(ckout)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutStore) FilterByOption(option *model.CheckoutFilterOption) ([]*model.Checkout, error) {

	tries := 0
	for {
		result, err := s.CheckoutStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutStore) GetByOption(option *model.CheckoutFilterOption) (*model.Checkout, error) {

	tries := 0
	for {
		result, err := s.CheckoutStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutStore) Upsert(transaction store_iface.SqlxExecutor, checkouts []*model.Checkout) ([]*model.Checkout, error) {

	tries := 0
	for {
		result, err := s.CheckoutStore.Upsert(transaction, checkouts)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) BulkCreate(checkoutLines []*model.CheckoutLine) ([]*model.CheckoutLine, error) {

	tries := 0
	for {
		result, err := s.CheckoutLineStore.BulkCreate(checkoutLines)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) BulkUpdate(checkoutLines []*model.CheckoutLine) error {

	tries := 0
	for {
		err := s.CheckoutLineStore.BulkUpdate(checkoutLines)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) CheckoutLinesByCheckoutID(checkoutID string) ([]*model.CheckoutLine, error) {

	tries := 0
	for {
		result, err := s.CheckoutLineStore.CheckoutLinesByCheckoutID(checkoutID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) CheckoutLinesByCheckoutWithPrefetch(checkoutID string) ([]*model.CheckoutLine, []*model.ProductVariant, []*model.Product, error) {

	tries := 0
	for {
		result, resultVar1, resultVar2, err := s.CheckoutLineStore.CheckoutLinesByCheckoutWithPrefetch(checkoutID)
		if err == nil {
			return result, resultVar1, resultVar2, nil
		}
		if !isRepeatableError(err) {
			return result, resultVar1, resultVar2, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, resultVar1, resultVar2, err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) CheckoutLinesByOption(option *model.CheckoutLineFilterOption) ([]*model.CheckoutLine, error) {

	tries := 0
	for {
		result, err := s.CheckoutLineStore.CheckoutLinesByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) DeleteLines(transaction store_iface.SqlxExecutor, checkoutLineIDs []string) error {

	tries := 0
	for {
		err := s.CheckoutLineStore.DeleteLines(transaction, checkoutLineIDs)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) Get(id string) (*model.CheckoutLine, error) {

	tries := 0
	for {
		result, err := s.CheckoutLineStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) TotalWeightForCheckoutLines(checkoutLineIDs []string) (*measurement.Weight, error) {

	tries := 0
	for {
		result, err := s.CheckoutLineStore.TotalWeightForCheckoutLines(checkoutLineIDs)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCheckoutLineStore) Upsert(checkoutLine *model.CheckoutLine) (*model.CheckoutLine, error) {

	tries := 0
	for {
		result, err := s.CheckoutLineStore.Upsert(checkoutLine)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerClusterDiscoveryStore) Cleanup() error {

	tries := 0
	for {
		err := s.ClusterDiscoveryStore.Cleanup()
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, error) {

	tries := 0
	for {
		result, err := s.ClusterDiscoveryStore.Delete(discovery)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, error) {

	tries := 0
	for {
		result, err := s.ClusterDiscoveryStore.Exists(discovery)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, error) {

	tries := 0
	for {
		result, err := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) error {

	tries := 0
	for {
		err := s.ClusterDiscoveryStore.Save(discovery)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) error {

	tries := 0
	for {
		err := s.ClusterDiscoveryStore.SetLastPingAt(discovery)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerCollectionStore) Delete(ids ...string) error {

	tries := 0
	for {
		err := s.CollectionStore.Delete(ids...)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerCollectionStore) FilterByOption(option *model.CollectionFilterOption) ([]*model.Collection, error) {

	tries := 0
	for {
		result, err := s.CollectionStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCollectionStore) Get(collectionID string) (*model.Collection, error) {

	tries := 0
	for {
		result, err := s.CollectionStore.Get(collectionID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCollectionStore) Upsert(collection *model.Collection) (*model.Collection, error) {

	tries := 0
	for {
		result, err := s.CollectionStore.Upsert(collection)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCollectionChannelListingStore) Delete(transaction store_iface.SqlxExecutor, options *model.CollectionChannelListingFilterOptions) error {

	tries := 0
	for {
		err := s.CollectionChannelListingStore.Delete(transaction, options)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerCollectionChannelListingStore) FilterByOptions(options *model.CollectionChannelListingFilterOptions) ([]*model.CollectionChannelListing, error) {

	tries := 0
	for {
		result, err := s.CollectionChannelListingStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCollectionChannelListingStore) Upsert(transaction store_iface.SqlxExecutor, relations ...*model.CollectionChannelListing) ([]*model.CollectionChannelListing, error) {

	tries := 0
	for {
		result, err := s.CollectionChannelListingStore.Upsert(transaction, relations...)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCollectionProductStore) BulkSave(transaction store_iface.SqlxExecutor, relations []*model.CollectionProduct) ([]*model.CollectionProduct, error) {

	tries := 0
	for {
		result, err := s.CollectionProductStore.BulkSave(transaction, relations)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCollectionProductStore) Delete(transaction store_iface.SqlxExecutor, options *model.CollectionProductFilterOptions) error {

	tries := 0
	for {
		err := s.CollectionProductStore.Delete(transaction, options)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerCollectionProductStore) FilterByOptions(options *model.CollectionProductFilterOptions) ([]*model.CollectionProduct, error) {

	tries := 0
	for {
		result, err := s.CollectionProductStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerComplianceStore) ComplianceExport(model *model.Compliance, cursor model.ComplianceExportCursor, limit int) ([]*model.CompliancePost, model.ComplianceExportCursor, error) {

	tries := 0
	for {
		result, resultVar1, err := s.ComplianceStore.ComplianceExport(model, cursor, limit)
		if err == nil {
			return result, resultVar1, nil
		}
		if !isRepeatableError(err) {
			return result, resultVar1, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, resultVar1, err
		}
	}

}

func (s *RetryLayerComplianceStore) Get(id string) (*model.Compliance, error) {

	tries := 0
	for {
		result, err := s.ComplianceStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, error) {

	tries := 0
	for {
		result, err := s.ComplianceStore.GetAll(offset, limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerComplianceStore) MessageExport(cursor model.MessageExportCursor, limit int) ([]*model.MessageExport, model.MessageExportCursor, error) {

	tries := 0
	for {
		result, resultVar1, err := s.ComplianceStore.MessageExport(cursor, limit)
		if err == nil {
			return result, resultVar1, nil
		}
		if !isRepeatableError(err) {
			return result, resultVar1, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, resultVar1, err
		}
	}

}

func (s *RetryLayerComplianceStore) Save(model *model.Compliance) (*model.Compliance, error) {

	tries := 0
	for {
		result, err := s.ComplianceStore.Save(model)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerComplianceStore) Update(model *model.Compliance) (*model.Compliance, error) {

	tries := 0
	for {
		result, err := s.ComplianceStore.Update(model)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCsvExportEventStore) FilterByOption(options *model.ExportEventFilterOption) ([]*model.ExportEvent, error) {

	tries := 0
	for {
		result, err := s.CsvExportEventStore.FilterByOption(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCsvExportEventStore) Save(event *model.ExportEvent) (*model.ExportEvent, error) {

	tries := 0
	for {
		result, err := s.CsvExportEventStore.Save(event)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCsvExportFileStore) Get(id string) (*model.ExportFile, error) {

	tries := 0
	for {
		result, err := s.CsvExportFileStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCsvExportFileStore) Save(file *model.ExportFile) (*model.ExportFile, error) {

	tries := 0
	for {
		result, err := s.CsvExportFileStore.Save(file)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCustomerEventStore) Count() (int64, error) {

	tries := 0
	for {
		result, err := s.CustomerEventStore.Count()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCustomerEventStore) FilterByOptions(options squirrel.Sqlizer) ([]*model.CustomerEvent, error) {

	tries := 0
	for {
		result, err := s.CustomerEventStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCustomerEventStore) Get(id string) (*model.CustomerEvent, error) {

	tries := 0
	for {
		result, err := s.CustomerEventStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCustomerEventStore) Save(customemrEvent *model.CustomerEvent) (*model.CustomerEvent, error) {

	tries := 0
	for {
		result, err := s.CustomerEventStore.Save(customemrEvent)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCustomerNoteStore) Get(id string) (*model.CustomerNote, error) {

	tries := 0
	for {
		result, err := s.CustomerNoteStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerCustomerNoteStore) Save(note *model.CustomerNote) (*model.CustomerNote, error) {

	tries := 0
	for {
		result, err := s.CustomerNoteStore.Save(note)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDigitalContentStore) FilterByOption(option *model.DigitalContentFilterOption) ([]*model.DigitalContent, error) {

	tries := 0
	for {
		result, err := s.DigitalContentStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDigitalContentStore) GetByOption(option *model.DigitalContentFilterOption) (*model.DigitalContent, error) {

	tries := 0
	for {
		result, err := s.DigitalContentStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDigitalContentStore) Save(content *model.DigitalContent) (*model.DigitalContent, error) {

	tries := 0
	for {
		result, err := s.DigitalContentStore.Save(content)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDigitalContentUrlStore) FilterByOptions(options *model.DigitalContentUrlFilterOptions) ([]*model.DigitalContentUrl, error) {

	tries := 0
	for {
		result, err := s.DigitalContentUrlStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDigitalContentUrlStore) Get(id string) (*model.DigitalContentUrl, error) {

	tries := 0
	for {
		result, err := s.DigitalContentUrlStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDigitalContentUrlStore) Upsert(contentURL *model.DigitalContentUrl) (*model.DigitalContentUrl, error) {

	tries := 0
	for {
		result, err := s.DigitalContentUrlStore.Upsert(contentURL)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountSaleStore) AddSaleRelations(transaction *gorm.DB, sales model.Sales, relations any) error {

	tries := 0
	for {
		err := s.DiscountSaleStore.AddSaleRelations(transaction, sales, relations)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerDiscountSaleStore) FilterSalesByOption(option *model.SaleFilterOption) ([]*model.Sale, error) {

	tries := 0
	for {
		result, err := s.DiscountSaleStore.FilterSalesByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountSaleStore) Get(saleID string) (*model.Sale, error) {

	tries := 0
	for {
		result, err := s.DiscountSaleStore.Get(saleID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountSaleStore) Upsert(transaction *gorm.DB, sale *model.Sale) (*model.Sale, error) {

	tries := 0
	for {
		result, err := s.DiscountSaleStore.Upsert(transaction, sale)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountSaleChannelListingStore) Get(saleChannelListingID string) (*model.SaleChannelListing, error) {

	tries := 0
	for {
		result, err := s.DiscountSaleChannelListingStore.Get(saleChannelListingID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountSaleChannelListingStore) SaleChannelListingsWithOption(option *model.SaleChannelListingFilterOption) ([]*model.SaleChannelListing, error) {

	tries := 0
	for {
		result, err := s.DiscountSaleChannelListingStore.SaleChannelListingsWithOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountSaleChannelListingStore) Save(saleChannelListing *model.SaleChannelListing) (*model.SaleChannelListing, error) {

	tries := 0
	for {
		result, err := s.DiscountSaleChannelListingStore.Save(saleChannelListing)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountVoucherStore) AddVoucherRelations(transaction *gorm.DB, vouchers model.Vouchers, relations any) error {

	tries := 0
	for {
		err := s.DiscountVoucherStore.AddVoucherRelations(transaction, vouchers, relations)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerDiscountVoucherStore) ExpiredVouchers(date *timemodule.Time) ([]*model.Voucher, error) {

	tries := 0
	for {
		result, err := s.DiscountVoucherStore.ExpiredVouchers(date)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountVoucherStore) FilterVouchersByOption(option *model.VoucherFilterOption) ([]*model.Voucher, error) {

	tries := 0
	for {
		result, err := s.DiscountVoucherStore.FilterVouchersByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountVoucherStore) Get(voucherID string) (*model.Voucher, error) {

	tries := 0
	for {
		result, err := s.DiscountVoucherStore.Get(voucherID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountVoucherStore) GetByOptions(options *model.VoucherFilterOption) (*model.Voucher, error) {

	tries := 0
	for {
		result, err := s.DiscountVoucherStore.GetByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerDiscountVoucherStore) Upsert(voucher *model.Voucher) (*model.Voucher, error) {

	tries := 0
	for {
		result, err := s.DiscountVoucherStore.Upsert(voucher)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) ClearCaches() {

	s.FileInfoStore.ClearCaches()

}

func (s *RetryLayerFileInfoStore) CountAll() (int64, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.CountAll()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) Get(id string) (*model.FileInfo, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) GetByIds(ids []string) ([]*model.FileInfo, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.GetByIds(ids)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.GetByPath(path)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) GetForUser(userID string) ([]*model.FileInfo, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.GetForUser(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) GetFromMaster(id string) (*model.FileInfo, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.GetFromMaster(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) GetWithOptions(page *int, perPage *int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.GetWithOptions(page, perPage, opt)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) InvalidateFileInfosForPostCache(postID string, deleted bool) {

	s.FileInfoStore.InvalidateFileInfosForPostCache(postID, deleted)

}

func (s *RetryLayerFileInfoStore) PermanentDelete(fileID string) error {

	tries := 0
	for {
		err := s.FileInfoStore.PermanentDelete(fileID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) PermanentDeleteByUser(userID string) (int64, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.PermanentDeleteByUser(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) SetContent(fileID string, content string) error {

	tries := 0
	for {
		err := s.FileInfoStore.SetContent(fileID, content)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerFileInfoStore) Upsert(info *model.FileInfo) (*model.FileInfo, error) {

	tries := 0
	for {
		result, err := s.FileInfoStore.Upsert(info)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFulfillmentStore) BulkDeleteFulfillments(transaction store_iface.SqlxExecutor, fulfillments model.Fulfillments) error {

	tries := 0
	for {
		err := s.FulfillmentStore.BulkDeleteFulfillments(transaction, fulfillments)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerFulfillmentStore) FilterByOption(transaction store_iface.SqlxExecutor, option *model.FulfillmentFilterOption) ([]*model.Fulfillment, error) {

	tries := 0
	for {
		result, err := s.FulfillmentStore.FilterByOption(transaction, option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFulfillmentStore) Get(id string) (*model.Fulfillment, error) {

	tries := 0
	for {
		result, err := s.FulfillmentStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFulfillmentStore) GetByOption(transaction store_iface.SqlxExecutor, option *model.FulfillmentFilterOption) (*model.Fulfillment, error) {

	tries := 0
	for {
		result, err := s.FulfillmentStore.GetByOption(transaction, option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFulfillmentStore) Upsert(transaction store_iface.SqlxExecutor, fulfillment *model.Fulfillment) (*model.Fulfillment, error) {

	tries := 0
	for {
		result, err := s.FulfillmentStore.Upsert(transaction, fulfillment)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFulfillmentLineStore) BulkUpsert(transaction store_iface.SqlxExecutor, fulfillmentLines []*model.FulfillmentLine) ([]*model.FulfillmentLine, error) {

	tries := 0
	for {
		result, err := s.FulfillmentLineStore.BulkUpsert(transaction, fulfillmentLines)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFulfillmentLineStore) DeleteFulfillmentLinesByOption(transaction store_iface.SqlxExecutor, option *model.FulfillmentLineFilterOption) error {

	tries := 0
	for {
		err := s.FulfillmentLineStore.DeleteFulfillmentLinesByOption(transaction, option)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerFulfillmentLineStore) FilterbyOption(option *model.FulfillmentLineFilterOption) ([]*model.FulfillmentLine, error) {

	tries := 0
	for {
		result, err := s.FulfillmentLineStore.FilterbyOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFulfillmentLineStore) Get(id string) (*model.FulfillmentLine, error) {

	tries := 0
	for {
		result, err := s.FulfillmentLineStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFulfillmentLineStore) Save(fulfillmentLine *model.FulfillmentLine) (*model.FulfillmentLine, error) {

	tries := 0
	for {
		result, err := s.FulfillmentLineStore.Save(fulfillmentLine)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardStore) BulkUpsert(transaction store_iface.SqlxExecutor, giftCards ...*model.GiftCard) ([]*model.GiftCard, error) {

	tries := 0
	for {
		result, err := s.GiftCardStore.BulkUpsert(transaction, giftCards...)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardStore) DeactivateOrderGiftcards(orderID string) ([]string, error) {

	tries := 0
	for {
		result, err := s.GiftCardStore.DeactivateOrderGiftcards(orderID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardStore) DeleteGiftcards(transaction store_iface.SqlxExecutor, ids []string) error {

	tries := 0
	for {
		err := s.GiftCardStore.DeleteGiftcards(transaction, ids)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerGiftCardStore) FilterByOption(option *model.GiftCardFilterOption) ([]*model.GiftCard, error) {

	tries := 0
	for {
		result, err := s.GiftCardStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardStore) GetById(id string) (*model.GiftCard, error) {

	tries := 0
	for {
		result, err := s.GiftCardStore.GetById(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardCheckoutStore) Delete(giftcardID string, checkoutID string) error {

	tries := 0
	for {
		err := s.GiftCardCheckoutStore.Delete(giftcardID, checkoutID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerGiftCardCheckoutStore) Get(id string) (*model.GiftCardCheckout, error) {

	tries := 0
	for {
		result, err := s.GiftCardCheckoutStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardCheckoutStore) Save(giftcardOrder *model.GiftCardCheckout) (*model.GiftCardCheckout, error) {

	tries := 0
	for {
		result, err := s.GiftCardCheckoutStore.Save(giftcardOrder)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardOrderStore) BulkUpsert(transaction store_iface.SqlxExecutor, orderGiftcards ...*model.OrderGiftCard) ([]*model.OrderGiftCard, error) {

	tries := 0
	for {
		result, err := s.GiftCardOrderStore.BulkUpsert(transaction, orderGiftcards...)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardOrderStore) FilterByOptions(options *model.OrderGiftCardFilterOptions) ([]*model.OrderGiftCard, error) {

	tries := 0
	for {
		result, err := s.GiftCardOrderStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardOrderStore) Get(id string) (*model.OrderGiftCard, error) {

	tries := 0
	for {
		result, err := s.GiftCardOrderStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftCardOrderStore) Save(giftcardOrder *model.OrderGiftCard) (*model.OrderGiftCard, error) {

	tries := 0
	for {
		result, err := s.GiftCardOrderStore.Save(giftcardOrder)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftcardEventStore) BulkUpsert(transaction store_iface.SqlxExecutor, events ...*model.GiftCardEvent) ([]*model.GiftCardEvent, error) {

	tries := 0
	for {
		result, err := s.GiftcardEventStore.BulkUpsert(transaction, events...)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftcardEventStore) FilterByOptions(options *model.GiftCardEventFilterOption) ([]*model.GiftCardEvent, error) {

	tries := 0
	for {
		result, err := s.GiftcardEventStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftcardEventStore) Get(id string) (*model.GiftCardEvent, error) {

	tries := 0
	for {
		result, err := s.GiftcardEventStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerGiftcardEventStore) Save(event *model.GiftCardEvent) (*model.GiftCardEvent, error) {

	tries := 0
	for {
		result, err := s.GiftcardEventStore.Save(event)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerInvoiceStore) Delete(transaction store_iface.SqlxExecutor, ids ...string) error {

	tries := 0
	for {
		err := s.InvoiceStore.Delete(transaction, ids...)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerInvoiceStore) FilterByOptions(options *model.InvoiceFilterOptions) ([]*model.Invoice, error) {

	tries := 0
	for {
		result, err := s.InvoiceStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerInvoiceStore) GetbyOptions(options *model.InvoiceFilterOptions) (*model.Invoice, error) {

	tries := 0
	for {
		result, err := s.InvoiceStore.GetbyOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerInvoiceStore) Upsert(invoice *model.Invoice) (*model.Invoice, error) {

	tries := 0
	for {
		result, err := s.InvoiceStore.Upsert(invoice)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerInvoiceEventStore) Get(invoiceEventID string) (*model.InvoiceEvent, error) {

	tries := 0
	for {
		result, err := s.InvoiceEventStore.Get(invoiceEventID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerInvoiceEventStore) Upsert(invoiceEvent *model.InvoiceEvent) (*model.InvoiceEvent, error) {

	tries := 0
	for {
		result, err := s.InvoiceEventStore.Upsert(invoiceEvent)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) Delete(id string) (string, error) {

	tries := 0
	for {
		result, err := s.JobStore.Delete(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) Get(id string) (*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) GetAllByStatus(status string) ([]*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.GetAllByStatus(status)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) GetAllByType(jobType string) ([]*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.GetAllByType(jobType)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.GetAllByTypePage(jobType, offset, limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) GetAllByTypesPage(jobTypes []string, offset int, limit int) ([]*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.GetAllByTypesPage(jobTypes, offset, limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.GetAllPage(offset, limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, error) {

	tries := 0
	for {
		result, err := s.JobStore.GetCountByStatusAndType(status, jobType)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.GetNewestJobByStatusAndType(status, jobType)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) GetNewestJobByStatusesAndType(statuses []string, jobType string) (*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.GetNewestJobByStatusesAndType(statuses, jobType)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) Save(job *model.Job) (*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.Save(job)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, error) {

	tries := 0
	for {
		result, err := s.JobStore.UpdateOptimistically(job, currentStatus)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) UpdateStatus(id string, status string) (*model.Job, error) {

	tries := 0
	for {
		result, err := s.JobStore.UpdateStatus(id, status)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, error) {

	tries := 0
	for {
		result, err := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerMenuStore) FilterByOptions(options *model.MenuFilterOptions) ([]*model.Menu, error) {

	tries := 0
	for {
		result, err := s.MenuStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerMenuStore) GetByOptions(options *model.MenuFilterOptions) (*model.Menu, error) {

	tries := 0
	for {
		result, err := s.MenuStore.GetByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerMenuStore) Save(menu *model.Menu) (*model.Menu, error) {

	tries := 0
	for {
		result, err := s.MenuStore.Save(menu)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerMenuItemStore) FilterByOptions(options *model.MenuItemFilterOptions) ([]*model.MenuItem, error) {

	tries := 0
	for {
		result, err := s.MenuItemStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerMenuItemStore) GetByOptions(options *model.MenuItemFilterOptions) (*model.MenuItem, error) {

	tries := 0
	for {
		result, err := s.MenuItemStore.GetByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerMenuItemStore) Save(menuItem *model.MenuItem) (*model.MenuItem, error) {

	tries := 0
	for {
		result, err := s.MenuItemStore.Save(menuItem)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOpenExchangeRateStore) BulkUpsert(rates []*model.OpenExchangeRate) ([]*model.OpenExchangeRate, error) {

	tries := 0
	for {
		result, err := s.OpenExchangeRateStore.BulkUpsert(rates)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOpenExchangeRateStore) GetAll() ([]*model.OpenExchangeRate, error) {

	tries := 0
	for {
		result, err := s.OpenExchangeRateStore.GetAll()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderStore) BulkUpsert(transaction store_iface.SqlxExecutor, orders []*model.Order) ([]*model.Order, error) {

	tries := 0
	for {
		result, err := s.OrderStore.BulkUpsert(transaction, orders)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderStore) FilterByOption(option *model.OrderFilterOption) ([]*model.Order, error) {

	tries := 0
	for {
		result, err := s.OrderStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderStore) Get(id string) (*model.Order, error) {

	tries := 0
	for {
		result, err := s.OrderStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderDiscountStore) BulkDelete(orderDiscountIDs []string) error {

	tries := 0
	for {
		err := s.OrderDiscountStore.BulkDelete(orderDiscountIDs)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerOrderDiscountStore) FilterbyOption(option *model.OrderDiscountFilterOption) ([]*model.OrderDiscount, error) {

	tries := 0
	for {
		result, err := s.OrderDiscountStore.FilterbyOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderDiscountStore) Get(orderDiscountID string) (*model.OrderDiscount, error) {

	tries := 0
	for {
		result, err := s.OrderDiscountStore.Get(orderDiscountID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderDiscountStore) Upsert(transaction store_iface.SqlxExecutor, orderDiscount *model.OrderDiscount) (*model.OrderDiscount, error) {

	tries := 0
	for {
		result, err := s.OrderDiscountStore.Upsert(transaction, orderDiscount)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderEventStore) FilterByOptions(options *model.OrderEventFilterOptions) ([]*model.OrderEvent, error) {

	tries := 0
	for {
		result, err := s.OrderEventStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderEventStore) Get(orderEventID string) (*model.OrderEvent, error) {

	tries := 0
	for {
		result, err := s.OrderEventStore.Get(orderEventID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderEventStore) Save(transaction store_iface.SqlxExecutor, orderEvent *model.OrderEvent) (*model.OrderEvent, error) {

	tries := 0
	for {
		result, err := s.OrderEventStore.Save(transaction, orderEvent)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderLineStore) BulkDelete(orderLineIDs []string) error {

	tries := 0
	for {
		err := s.OrderLineStore.BulkDelete(orderLineIDs)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerOrderLineStore) BulkUpsert(transaction store_iface.SqlxExecutor, orderLines []*model.OrderLine) ([]*model.OrderLine, error) {

	tries := 0
	for {
		result, err := s.OrderLineStore.BulkUpsert(transaction, orderLines)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderLineStore) FilterbyOption(option *model.OrderLineFilterOption) ([]*model.OrderLine, error) {

	tries := 0
	for {
		result, err := s.OrderLineStore.FilterbyOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderLineStore) Get(id string) (*model.OrderLine, error) {

	tries := 0
	for {
		result, err := s.OrderLineStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOrderLineStore) Upsert(transaction store_iface.SqlxExecutor, orderLine *model.OrderLine) (*model.OrderLine, error) {

	tries := 0
	for {
		result, err := s.OrderLineStore.Upsert(transaction, orderLine)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPageStore) FilterByOptions(options *model.PageFilterOptions) ([]*model.Page, error) {

	tries := 0
	for {
		result, err := s.PageStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentStore) CancelActivePaymentsOfCheckout(checkoutToken string) error {

	tries := 0
	for {
		err := s.PaymentStore.CancelActivePaymentsOfCheckout(checkoutToken)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPaymentStore) FilterByOption(option *model.PaymentFilterOption) ([]*model.Payment, error) {

	tries := 0
	for {
		result, err := s.PaymentStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentStore) Get(transaction store_iface.SqlxExecutor, id string, lockForUpdate bool) (*model.Payment, error) {

	tries := 0
	for {
		result, err := s.PaymentStore.Get(transaction, id, lockForUpdate)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentStore) PaymentOwnedByUser(userID string, paymentID string) (bool, error) {

	tries := 0
	for {
		result, err := s.PaymentStore.PaymentOwnedByUser(userID, paymentID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentStore) Save(transaction store_iface.SqlxExecutor, model *model.Payment) (*model.Payment, error) {

	tries := 0
	for {
		result, err := s.PaymentStore.Save(transaction, model)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentStore) Update(transaction store_iface.SqlxExecutor, model *model.Payment) (*model.Payment, error) {

	tries := 0
	for {
		result, err := s.PaymentStore.Update(transaction, model)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentStore) UpdatePaymentsOfCheckout(transaction store_iface.SqlxExecutor, checkoutToken string, option *model.PaymentPatch) error {

	tries := 0
	for {
		err := s.PaymentStore.UpdatePaymentsOfCheckout(transaction, checkoutToken, option)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPaymentTransactionStore) FilterByOption(option *model.PaymentTransactionFilterOpts) ([]*model.PaymentTransaction, error) {

	tries := 0
	for {
		result, err := s.PaymentTransactionStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentTransactionStore) Get(id string) (*model.PaymentTransaction, error) {

	tries := 0
	for {
		result, err := s.PaymentTransactionStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentTransactionStore) Save(transaction store_iface.SqlxExecutor, paymentTransaction *model.PaymentTransaction) (*model.PaymentTransaction, error) {

	tries := 0
	for {
		result, err := s.PaymentTransactionStore.Save(transaction, paymentTransaction)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPaymentTransactionStore) Update(transaction *model.PaymentTransaction) (*model.PaymentTransaction, error) {

	tries := 0
	for {
		result, err := s.PaymentTransactionStore.Update(transaction)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {

	tries := 0
	for {
		result, err := s.PluginStore.CompareAndDelete(keyVal, oldValue)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {

	tries := 0
	for {
		result, err := s.PluginStore.CompareAndSet(keyVal, oldValue)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginStore) Delete(pluginID string, key string) error {

	tries := 0
	for {
		err := s.PluginStore.Delete(pluginID, key)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPluginStore) DeleteAllExpired() error {

	tries := 0
	for {
		err := s.PluginStore.DeleteAllExpired()
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPluginStore) DeleteAllForPlugin(PluginID string) error {

	tries := 0
	for {
		err := s.PluginStore.DeleteAllForPlugin(PluginID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPluginStore) Get(pluginID string, key string) (*model.PluginKeyValue, error) {

	tries := 0
	for {
		result, err := s.PluginStore.Get(pluginID, key)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginStore) List(pluginID string, page int, perPage int) ([]string, error) {

	tries := 0
	for {
		result, err := s.PluginStore.List(pluginID, page, perPage)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, error) {

	tries := 0
	for {
		result, err := s.PluginStore.SaveOrUpdate(keyVal)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginStore) SetWithOptions(pluginID string, key string, value []byte, options model.PluginKVSetOptions) (bool, error) {

	tries := 0
	for {
		result, err := s.PluginStore.SetWithOptions(pluginID, key, value, options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginConfigurationStore) FilterPluginConfigurations(options model.PluginConfigurationFilterOptions) ([]*model.PluginConfiguration, error) {

	tries := 0
	for {
		result, err := s.PluginConfigurationStore.FilterPluginConfigurations(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginConfigurationStore) Get(id string) (*model.PluginConfiguration, error) {

	tries := 0
	for {
		result, err := s.PluginConfigurationStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginConfigurationStore) GetByOptions(options *model.PluginConfigurationFilterOptions) (*model.PluginConfiguration, error) {

	tries := 0
	for {
		result, err := s.PluginConfigurationStore.GetByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPluginConfigurationStore) Upsert(config *model.PluginConfiguration) (*model.PluginConfiguration, error) {

	tries := 0
	for {
		result, err := s.PluginConfigurationStore.Upsert(config)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, error) {

	tries := 0
	for {
		result, err := s.PreferenceStore.CleanupFlagsBatch(limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPreferenceStore) Delete(userID string, category string, name string) error {

	tries := 0
	for {
		err := s.PreferenceStore.Delete(userID, category, name)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPreferenceStore) DeleteCategory(userID string, category string) error {

	tries := 0
	for {
		err := s.PreferenceStore.DeleteCategory(userID, category)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPreferenceStore) DeleteCategoryAndName(category string, name string) error {

	tries := 0
	for {
		err := s.PreferenceStore.DeleteCategoryAndName(category, name)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPreferenceStore) DeleteUnusedFeatures() {

	s.PreferenceStore.DeleteUnusedFeatures()

}

func (s *RetryLayerPreferenceStore) Get(userID string, category string, name string) (*model.Preference, error) {

	tries := 0
	for {
		result, err := s.PreferenceStore.Get(userID, category, name)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPreferenceStore) GetAll(userID string) (model.Preferences, error) {

	tries := 0
	for {
		result, err := s.PreferenceStore.GetAll(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPreferenceStore) GetCategory(userID string, category string) (model.Preferences, error) {

	tries := 0
	for {
		result, err := s.PreferenceStore.GetCategory(userID, category)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPreferenceStore) PermanentDeleteByUser(userID string) error {

	tries := 0
	for {
		err := s.PreferenceStore.PermanentDeleteByUser(userID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPreferenceStore) Save(preferences model.Preferences) error {

	tries := 0
	for {
		err := s.PreferenceStore.Save(preferences)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPreorderAllocationStore) BulkCreate(transaction store_iface.SqlxExecutor, preorderAllocations []*model.PreorderAllocation) ([]*model.PreorderAllocation, error) {

	tries := 0
	for {
		result, err := s.PreorderAllocationStore.BulkCreate(transaction, preorderAllocations)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerPreorderAllocationStore) Delete(transaction store_iface.SqlxExecutor, preorderAllocationIDs ...string) error {

	tries := 0
	for {
		err := s.PreorderAllocationStore.Delete(transaction, preorderAllocationIDs...)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerPreorderAllocationStore) FilterByOption(options *model.PreorderAllocationFilterOption) ([]*model.PreorderAllocation, error) {

	tries := 0
	for {
		result, err := s.PreorderAllocationStore.FilterByOption(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) AdvancedFilterQueryBuilder(input *model.ExportProductsFilterOptions) squirrel.SelectBuilder {

	return s.ProductStore.AdvancedFilterQueryBuilder(input)

}

func (s *RetryLayerProductStore) CountByCategoryIDs(categoryIDs []string) ([]*model.ProductCountByCategoryID, error) {

	tries := 0
	for {
		result, err := s.ProductStore.CountByCategoryIDs(categoryIDs)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) FilterByOption(option *model.ProductFilterOption) ([]*model.Product, error) {

	tries := 0
	for {
		result, err := s.ProductStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) FilterByQuery(query squirrel.SelectBuilder) (model.Products, error) {

	tries := 0
	for {
		result, err := s.ProductStore.FilterByQuery(query)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) GetByOption(option *model.ProductFilterOption) (*model.Product, error) {

	tries := 0
	for {
		result, err := s.ProductStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) NotPublishedProducts(channelSlug string) ([]*struct {
	model.Product
	IsPublished     bool
	PublicationDate *timemodule.Time
}, error) {

	tries := 0
	for {
		result, err := s.ProductStore.NotPublishedProducts(channelSlug)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) PublishedProducts(channelSlug string) ([]*model.Product, error) {

	tries := 0
	for {
		result, err := s.ProductStore.PublishedProducts(channelSlug)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) PublishedWithVariants(channel_SlugOrID string) squirrel.SelectBuilder {

	return s.ProductStore.PublishedWithVariants(channel_SlugOrID)

}

func (s *RetryLayerProductStore) Save(prd *model.Product) (*model.Product, error) {

	tries := 0
	for {
		result, err := s.ProductStore.Save(prd)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) SelectForUpdateDiscountedPricesOfCatalogues(productIDs []string, categoryIDs []string, collectionIDs []string, variantIDs []string) ([]*model.Product, error) {

	tries := 0
	for {
		result, err := s.ProductStore.SelectForUpdateDiscountedPricesOfCatalogues(productIDs, categoryIDs, collectionIDs, variantIDs)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductStore) VisibleToUserProductsQuery(channel_SlugOrID string, userHasOneOfProductpermissions bool) squirrel.SelectBuilder {

	return s.ProductStore.VisibleToUserProductsQuery(channel_SlugOrID, userHasOneOfProductpermissions)

}

func (s *RetryLayerProductChannelListingStore) BulkUpsert(transaction store_iface.SqlxExecutor, listings []*model.ProductChannelListing) ([]*model.ProductChannelListing, error) {

	tries := 0
	for {
		result, err := s.ProductChannelListingStore.BulkUpsert(transaction, listings)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductChannelListingStore) FilterByOption(option *model.ProductChannelListingFilterOption) ([]*model.ProductChannelListing, error) {

	tries := 0
	for {
		result, err := s.ProductChannelListingStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductChannelListingStore) Get(channelListingID string) (*model.ProductChannelListing, error) {

	tries := 0
	for {
		result, err := s.ProductChannelListingStore.Get(channelListingID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductMediaStore) FilterByOption(option *model.ProductMediaFilterOption) ([]*model.ProductMedia, error) {

	tries := 0
	for {
		result, err := s.ProductMediaStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductMediaStore) Get(id string) (*model.ProductMedia, error) {

	tries := 0
	for {
		result, err := s.ProductMediaStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductMediaStore) Upsert(media *model.ProductMedia) (*model.ProductMedia, error) {

	tries := 0
	for {
		result, err := s.ProductMediaStore.Upsert(media)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTranslationStore) FilterByOption(option *model.ProductTranslationFilterOption) ([]*model.ProductTranslation, error) {

	tries := 0
	for {
		result, err := s.ProductTranslationStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTranslationStore) Get(translationID string) (*model.ProductTranslation, error) {

	tries := 0
	for {
		result, err := s.ProductTranslationStore.Get(translationID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTranslationStore) Upsert(translation *model.ProductTranslation) (*model.ProductTranslation, error) {

	tries := 0
	for {
		result, err := s.ProductTranslationStore.Upsert(translation)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTypeStore) Count(options *model.ProductTypeFilterOption) (int64, error) {

	tries := 0
	for {
		result, err := s.ProductTypeStore.Count(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTypeStore) FilterProductTypesByCheckoutToken(checkoutToken string) ([]*model.ProductType, error) {

	tries := 0
	for {
		result, err := s.ProductTypeStore.FilterProductTypesByCheckoutToken(checkoutToken)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTypeStore) FilterbyOption(options *model.ProductTypeFilterOption) ([]*model.ProductType, error) {

	tries := 0
	for {
		result, err := s.ProductTypeStore.FilterbyOption(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTypeStore) GetByOption(options *model.ProductTypeFilterOption) (*model.ProductType, error) {

	tries := 0
	for {
		result, err := s.ProductTypeStore.GetByOption(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTypeStore) ProductTypeByProductVariantID(variantID string) (*model.ProductType, error) {

	tries := 0
	for {
		result, err := s.ProductTypeStore.ProductTypeByProductVariantID(variantID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTypeStore) ProductTypesByProductIDs(productIDs []string) ([]*model.ProductType, error) {

	tries := 0
	for {
		result, err := s.ProductTypeStore.ProductTypesByProductIDs(productIDs)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductTypeStore) Save(productType *model.ProductType) (*model.ProductType, error) {

	tries := 0
	for {
		result, err := s.ProductTypeStore.Save(productType)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantStore) AddProductVariantMedias(transaction *gorm.DB, variants model.ProductVariants, medias model.ProductMedias) error {

	tries := 0
	for {
		err := s.ProductVariantStore.AddProductVariantMedias(transaction, variants, medias)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerProductVariantStore) FilterByOption(option *model.ProductVariantFilterOption) ([]*model.ProductVariant, error) {

	tries := 0
	for {
		result, err := s.ProductVariantStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantStore) Get(id string) (*model.ProductVariant, error) {

	tries := 0
	for {
		result, err := s.ProductVariantStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantStore) GetByOrderLineID(orderLineID string) (*model.ProductVariant, error) {

	tries := 0
	for {
		result, err := s.ProductVariantStore.GetByOrderLineID(orderLineID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantStore) GetWeight(productVariantID string) (*measurement.Weight, error) {

	tries := 0
	for {
		result, err := s.ProductVariantStore.GetWeight(productVariantID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantStore) Save(transaction store_iface.SqlxExecutor, variant *model.ProductVariant) (*model.ProductVariant, error) {

	tries := 0
	for {
		result, err := s.ProductVariantStore.Save(transaction, variant)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantStore) Update(transaction store_iface.SqlxExecutor, variant *model.ProductVariant) (*model.ProductVariant, error) {

	tries := 0
	for {
		result, err := s.ProductVariantStore.Update(transaction, variant)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantChannelListingStore) BulkUpsert(transaction store_iface.SqlxExecutor, variantChannelListings []*model.ProductVariantChannelListing) ([]*model.ProductVariantChannelListing, error) {

	tries := 0
	for {
		result, err := s.ProductVariantChannelListingStore.BulkUpsert(transaction, variantChannelListings)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantChannelListingStore) FilterbyOption(option *model.ProductVariantChannelListingFilterOption) ([]*model.ProductVariantChannelListing, error) {

	tries := 0
	for {
		result, err := s.ProductVariantChannelListingStore.FilterbyOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantChannelListingStore) Get(variantChannelListingID string) (*model.ProductVariantChannelListing, error) {

	tries := 0
	for {
		result, err := s.ProductVariantChannelListingStore.Get(variantChannelListingID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantChannelListingStore) Save(variantChannelListing *model.ProductVariantChannelListing) (*model.ProductVariantChannelListing, error) {

	tries := 0
	for {
		result, err := s.ProductVariantChannelListingStore.Save(variantChannelListing)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantTranslationStore) FilterByOption(option *model.ProductVariantTranslationFilterOption) ([]*model.ProductVariantTranslation, error) {

	tries := 0
	for {
		result, err := s.ProductVariantTranslationStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantTranslationStore) Get(translationID string) (*model.ProductVariantTranslation, error) {

	tries := 0
	for {
		result, err := s.ProductVariantTranslationStore.Get(translationID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerProductVariantTranslationStore) Upsert(translation *model.ProductVariantTranslation) (*model.ProductVariantTranslation, error) {

	tries := 0
	for {
		result, err := s.ProductVariantTranslationStore.Upsert(translation)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerRoleStore) Delete(roleID string) (*model.Role, error) {

	tries := 0
	for {
		result, err := s.RoleStore.Delete(roleID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerRoleStore) Get(roleID string) (*model.Role, error) {

	tries := 0
	for {
		result, err := s.RoleStore.Get(roleID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerRoleStore) GetAll() ([]*model.Role, error) {

	tries := 0
	for {
		result, err := s.RoleStore.GetAll()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerRoleStore) GetByName(ctx context.Context, name string) (*model.Role, error) {

	tries := 0
	for {
		result, err := s.RoleStore.GetByName(ctx, name)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerRoleStore) GetByNames(names []string) ([]*model.Role, error) {

	tries := 0
	for {
		result, err := s.RoleStore.GetByNames(names)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerRoleStore) PermanentDeleteAll() error {

	tries := 0
	for {
		err := s.RoleStore.PermanentDeleteAll()
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerRoleStore) Save(role *model.Role) (*model.Role, error) {

	tries := 0
	for {
		result, err := s.RoleStore.Save(role)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) AnalyticsSessionCount() (int64, error) {

	tries := 0
	for {
		result, err := s.SessionStore.AnalyticsSessionCount()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {

	s.SessionStore.Cleanup(expiryTime, batchSize)

}

func (s *RetryLayerSessionStore) Get(ctx context.Context, sessionIDOrToken string) (*model.Session, error) {

	tries := 0
	for {
		result, err := s.SessionStore.Get(ctx, sessionIDOrToken)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) GetSessions(userID string) ([]*model.Session, error) {

	tries := 0
	for {
		result, err := s.SessionStore.GetSessions(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, error) {

	tries := 0
	for {
		result, err := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) GetSessionsWithActiveDeviceIds(userID string) ([]*model.Session, error) {

	tries := 0
	for {
		result, err := s.SessionStore.GetSessionsWithActiveDeviceIds(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) PermanentDeleteSessionsByUser(teamID string) error {

	tries := 0
	for {
		err := s.SessionStore.PermanentDeleteSessionsByUser(teamID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSessionStore) Remove(sessionIDOrToken string) error {

	tries := 0
	for {
		err := s.SessionStore.Remove(sessionIDOrToken)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSessionStore) RemoveAllSessions() error {

	tries := 0
	for {
		err := s.SessionStore.RemoveAllSessions()
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSessionStore) Save(session *model.Session) (*model.Session, error) {

	tries := 0
	for {
		result, err := s.SessionStore.Save(session)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) UpdateDeviceId(id string, deviceID string, expiresAt int64) (string, error) {

	tries := 0
	for {
		result, err := s.SessionStore.UpdateDeviceId(id, deviceID, expiresAt)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) error {

	tries := 0
	for {
		err := s.SessionStore.UpdateExpiredNotify(sessionid, notified)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSessionStore) UpdateExpiresAt(sessionID string, time int64) error {

	tries := 0
	for {
		err := s.SessionStore.UpdateExpiresAt(sessionID, time)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSessionStore) UpdateLastActivityAt(sessionID string, time int64) error {

	tries := 0
	for {
		err := s.SessionStore.UpdateLastActivityAt(sessionID, time)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSessionStore) UpdateProps(session *model.Session) error {

	tries := 0
	for {
		err := s.SessionStore.UpdateProps(session)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSessionStore) UpdateRoles(userID string, roles string) (string, error) {

	tries := 0
	for {
		result, err := s.SessionStore.UpdateRoles(userID, roles)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodStore) ApplicableShippingMethods(price *goprices.Money, channelID string, weight *measurement.Weight, countryCode model.CountryCode, productIDs []string) ([]*model.ShippingMethod, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodStore.ApplicableShippingMethods(price, channelID, weight, countryCode, productIDs)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodStore) Delete(transaction store_iface.SqlxExecutor, ids ...string) error {

	tries := 0
	for {
		err := s.ShippingMethodStore.Delete(transaction, ids...)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerShippingMethodStore) FilterByOptions(options *model.ShippingMethodFilterOption) ([]*model.ShippingMethod, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodStore) Get(methodID string) (*model.ShippingMethod, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodStore.Get(methodID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodStore) GetbyOption(options *model.ShippingMethodFilterOption) (*model.ShippingMethod, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodStore.GetbyOption(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodStore) Upsert(transaction store_iface.SqlxExecutor, method *model.ShippingMethod) (*model.ShippingMethod, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodStore.Upsert(transaction, method)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodChannelListingStore) BulkDelete(transaction store_iface.SqlxExecutor, options *model.ShippingMethodChannelListingFilterOption) error {

	tries := 0
	for {
		err := s.ShippingMethodChannelListingStore.BulkDelete(transaction, options)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerShippingMethodChannelListingStore) FilterByOption(option *model.ShippingMethodChannelListingFilterOption) ([]*model.ShippingMethodChannelListing, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodChannelListingStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodChannelListingStore) Get(listingID string) (*model.ShippingMethodChannelListing, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodChannelListingStore.Get(listingID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodChannelListingStore) Upsert(transaction store_iface.SqlxExecutor, listings model.ShippingMethodChannelListings) (model.ShippingMethodChannelListings, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodChannelListingStore.Upsert(transaction, listings)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodExcludedProductStore) Delete(transaction store_iface.SqlxExecutor, options *model.ShippingMethodExcludedProductFilterOptions) error {

	tries := 0
	for {
		err := s.ShippingMethodExcludedProductStore.Delete(transaction, options)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerShippingMethodExcludedProductStore) FilterByOptions(options *model.ShippingMethodExcludedProductFilterOptions) ([]*model.ShippingMethodExcludedProduct, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodExcludedProductStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodExcludedProductStore) Save(instance *model.ShippingMethodExcludedProduct) (*model.ShippingMethodExcludedProduct, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodExcludedProductStore.Save(instance)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodPostalCodeRuleStore) Delete(transaction store_iface.SqlxExecutor, ids ...string) error {

	tries := 0
	for {
		err := s.ShippingMethodPostalCodeRuleStore.Delete(transaction, ids...)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerShippingMethodPostalCodeRuleStore) FilterByOptions(options *model.ShippingMethodPostalCodeRuleFilterOptions) ([]*model.ShippingMethodPostalCodeRule, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodPostalCodeRuleStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingMethodPostalCodeRuleStore) Save(transaction store_iface.SqlxExecutor, rules model.ShippingMethodPostalCodeRules) (model.ShippingMethodPostalCodeRules, error) {

	tries := 0
	for {
		result, err := s.ShippingMethodPostalCodeRuleStore.Save(transaction, rules)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingZoneStore) CountByOptions(options *model.ShippingZoneFilterOption) (int64, error) {

	tries := 0
	for {
		result, err := s.ShippingZoneStore.CountByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingZoneStore) Delete(transaction store_iface.SqlxExecutor, conditions *model.ShippingZoneFilterOption) (int64, error) {

	tries := 0
	for {
		result, err := s.ShippingZoneStore.Delete(transaction, conditions)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingZoneStore) FilterByOption(option *model.ShippingZoneFilterOption) ([]*model.ShippingZone, error) {

	tries := 0
	for {
		result, err := s.ShippingZoneStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingZoneStore) Get(shippingZoneID string) (*model.ShippingZone, error) {

	tries := 0
	for {
		result, err := s.ShippingZoneStore.Get(shippingZoneID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingZoneStore) Upsert(transaction store_iface.SqlxExecutor, shippingZone *model.ShippingZone) (*model.ShippingZone, error) {

	tries := 0
	for {
		result, err := s.ShippingZoneStore.Upsert(transaction, shippingZone)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingZoneChannelStore) BulkDelete(transaction store_iface.SqlxExecutor, options *model.ShippingZoneChannelFilterOptions) error {

	tries := 0
	for {
		err := s.ShippingZoneChannelStore.BulkDelete(transaction, options)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerShippingZoneChannelStore) BulkSave(transaction store_iface.SqlxExecutor, relations []*model.ShippingZoneChannel) ([]*model.ShippingZoneChannel, error) {

	tries := 0
	for {
		result, err := s.ShippingZoneChannelStore.BulkSave(transaction, relations)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShippingZoneChannelStore) FilterByOptions(options *model.ShippingZoneChannelFilterOptions) ([]*model.ShippingZoneChannel, error) {

	tries := 0
	for {
		result, err := s.ShippingZoneChannelStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopStore) FilterByOptions(options *model.ShopFilterOptions) ([]*model.Shop, error) {

	tries := 0
	for {
		result, err := s.ShopStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopStore) Get(shopID string) (*model.Shop, error) {

	tries := 0
	for {
		result, err := s.ShopStore.Get(shopID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopStore) GetByOptions(options *model.ShopFilterOptions) (*model.Shop, error) {

	tries := 0
	for {
		result, err := s.ShopStore.GetByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopStore) Upsert(shop *model.Shop) (*model.Shop, error) {

	tries := 0
	for {
		result, err := s.ShopStore.Upsert(shop)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopStaffStore) FilterByOptions(options *model.ShopStaffFilterOptions) ([]*model.ShopStaff, error) {

	tries := 0
	for {
		result, err := s.ShopStaffStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopStaffStore) Get(shopStaffID string) (*model.ShopStaff, error) {

	tries := 0
	for {
		result, err := s.ShopStaffStore.Get(shopStaffID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopStaffStore) GetByOptions(options *model.ShopStaffFilterOptions) (*model.ShopStaff, error) {

	tries := 0
	for {
		result, err := s.ShopStaffStore.GetByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopStaffStore) Save(shopStaff *model.ShopStaff) (*model.ShopStaff, error) {

	tries := 0
	for {
		result, err := s.ShopStaffStore.Save(shopStaff)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopTranslationStore) Get(id string) (*model.ShopTranslation, error) {

	tries := 0
	for {
		result, err := s.ShopTranslationStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerShopTranslationStore) Upsert(translation *model.ShopTranslation) (*model.ShopTranslation, error) {

	tries := 0
	for {
		result, err := s.ShopTranslationStore.Upsert(translation)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStaffNotificationRecipientStore) FilterByOptions(options *model.StaffNotificationRecipientFilterOptions) ([]*model.StaffNotificationRecipient, error) {

	tries := 0
	for {
		result, err := s.StaffNotificationRecipientStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStaffNotificationRecipientStore) Save(notificationRecipient *model.StaffNotificationRecipient) (*model.StaffNotificationRecipient, error) {

	tries := 0
	for {
		result, err := s.StaffNotificationRecipientStore.Save(notificationRecipient)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStatusStore) Get(userID string) (*model.Status, error) {

	tries := 0
	for {
		result, err := s.StatusStore.Get(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, error) {

	tries := 0
	for {
		result, err := s.StatusStore.GetByIds(userIds)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStatusStore) GetTotalActiveUsersCount() (int64, error) {

	tries := 0
	for {
		result, err := s.StatusStore.GetTotalActiveUsersCount()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStatusStore) ResetAll() error {

	tries := 0
	for {
		err := s.StatusStore.ResetAll()
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerStatusStore) SaveOrUpdate(status *model.Status) error {

	tries := 0
	for {
		err := s.StatusStore.SaveOrUpdate(status)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerStatusStore) UpdateLastActivityAt(userID string, lastActivityAt int64) error {

	tries := 0
	for {
		err := s.StatusStore.UpdateLastActivityAt(userID, lastActivityAt)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerStockStore) BulkUpsert(transaction store_iface.SqlxExecutor, stocks []*model.Stock) ([]*model.Stock, error) {

	tries := 0
	for {
		result, err := s.StockStore.BulkUpsert(transaction, stocks)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStockStore) ChangeQuantity(stockID string, quantity int) error {

	tries := 0
	for {
		err := s.StockStore.ChangeQuantity(stockID, quantity)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerStockStore) CountByOptions(options *model.StockFilterOption) (int32, error) {

	tries := 0
	for {
		result, err := s.StockStore.CountByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStockStore) FilterByOption(options *model.StockFilterOption) ([]*model.Stock, error) {

	tries := 0
	for {
		result, err := s.StockStore.FilterByOption(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStockStore) FilterForChannel(options *model.StockFilterForChannelOption) (squirrel.Sqlizer, []*model.Stock, error) {

	tries := 0
	for {
		result, resultVar1, err := s.StockStore.FilterForChannel(options)
		if err == nil {
			return result, resultVar1, nil
		}
		if !isRepeatableError(err) {
			return result, resultVar1, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, resultVar1, err
		}
	}

}

func (s *RetryLayerStockStore) FilterForCountryAndChannel(options *model.StockFilterForCountryAndChannel) ([]*model.Stock, error) {

	tries := 0
	for {
		result, err := s.StockStore.FilterForCountryAndChannel(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStockStore) FilterProductStocksForCountryAndChannel(options *model.StockFilterForCountryAndChannel) ([]*model.Stock, error) {

	tries := 0
	for {
		result, err := s.StockStore.FilterProductStocksForCountryAndChannel(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStockStore) FilterVariantStocksForCountry(options *model.StockFilterForCountryAndChannel) ([]*model.Stock, error) {

	tries := 0
	for {
		result, err := s.StockStore.FilterVariantStocksForCountry(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerStockStore) Get(stockID string) (*model.Stock, error) {

	tries := 0
	for {
		result, err := s.StockStore.Get(stockID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSystemStore) Get() (model.StringMap, error) {

	tries := 0
	for {
		result, err := s.SystemStore.Get()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSystemStore) GetByName(name string) (*model.System, error) {

	tries := 0
	for {
		result, err := s.SystemStore.GetByName(name)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSystemStore) InsertIfExists(system *model.System) (*model.System, error) {

	tries := 0
	for {
		result, err := s.SystemStore.InsertIfExists(system)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSystemStore) PermanentDeleteByName(name string) (*model.System, error) {

	tries := 0
	for {
		result, err := s.SystemStore.PermanentDeleteByName(name)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSystemStore) Save(system *model.System) error {

	tries := 0
	for {
		err := s.SystemStore.Save(system)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSystemStore) SaveOrUpdate(system *model.System) error {

	tries := 0
	for {
		err := s.SystemStore.SaveOrUpdate(system)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSystemStore) SaveOrUpdateWithWarnMetricHandling(system *model.System) error {

	tries := 0
	for {
		err := s.SystemStore.SaveOrUpdateWithWarnMetricHandling(system)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSystemStore) Update(system *model.System) error {

	tries := 0
	for {
		err := s.SystemStore.Update(system)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {

	tries := 0
	for {
		result, err := s.TermsOfServiceStore.Get(id, allowFromCache)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {

	tries := 0
	for {
		result, err := s.TermsOfServiceStore.GetLatest(allowFromCache)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {

	tries := 0
	for {
		result, err := s.TermsOfServiceStore.Save(termsOfService)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerTokenStore) Cleanup() {

	s.TokenStore.Cleanup()

}

func (s *RetryLayerTokenStore) Delete(token string) error {

	tries := 0
	for {
		err := s.TokenStore.Delete(token)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerTokenStore) GetAllTokensByType(tokenType model.TokenType) ([]*model.Token, error) {

	tries := 0
	for {
		result, err := s.TokenStore.GetAllTokensByType(tokenType)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerTokenStore) GetByToken(token string) (*model.Token, error) {

	tries := 0
	for {
		result, err := s.TokenStore.GetByToken(token)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerTokenStore) RemoveAllTokensByType(tokenType string) error {

	tries := 0
	for {
		err := s.TokenStore.RemoveAllTokensByType(tokenType)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerTokenStore) Save(recovery *model.Token) error {

	tries := 0
	for {
		err := s.TokenStore.Save(recovery)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUploadSessionStore) Delete(id string) error {

	tries := 0
	for {
		err := s.UploadSessionStore.Delete(id)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUploadSessionStore) Get(id string) (*model.UploadSession, error) {

	tries := 0
	for {
		result, err := s.UploadSessionStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUploadSessionStore) GetForUser(userID string) ([]*model.UploadSession, error) {

	tries := 0
	for {
		result, err := s.UploadSessionStore.GetForUser(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUploadSessionStore) Save(session *model.UploadSession) (*model.UploadSession, error) {

	tries := 0
	for {
		result, err := s.UploadSessionStore.Save(session)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUploadSessionStore) Update(session *model.UploadSession) error {

	tries := 0
	for {
		err := s.UploadSessionStore.Update(session)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) AddRelations(transaction *gorm.DB, userID string, relations any, customerNoteOnUser bool) *model.AppError {

	return s.UserStore.AddRelations(transaction, userID, relations, customerNoteOnUser)

}

func (s *RetryLayerUserStore) AnalyticsActiveCount(time int64, options model.UserCountOptions) (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.AnalyticsActiveCount(time, options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) AnalyticsActiveCountForPeriod(startTime int64, endTime int64, options model.UserCountOptions) (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.AnalyticsActiveCountForPeriod(startTime, endTime, options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) AnalyticsGetExternalUsers(hostDomain string) (bool, error) {

	tries := 0
	for {
		result, err := s.UserStore.AnalyticsGetExternalUsers(hostDomain)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) AnalyticsGetGuestCount() (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.AnalyticsGetGuestCount()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.AnalyticsGetInactiveUsersCount()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) AnalyticsGetSystemAdminCount() (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.AnalyticsGetSystemAdminCount()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) ClearAllCustomRoleAssignments() error {

	tries := 0
	for {
		err := s.UserStore.ClearAllCustomRoleAssignments()
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) ClearCaches() {

	s.UserStore.ClearCaches()

}

func (s *RetryLayerUserStore) Count(options model.UserCountOptions) (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.Count(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) FilterByOptions(ctx context.Context, options *model.UserFilterOptions) ([]*model.User, error) {

	tries := 0
	for {
		result, err := s.UserStore.FilterByOptions(ctx, options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, error) {

	tries := 0
	for {
		result, err := s.UserStore.GetAllProfiles(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) GetByOptions(ctx context.Context, options *model.UserFilterOptions) (*model.User, error) {

	tries := 0
	for {
		result, err := s.UserStore.GetByOptions(ctx, options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) GetEtagForAllProfiles() string {

	return s.UserStore.GetEtagForAllProfiles()

}

func (s *RetryLayerUserStore) GetEtagForProfiles(teamID string) string {

	return s.UserStore.GetEtagForProfiles(teamID)

}

func (s *RetryLayerUserStore) GetForLogin(loginID string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, error) {

	tries := 0
	for {
		result, err := s.UserStore.GetForLogin(loginID, allowSignInWithUsername, allowSignInWithEmail)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) GetKnownUsers(userID string) ([]string, error) {

	tries := 0
	for {
		result, err := s.UserStore.GetKnownUsers(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) GetProfileByIds(ctx context.Context, userIds []string, options *store.UserGetByIdsOpts, allowFromCache bool) ([]*model.User, error) {

	tries := 0
	for {
		result, err := s.UserStore.GetProfileByIds(ctx, userIds, options, allowFromCache)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, error) {

	tries := 0
	for {
		result, err := s.UserStore.GetSystemAdminProfiles()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) GetUnreadCount(userID string) (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.GetUnreadCount(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.UserForIndexing, error) {

	tries := 0
	for {
		result, err := s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) InferSystemInstallDate() (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.InferSystemInstallDate()
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) InvalidateProfileCacheForUser(userID string) {

	s.UserStore.InvalidateProfileCacheForUser(userID)

}

func (s *RetryLayerUserStore) PermanentDelete(userID string) error {

	tries := 0
	for {
		err := s.UserStore.PermanentDelete(userID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) RemoveRelations(transaction *gorm.DB, userID string, relations any, customerNoteOnUser bool) *model.AppError {

	return s.UserStore.RemoveRelations(transaction, userID, relations, customerNoteOnUser)

}

func (s *RetryLayerUserStore) ResetAuthDataToEmailForUsers(service string, userIDs []string, includeDeleted bool, dryRun bool) (int, error) {

	tries := 0
	for {
		result, err := s.UserStore.ResetAuthDataToEmailForUsers(service, userIDs, includeDeleted, dryRun)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) ResetLastPictureUpdate(userID string) error {

	tries := 0
	for {
		err := s.UserStore.ResetLastPictureUpdate(userID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) Save(user *model.User) (*model.User, error) {

	tries := 0
	for {
		result, err := s.UserStore.Save(user)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) Search(term string, options *model.UserSearchOptions) ([]*model.User, error) {

	tries := 0
	for {
		result, err := s.UserStore.Search(term, options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) Update(user *model.User, allowRoleUpdate bool) (*model.UserUpdate, error) {

	tries := 0
	for {
		result, err := s.UserStore.Update(user, allowRoleUpdate)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) UpdateAuthData(userID string, service string, authData *string, email string, resetMfa bool) (string, error) {

	tries := 0
	for {
		result, err := s.UserStore.UpdateAuthData(userID, service, authData, email, resetMfa)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) UpdateFailedPasswordAttempts(userID string, attempts int) error {

	tries := 0
	for {
		err := s.UserStore.UpdateFailedPasswordAttempts(userID, attempts)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) UpdateLastPictureUpdate(userID string) error {

	tries := 0
	for {
		err := s.UserStore.UpdateLastPictureUpdate(userID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) UpdateMfaActive(userID string, active bool) error {

	tries := 0
	for {
		err := s.UserStore.UpdateMfaActive(userID, active)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) UpdateMfaSecret(userID string, secret string) error {

	tries := 0
	for {
		err := s.UserStore.UpdateMfaSecret(userID, secret)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) UpdatePassword(userID string, newPassword string) error {

	tries := 0
	for {
		err := s.UserStore.UpdatePassword(userID, newPassword)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserStore) UpdateUpdateAt(userID string) (int64, error) {

	tries := 0
	for {
		result, err := s.UserStore.UpdateUpdateAt(userID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserStore) VerifyEmail(userID string, email string) (string, error) {

	tries := 0
	for {
		result, err := s.UserStore.VerifyEmail(userID, email)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) Delete(tokenID string) error {

	tries := 0
	for {
		err := s.UserAccessTokenStore.Delete(tokenID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) DeleteAllForUser(userID string) error {

	tries := 0
	for {
		err := s.UserAccessTokenStore.DeleteAllForUser(userID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) Get(tokenID string) (*model.UserAccessToken, error) {

	tries := 0
	for {
		result, err := s.UserAccessTokenStore.Get(tokenID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, error) {

	tries := 0
	for {
		result, err := s.UserAccessTokenStore.GetAll(offset, limit)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, error) {

	tries := 0
	for {
		result, err := s.UserAccessTokenStore.GetByToken(tokenString)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) GetByUser(userID string, page int, perPage int) ([]*model.UserAccessToken, error) {

	tries := 0
	for {
		result, err := s.UserAccessTokenStore.GetByUser(userID, page, perPage)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, error) {

	tries := 0
	for {
		result, err := s.UserAccessTokenStore.Save(token)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, error) {

	tries := 0
	for {
		result, err := s.UserAccessTokenStore.Search(term)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) UpdateTokenDisable(tokenID string) error {

	tries := 0
	for {
		err := s.UserAccessTokenStore.UpdateTokenDisable(tokenID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserAccessTokenStore) UpdateTokenEnable(tokenID string) error {

	tries := 0
	for {
		err := s.UserAccessTokenStore.UpdateTokenEnable(tokenID)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerVatStore) FilterByOptions(options *model.VatFilterOptions) ([]*model.Vat, error) {

	tries := 0
	for {
		result, err := s.VatStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVatStore) Upsert(transaction store_iface.SqlxExecutor, vats []*model.Vat) ([]*model.Vat, error) {

	tries := 0
	for {
		result, err := s.VatStore.Upsert(transaction, vats)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherChannelListingStore) FilterbyOption(option *model.VoucherChannelListingFilterOption) ([]*model.VoucherChannelListing, error) {

	tries := 0
	for {
		result, err := s.VoucherChannelListingStore.FilterbyOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherChannelListingStore) Get(voucherChannelListingID string) (*model.VoucherChannelListing, error) {

	tries := 0
	for {
		result, err := s.VoucherChannelListingStore.Get(voucherChannelListingID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherChannelListingStore) Upsert(voucherChannelListing *model.VoucherChannelListing) (*model.VoucherChannelListing, error) {

	tries := 0
	for {
		result, err := s.VoucherChannelListingStore.Upsert(voucherChannelListing)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherCustomerStore) DeleteInBulk(options *model.VoucherCustomerFilterOption) error {

	tries := 0
	for {
		err := s.VoucherCustomerStore.DeleteInBulk(options)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerVoucherCustomerStore) FilterByOptions(options *model.VoucherCustomerFilterOption) ([]*model.VoucherCustomer, error) {

	tries := 0
	for {
		result, err := s.VoucherCustomerStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherCustomerStore) GetByOption(options *model.VoucherCustomerFilterOption) (*model.VoucherCustomer, error) {

	tries := 0
	for {
		result, err := s.VoucherCustomerStore.GetByOption(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherCustomerStore) Save(voucherCustomer *model.VoucherCustomer) (*model.VoucherCustomer, error) {

	tries := 0
	for {
		result, err := s.VoucherCustomerStore.Save(voucherCustomer)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherTranslationStore) FilterByOption(option *model.VoucherTranslationFilterOption) ([]*model.VoucherTranslation, error) {

	tries := 0
	for {
		result, err := s.VoucherTranslationStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherTranslationStore) Get(id string) (*model.VoucherTranslation, error) {

	tries := 0
	for {
		result, err := s.VoucherTranslationStore.Get(id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherTranslationStore) GetByOption(option *model.VoucherTranslationFilterOption) (*model.VoucherTranslation, error) {

	tries := 0
	for {
		result, err := s.VoucherTranslationStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerVoucherTranslationStore) Save(translation *model.VoucherTranslation) (*model.VoucherTranslation, error) {

	tries := 0
	for {
		result, err := s.VoucherTranslationStore.Save(translation)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseStore) ApplicableForClickAndCollectCheckoutLines(checkoutLines model.CheckoutLines, country model.CountryCode) (model.Warehouses, error) {

	tries := 0
	for {
		result, err := s.WarehouseStore.ApplicableForClickAndCollectCheckoutLines(checkoutLines, country)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseStore) ApplicableForClickAndCollectNoQuantityCheck(checkoutLines model.CheckoutLines, country model.CountryCode) (model.Warehouses, error) {

	tries := 0
	for {
		result, err := s.WarehouseStore.ApplicableForClickAndCollectNoQuantityCheck(checkoutLines, country)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseStore) ApplicableForClickAndCollectOrderLines(orderLines model.OrderLines, country model.CountryCode) (model.Warehouses, error) {

	tries := 0
	for {
		result, err := s.WarehouseStore.ApplicableForClickAndCollectOrderLines(orderLines, country)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseStore) Delete(transaction store_iface.SqlxExecutor, ids ...string) error {

	tries := 0
	for {
		err := s.WarehouseStore.Delete(transaction, ids...)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerWarehouseStore) FilterByOprion(option *model.WarehouseFilterOption) ([]*model.WareHouse, error) {

	tries := 0
	for {
		result, err := s.WarehouseStore.FilterByOprion(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseStore) GetByOption(option *model.WarehouseFilterOption) (*model.WareHouse, error) {

	tries := 0
	for {
		result, err := s.WarehouseStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseStore) Save(model *model.WareHouse) (*model.WareHouse, error) {

	tries := 0
	for {
		result, err := s.WarehouseStore.Save(model)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseStore) Update(warehouse *model.WareHouse) (*model.WareHouse, error) {

	tries := 0
	for {
		result, err := s.WarehouseStore.Update(warehouse)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseStore) WarehouseByStockID(stockID string) (*model.WareHouse, error) {

	tries := 0
	for {
		result, err := s.WarehouseStore.WarehouseByStockID(stockID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseShippingZoneStore) Delete(transaction store_iface.SqlxExecutor, options *model.WarehouseShippingZoneFilterOption) error {

	tries := 0
	for {
		err := s.WarehouseShippingZoneStore.Delete(transaction, options)
		if err == nil {
			return nil
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerWarehouseShippingZoneStore) FilterByCountryCodeAndChannelID(countryCode string, channelID string) ([]*model.WarehouseShippingZone, error) {

	tries := 0
	for {
		result, err := s.WarehouseShippingZoneStore.FilterByCountryCodeAndChannelID(countryCode, channelID)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseShippingZoneStore) FilterByOptions(options *model.WarehouseShippingZoneFilterOption) ([]*model.WarehouseShippingZone, error) {

	tries := 0
	for {
		result, err := s.WarehouseShippingZoneStore.FilterByOptions(options)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWarehouseShippingZoneStore) Save(transaction store_iface.SqlxExecutor, warehouseShippingZones []*model.WarehouseShippingZone) ([]*model.WarehouseShippingZone, error) {

	tries := 0
	for {
		result, err := s.WarehouseShippingZoneStore.Save(transaction, warehouseShippingZones)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistStore) GetByOption(option *model.WishlistFilterOption) (*model.Wishlist, error) {

	tries := 0
	for {
		result, err := s.WishlistStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistStore) Upsert(wishList *model.Wishlist) (*model.Wishlist, error) {

	tries := 0
	for {
		result, err := s.WishlistStore.Upsert(wishList)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemStore) BulkUpsert(transaction store_iface.SqlxExecutor, wishlistItems model.WishlistItems) (model.WishlistItems, error) {

	tries := 0
	for {
		result, err := s.WishlistItemStore.BulkUpsert(transaction, wishlistItems)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemStore) DeleteItemsByOption(transaction store_iface.SqlxExecutor, option *model.WishlistItemFilterOption) (int64, error) {

	tries := 0
	for {
		result, err := s.WishlistItemStore.DeleteItemsByOption(transaction, option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemStore) FilterByOption(option *model.WishlistItemFilterOption) ([]*model.WishlistItem, error) {

	tries := 0
	for {
		result, err := s.WishlistItemStore.FilterByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemStore) GetById(selector store_iface.SqlxExecutor, id string) (*model.WishlistItem, error) {

	tries := 0
	for {
		result, err := s.WishlistItemStore.GetById(selector, id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemStore) GetByOption(option *model.WishlistItemFilterOption) (*model.WishlistItem, error) {

	tries := 0
	for {
		result, err := s.WishlistItemStore.GetByOption(option)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemProductVariantStore) BulkUpsert(transaction store_iface.SqlxExecutor, relations []*model.WishlistItemProductVariant) ([]*model.WishlistItemProductVariant, error) {

	tries := 0
	for {
		result, err := s.WishlistItemProductVariantStore.BulkUpsert(transaction, relations)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemProductVariantStore) DeleteRelation(relation *model.WishlistItemProductVariant) (int64, error) {

	tries := 0
	for {
		result, err := s.WishlistItemProductVariantStore.DeleteRelation(relation)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemProductVariantStore) GetById(selector store_iface.SqlxExecutor, id string) (*model.WishlistItemProductVariant, error) {

	tries := 0
	for {
		result, err := s.WishlistItemProductVariantStore.GetById(selector, id)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWishlistItemProductVariantStore) Save(wishlistVariant *model.WishlistItemProductVariant) (*model.WishlistItemProductVariant, error) {

	tries := 0
	for {
		result, err := s.WishlistItemProductVariantStore.Save(wishlistVariant)
		if err == nil {
			return result, nil
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries >= 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayer) Close() {
	s.Store.Close()
}

func (s *RetryLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *RetryLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *RetryLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *RetryLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *RetryLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func New(childStore store.Store) *RetryLayer {
	newStore := RetryLayer{
		Store: childStore,
	}

	newStore.AddressStore = &RetryLayerAddressStore{AddressStore: childStore.Address(), Root: &newStore}
	newStore.AllocationStore = &RetryLayerAllocationStore{AllocationStore: childStore.Allocation(), Root: &newStore}
	newStore.AppStore = &RetryLayerAppStore{AppStore: childStore.App(), Root: &newStore}
	newStore.AppTokenStore = &RetryLayerAppTokenStore{AppTokenStore: childStore.AppToken(), Root: &newStore}
	newStore.AssignedPageAttributeStore = &RetryLayerAssignedPageAttributeStore{AssignedPageAttributeStore: childStore.AssignedPageAttribute(), Root: &newStore}
	newStore.AssignedPageAttributeValueStore = &RetryLayerAssignedPageAttributeValueStore{AssignedPageAttributeValueStore: childStore.AssignedPageAttributeValue(), Root: &newStore}
	newStore.AssignedProductAttributeStore = &RetryLayerAssignedProductAttributeStore{AssignedProductAttributeStore: childStore.AssignedProductAttribute(), Root: &newStore}
	newStore.AssignedProductAttributeValueStore = &RetryLayerAssignedProductAttributeValueStore{AssignedProductAttributeValueStore: childStore.AssignedProductAttributeValue(), Root: &newStore}
	newStore.AssignedVariantAttributeStore = &RetryLayerAssignedVariantAttributeStore{AssignedVariantAttributeStore: childStore.AssignedVariantAttribute(), Root: &newStore}
	newStore.AssignedVariantAttributeValueStore = &RetryLayerAssignedVariantAttributeValueStore{AssignedVariantAttributeValueStore: childStore.AssignedVariantAttributeValue(), Root: &newStore}
	newStore.AttributeStore = &RetryLayerAttributeStore{AttributeStore: childStore.Attribute(), Root: &newStore}
	newStore.AttributePageStore = &RetryLayerAttributePageStore{AttributePageStore: childStore.AttributePage(), Root: &newStore}
	newStore.AttributeProductStore = &RetryLayerAttributeProductStore{AttributeProductStore: childStore.AttributeProduct(), Root: &newStore}
	newStore.AttributeTranslationStore = &RetryLayerAttributeTranslationStore{AttributeTranslationStore: childStore.AttributeTranslation(), Root: &newStore}
	newStore.AttributeValueStore = &RetryLayerAttributeValueStore{AttributeValueStore: childStore.AttributeValue(), Root: &newStore}
	newStore.AttributeValueTranslationStore = &RetryLayerAttributeValueTranslationStore{AttributeValueTranslationStore: childStore.AttributeValueTranslation(), Root: &newStore}
	newStore.AttributeVariantStore = &RetryLayerAttributeVariantStore{AttributeVariantStore: childStore.AttributeVariant(), Root: &newStore}
	newStore.AuditStore = &RetryLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.CategoryStore = &RetryLayerCategoryStore{CategoryStore: childStore.Category(), Root: &newStore}
	newStore.CategoryTranslationStore = &RetryLayerCategoryTranslationStore{CategoryTranslationStore: childStore.CategoryTranslation(), Root: &newStore}
	newStore.ChannelStore = &RetryLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.ChannelShopStore = &RetryLayerChannelShopStore{ChannelShopStore: childStore.ChannelShop(), Root: &newStore}
	newStore.CheckoutStore = &RetryLayerCheckoutStore{CheckoutStore: childStore.Checkout(), Root: &newStore}
	newStore.CheckoutLineStore = &RetryLayerCheckoutLineStore{CheckoutLineStore: childStore.CheckoutLine(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &RetryLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CollectionStore = &RetryLayerCollectionStore{CollectionStore: childStore.Collection(), Root: &newStore}
	newStore.CollectionChannelListingStore = &RetryLayerCollectionChannelListingStore{CollectionChannelListingStore: childStore.CollectionChannelListing(), Root: &newStore}
	newStore.CollectionProductStore = &RetryLayerCollectionProductStore{CollectionProductStore: childStore.CollectionProduct(), Root: &newStore}
	newStore.CollectionTranslationStore = &RetryLayerCollectionTranslationStore{CollectionTranslationStore: childStore.CollectionTranslation(), Root: &newStore}
	newStore.ComplianceStore = &RetryLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.CsvExportEventStore = &RetryLayerCsvExportEventStore{CsvExportEventStore: childStore.CsvExportEvent(), Root: &newStore}
	newStore.CsvExportFileStore = &RetryLayerCsvExportFileStore{CsvExportFileStore: childStore.CsvExportFile(), Root: &newStore}
	newStore.CustomerEventStore = &RetryLayerCustomerEventStore{CustomerEventStore: childStore.CustomerEvent(), Root: &newStore}
	newStore.CustomerNoteStore = &RetryLayerCustomerNoteStore{CustomerNoteStore: childStore.CustomerNote(), Root: &newStore}
	newStore.DigitalContentStore = &RetryLayerDigitalContentStore{DigitalContentStore: childStore.DigitalContent(), Root: &newStore}
	newStore.DigitalContentUrlStore = &RetryLayerDigitalContentUrlStore{DigitalContentUrlStore: childStore.DigitalContentUrl(), Root: &newStore}
	newStore.DiscountSaleStore = &RetryLayerDiscountSaleStore{DiscountSaleStore: childStore.DiscountSale(), Root: &newStore}
	newStore.DiscountSaleChannelListingStore = &RetryLayerDiscountSaleChannelListingStore{DiscountSaleChannelListingStore: childStore.DiscountSaleChannelListing(), Root: &newStore}
	newStore.DiscountSaleTranslationStore = &RetryLayerDiscountSaleTranslationStore{DiscountSaleTranslationStore: childStore.DiscountSaleTranslation(), Root: &newStore}
	newStore.DiscountVoucherStore = &RetryLayerDiscountVoucherStore{DiscountVoucherStore: childStore.DiscountVoucher(), Root: &newStore}
	newStore.FileInfoStore = &RetryLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.FulfillmentStore = &RetryLayerFulfillmentStore{FulfillmentStore: childStore.Fulfillment(), Root: &newStore}
	newStore.FulfillmentLineStore = &RetryLayerFulfillmentLineStore{FulfillmentLineStore: childStore.FulfillmentLine(), Root: &newStore}
	newStore.GiftCardStore = &RetryLayerGiftCardStore{GiftCardStore: childStore.GiftCard(), Root: &newStore}
	newStore.GiftCardCheckoutStore = &RetryLayerGiftCardCheckoutStore{GiftCardCheckoutStore: childStore.GiftCardCheckout(), Root: &newStore}
	newStore.GiftCardOrderStore = &RetryLayerGiftCardOrderStore{GiftCardOrderStore: childStore.GiftCardOrder(), Root: &newStore}
	newStore.GiftcardEventStore = &RetryLayerGiftcardEventStore{GiftcardEventStore: childStore.GiftcardEvent(), Root: &newStore}
	newStore.InvoiceStore = &RetryLayerInvoiceStore{InvoiceStore: childStore.Invoice(), Root: &newStore}
	newStore.InvoiceEventStore = &RetryLayerInvoiceEventStore{InvoiceEventStore: childStore.InvoiceEvent(), Root: &newStore}
	newStore.JobStore = &RetryLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.MenuStore = &RetryLayerMenuStore{MenuStore: childStore.Menu(), Root: &newStore}
	newStore.MenuItemStore = &RetryLayerMenuItemStore{MenuItemStore: childStore.MenuItem(), Root: &newStore}
	newStore.MenuItemTranslationStore = &RetryLayerMenuItemTranslationStore{MenuItemTranslationStore: childStore.MenuItemTranslation(), Root: &newStore}
	newStore.OpenExchangeRateStore = &RetryLayerOpenExchangeRateStore{OpenExchangeRateStore: childStore.OpenExchangeRate(), Root: &newStore}
	newStore.OrderStore = &RetryLayerOrderStore{OrderStore: childStore.Order(), Root: &newStore}
	newStore.OrderDiscountStore = &RetryLayerOrderDiscountStore{OrderDiscountStore: childStore.OrderDiscount(), Root: &newStore}
	newStore.OrderEventStore = &RetryLayerOrderEventStore{OrderEventStore: childStore.OrderEvent(), Root: &newStore}
	newStore.OrderLineStore = &RetryLayerOrderLineStore{OrderLineStore: childStore.OrderLine(), Root: &newStore}
	newStore.PageStore = &RetryLayerPageStore{PageStore: childStore.Page(), Root: &newStore}
	newStore.PageTranslationStore = &RetryLayerPageTranslationStore{PageTranslationStore: childStore.PageTranslation(), Root: &newStore}
	newStore.PageTypeStore = &RetryLayerPageTypeStore{PageTypeStore: childStore.PageType(), Root: &newStore}
	newStore.PaymentStore = &RetryLayerPaymentStore{PaymentStore: childStore.Payment(), Root: &newStore}
	newStore.PaymentTransactionStore = &RetryLayerPaymentTransactionStore{PaymentTransactionStore: childStore.PaymentTransaction(), Root: &newStore}
	newStore.PluginStore = &RetryLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PluginConfigurationStore = &RetryLayerPluginConfigurationStore{PluginConfigurationStore: childStore.PluginConfiguration(), Root: &newStore}
	newStore.PreferenceStore = &RetryLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.PreorderAllocationStore = &RetryLayerPreorderAllocationStore{PreorderAllocationStore: childStore.PreorderAllocation(), Root: &newStore}
	newStore.ProductStore = &RetryLayerProductStore{ProductStore: childStore.Product(), Root: &newStore}
	newStore.ProductChannelListingStore = &RetryLayerProductChannelListingStore{ProductChannelListingStore: childStore.ProductChannelListing(), Root: &newStore}
	newStore.ProductMediaStore = &RetryLayerProductMediaStore{ProductMediaStore: childStore.ProductMedia(), Root: &newStore}
	newStore.ProductTranslationStore = &RetryLayerProductTranslationStore{ProductTranslationStore: childStore.ProductTranslation(), Root: &newStore}
	newStore.ProductTypeStore = &RetryLayerProductTypeStore{ProductTypeStore: childStore.ProductType(), Root: &newStore}
	newStore.ProductVariantStore = &RetryLayerProductVariantStore{ProductVariantStore: childStore.ProductVariant(), Root: &newStore}
	newStore.ProductVariantChannelListingStore = &RetryLayerProductVariantChannelListingStore{ProductVariantChannelListingStore: childStore.ProductVariantChannelListing(), Root: &newStore}
	newStore.ProductVariantTranslationStore = &RetryLayerProductVariantTranslationStore{ProductVariantTranslationStore: childStore.ProductVariantTranslation(), Root: &newStore}
	newStore.RoleStore = &RetryLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SessionStore = &RetryLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.ShippingMethodStore = &RetryLayerShippingMethodStore{ShippingMethodStore: childStore.ShippingMethod(), Root: &newStore}
	newStore.ShippingMethodChannelListingStore = &RetryLayerShippingMethodChannelListingStore{ShippingMethodChannelListingStore: childStore.ShippingMethodChannelListing(), Root: &newStore}
	newStore.ShippingMethodExcludedProductStore = &RetryLayerShippingMethodExcludedProductStore{ShippingMethodExcludedProductStore: childStore.ShippingMethodExcludedProduct(), Root: &newStore}
	newStore.ShippingMethodPostalCodeRuleStore = &RetryLayerShippingMethodPostalCodeRuleStore{ShippingMethodPostalCodeRuleStore: childStore.ShippingMethodPostalCodeRule(), Root: &newStore}
	newStore.ShippingMethodTranslationStore = &RetryLayerShippingMethodTranslationStore{ShippingMethodTranslationStore: childStore.ShippingMethodTranslation(), Root: &newStore}
	newStore.ShippingZoneStore = &RetryLayerShippingZoneStore{ShippingZoneStore: childStore.ShippingZone(), Root: &newStore}
	newStore.ShippingZoneChannelStore = &RetryLayerShippingZoneChannelStore{ShippingZoneChannelStore: childStore.ShippingZoneChannel(), Root: &newStore}
	newStore.ShopStore = &RetryLayerShopStore{ShopStore: childStore.Shop(), Root: &newStore}
	newStore.ShopStaffStore = &RetryLayerShopStaffStore{ShopStaffStore: childStore.ShopStaff(), Root: &newStore}
	newStore.ShopTranslationStore = &RetryLayerShopTranslationStore{ShopTranslationStore: childStore.ShopTranslation(), Root: &newStore}
	newStore.StaffNotificationRecipientStore = &RetryLayerStaffNotificationRecipientStore{StaffNotificationRecipientStore: childStore.StaffNotificationRecipient(), Root: &newStore}
	newStore.StatusStore = &RetryLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.StockStore = &RetryLayerStockStore{StockStore: childStore.Stock(), Root: &newStore}
	newStore.SystemStore = &RetryLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TermsOfServiceStore = &RetryLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &RetryLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UploadSessionStore = &RetryLayerUploadSessionStore{UploadSessionStore: childStore.UploadSession(), Root: &newStore}
	newStore.UserStore = &RetryLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &RetryLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.VatStore = &RetryLayerVatStore{VatStore: childStore.Vat(), Root: &newStore}
	newStore.VoucherChannelListingStore = &RetryLayerVoucherChannelListingStore{VoucherChannelListingStore: childStore.VoucherChannelListing(), Root: &newStore}
	newStore.VoucherCustomerStore = &RetryLayerVoucherCustomerStore{VoucherCustomerStore: childStore.VoucherCustomer(), Root: &newStore}
	newStore.VoucherTranslationStore = &RetryLayerVoucherTranslationStore{VoucherTranslationStore: childStore.VoucherTranslation(), Root: &newStore}
	newStore.WarehouseStore = &RetryLayerWarehouseStore{WarehouseStore: childStore.Warehouse(), Root: &newStore}
	newStore.WarehouseShippingZoneStore = &RetryLayerWarehouseShippingZoneStore{WarehouseShippingZoneStore: childStore.WarehouseShippingZone(), Root: &newStore}
	newStore.WishlistStore = &RetryLayerWishlistStore{WishlistStore: childStore.Wishlist(), Root: &newStore}
	newStore.WishlistItemStore = &RetryLayerWishlistItemStore{WishlistItemStore: childStore.WishlistItem(), Root: &newStore}
	newStore.WishlistItemProductVariantStore = &RetryLayerWishlistItemProductVariantStore{WishlistItemProductVariantStore: childStore.WishlistItemProductVariant(), Root: &newStore}
	return &newStore
}
