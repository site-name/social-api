// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// User is an object representing the database table.
type User struct {
	ID                       string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	Email                    null.String `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	Username                 null.String `boil:"username" json:"username,omitempty" toml:"username" yaml:"username,omitempty"`
	Firstname                null.String `boil:"firstname" json:"firstname,omitempty" toml:"firstname" yaml:"firstname,omitempty"`
	Lastname                 null.String `boil:"lastname" json:"lastname,omitempty" toml:"lastname" yaml:"lastname,omitempty"`
	Defaultshippingaddressid null.String `boil:"defaultshippingaddressid" json:"defaultshippingaddressid,omitempty" toml:"defaultshippingaddressid" yaml:"defaultshippingaddressid,omitempty"`
	Defaultbillingaddressid  null.String `boil:"defaultbillingaddressid" json:"defaultbillingaddressid,omitempty" toml:"defaultbillingaddressid" yaml:"defaultbillingaddressid,omitempty"`
	Password                 null.String `boil:"password" json:"password,omitempty" toml:"password" yaml:"password,omitempty"`
	Authdata                 null.String `boil:"authdata" json:"authdata,omitempty" toml:"authdata" yaml:"authdata,omitempty"`
	Authservice              null.String `boil:"authservice" json:"authservice,omitempty" toml:"authservice" yaml:"authservice,omitempty"`
	Emailverified            null.Bool   `boil:"emailverified" json:"emailverified,omitempty" toml:"emailverified" yaml:"emailverified,omitempty"`
	Nickname                 null.String `boil:"nickname" json:"nickname,omitempty" toml:"nickname" yaml:"nickname,omitempty"`
	Roles                    null.String `boil:"roles" json:"roles,omitempty" toml:"roles" yaml:"roles,omitempty"`
	Props                    null.JSON   `boil:"props" json:"props,omitempty" toml:"props" yaml:"props,omitempty"`
	Notifyprops              null.JSON   `boil:"notifyprops" json:"notifyprops,omitempty" toml:"notifyprops" yaml:"notifyprops,omitempty"`
	Lastpasswordupdate       null.Int64  `boil:"lastpasswordupdate" json:"lastpasswordupdate,omitempty" toml:"lastpasswordupdate" yaml:"lastpasswordupdate,omitempty"`
	Lastpictureupdate        null.Int64  `boil:"lastpictureupdate" json:"lastpictureupdate,omitempty" toml:"lastpictureupdate" yaml:"lastpictureupdate,omitempty"`
	Failedattempts           null.Int    `boil:"failedattempts" json:"failedattempts,omitempty" toml:"failedattempts" yaml:"failedattempts,omitempty"`
	Locale                   null.String `boil:"locale" json:"locale,omitempty" toml:"locale" yaml:"locale,omitempty"`
	Timezone                 null.JSON   `boil:"timezone" json:"timezone,omitempty" toml:"timezone" yaml:"timezone,omitempty"`
	Mfaactive                null.Bool   `boil:"mfaactive" json:"mfaactive,omitempty" toml:"mfaactive" yaml:"mfaactive,omitempty"`
	Mfasecret                null.String `boil:"mfasecret" json:"mfasecret,omitempty" toml:"mfasecret" yaml:"mfasecret,omitempty"`
	Createat                 null.Int64  `boil:"createat" json:"createat,omitempty" toml:"createat" yaml:"createat,omitempty"`
	Updateat                 null.Int64  `boil:"updateat" json:"updateat,omitempty" toml:"updateat" yaml:"updateat,omitempty"`
	Deleteat                 null.Int64  `boil:"deleteat" json:"deleteat,omitempty" toml:"deleteat" yaml:"deleteat,omitempty"`
	Isactive                 null.Bool   `boil:"isactive" json:"isactive,omitempty" toml:"isactive" yaml:"isactive,omitempty"`
	Note                     null.String `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	Jwttokenkey              null.String `boil:"jwttokenkey" json:"jwttokenkey,omitempty" toml:"jwttokenkey" yaml:"jwttokenkey,omitempty"`
	Metadata                 null.JSON   `boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	Privatemetadata          null.JSON   `boil:"privatemetadata" json:"privatemetadata,omitempty" toml:"privatemetadata" yaml:"privatemetadata,omitempty"`

	R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ID                       string
	Email                    string
	Username                 string
	Firstname                string
	Lastname                 string
	Defaultshippingaddressid string
	Defaultbillingaddressid  string
	Password                 string
	Authdata                 string
	Authservice              string
	Emailverified            string
	Nickname                 string
	Roles                    string
	Props                    string
	Notifyprops              string
	Lastpasswordupdate       string
	Lastpictureupdate        string
	Failedattempts           string
	Locale                   string
	Timezone                 string
	Mfaactive                string
	Mfasecret                string
	Createat                 string
	Updateat                 string
	Deleteat                 string
	Isactive                 string
	Note                     string
	Jwttokenkey              string
	Metadata                 string
	Privatemetadata          string
}{
	ID:                       "id",
	Email:                    "email",
	Username:                 "username",
	Firstname:                "firstname",
	Lastname:                 "lastname",
	Defaultshippingaddressid: "defaultshippingaddressid",
	Defaultbillingaddressid:  "defaultbillingaddressid",
	Password:                 "password",
	Authdata:                 "authdata",
	Authservice:              "authservice",
	Emailverified:            "emailverified",
	Nickname:                 "nickname",
	Roles:                    "roles",
	Props:                    "props",
	Notifyprops:              "notifyprops",
	Lastpasswordupdate:       "lastpasswordupdate",
	Lastpictureupdate:        "lastpictureupdate",
	Failedattempts:           "failedattempts",
	Locale:                   "locale",
	Timezone:                 "timezone",
	Mfaactive:                "mfaactive",
	Mfasecret:                "mfasecret",
	Createat:                 "createat",
	Updateat:                 "updateat",
	Deleteat:                 "deleteat",
	Isactive:                 "isactive",
	Note:                     "note",
	Jwttokenkey:              "jwttokenkey",
	Metadata:                 "metadata",
	Privatemetadata:          "privatemetadata",
}

var UserTableColumns = struct {
	ID                       string
	Email                    string
	Username                 string
	Firstname                string
	Lastname                 string
	Defaultshippingaddressid string
	Defaultbillingaddressid  string
	Password                 string
	Authdata                 string
	Authservice              string
	Emailverified            string
	Nickname                 string
	Roles                    string
	Props                    string
	Notifyprops              string
	Lastpasswordupdate       string
	Lastpictureupdate        string
	Failedattempts           string
	Locale                   string
	Timezone                 string
	Mfaactive                string
	Mfasecret                string
	Createat                 string
	Updateat                 string
	Deleteat                 string
	Isactive                 string
	Note                     string
	Jwttokenkey              string
	Metadata                 string
	Privatemetadata          string
}{
	ID:                       "users.id",
	Email:                    "users.email",
	Username:                 "users.username",
	Firstname:                "users.firstname",
	Lastname:                 "users.lastname",
	Defaultshippingaddressid: "users.defaultshippingaddressid",
	Defaultbillingaddressid:  "users.defaultbillingaddressid",
	Password:                 "users.password",
	Authdata:                 "users.authdata",
	Authservice:              "users.authservice",
	Emailverified:            "users.emailverified",
	Nickname:                 "users.nickname",
	Roles:                    "users.roles",
	Props:                    "users.props",
	Notifyprops:              "users.notifyprops",
	Lastpasswordupdate:       "users.lastpasswordupdate",
	Lastpictureupdate:        "users.lastpictureupdate",
	Failedattempts:           "users.failedattempts",
	Locale:                   "users.locale",
	Timezone:                 "users.timezone",
	Mfaactive:                "users.mfaactive",
	Mfasecret:                "users.mfasecret",
	Createat:                 "users.createat",
	Updateat:                 "users.updateat",
	Deleteat:                 "users.deleteat",
	Isactive:                 "users.isactive",
	Note:                     "users.note",
	Jwttokenkey:              "users.jwttokenkey",
	Metadata:                 "users.metadata",
	Privatemetadata:          "users.privatemetadata",
}

// Generated where

var UserWhere = struct {
	ID                       whereHelperstring
	Email                    whereHelpernull_String
	Username                 whereHelpernull_String
	Firstname                whereHelpernull_String
	Lastname                 whereHelpernull_String
	Defaultshippingaddressid whereHelpernull_String
	Defaultbillingaddressid  whereHelpernull_String
	Password                 whereHelpernull_String
	Authdata                 whereHelpernull_String
	Authservice              whereHelpernull_String
	Emailverified            whereHelpernull_Bool
	Nickname                 whereHelpernull_String
	Roles                    whereHelpernull_String
	Props                    whereHelpernull_JSON
	Notifyprops              whereHelpernull_JSON
	Lastpasswordupdate       whereHelpernull_Int64
	Lastpictureupdate        whereHelpernull_Int64
	Failedattempts           whereHelpernull_Int
	Locale                   whereHelpernull_String
	Timezone                 whereHelpernull_JSON
	Mfaactive                whereHelpernull_Bool
	Mfasecret                whereHelpernull_String
	Createat                 whereHelpernull_Int64
	Updateat                 whereHelpernull_Int64
	Deleteat                 whereHelpernull_Int64
	Isactive                 whereHelpernull_Bool
	Note                     whereHelpernull_String
	Jwttokenkey              whereHelpernull_String
	Metadata                 whereHelpernull_JSON
	Privatemetadata          whereHelpernull_JSON
}{
	ID:                       whereHelperstring{field: "\"users\".\"id\""},
	Email:                    whereHelpernull_String{field: "\"users\".\"email\""},
	Username:                 whereHelpernull_String{field: "\"users\".\"username\""},
	Firstname:                whereHelpernull_String{field: "\"users\".\"firstname\""},
	Lastname:                 whereHelpernull_String{field: "\"users\".\"lastname\""},
	Defaultshippingaddressid: whereHelpernull_String{field: "\"users\".\"defaultshippingaddressid\""},
	Defaultbillingaddressid:  whereHelpernull_String{field: "\"users\".\"defaultbillingaddressid\""},
	Password:                 whereHelpernull_String{field: "\"users\".\"password\""},
	Authdata:                 whereHelpernull_String{field: "\"users\".\"authdata\""},
	Authservice:              whereHelpernull_String{field: "\"users\".\"authservice\""},
	Emailverified:            whereHelpernull_Bool{field: "\"users\".\"emailverified\""},
	Nickname:                 whereHelpernull_String{field: "\"users\".\"nickname\""},
	Roles:                    whereHelpernull_String{field: "\"users\".\"roles\""},
	Props:                    whereHelpernull_JSON{field: "\"users\".\"props\""},
	Notifyprops:              whereHelpernull_JSON{field: "\"users\".\"notifyprops\""},
	Lastpasswordupdate:       whereHelpernull_Int64{field: "\"users\".\"lastpasswordupdate\""},
	Lastpictureupdate:        whereHelpernull_Int64{field: "\"users\".\"lastpictureupdate\""},
	Failedattempts:           whereHelpernull_Int{field: "\"users\".\"failedattempts\""},
	Locale:                   whereHelpernull_String{field: "\"users\".\"locale\""},
	Timezone:                 whereHelpernull_JSON{field: "\"users\".\"timezone\""},
	Mfaactive:                whereHelpernull_Bool{field: "\"users\".\"mfaactive\""},
	Mfasecret:                whereHelpernull_String{field: "\"users\".\"mfasecret\""},
	Createat:                 whereHelpernull_Int64{field: "\"users\".\"createat\""},
	Updateat:                 whereHelpernull_Int64{field: "\"users\".\"updateat\""},
	Deleteat:                 whereHelpernull_Int64{field: "\"users\".\"deleteat\""},
	Isactive:                 whereHelpernull_Bool{field: "\"users\".\"isactive\""},
	Note:                     whereHelpernull_String{field: "\"users\".\"note\""},
	Jwttokenkey:              whereHelpernull_String{field: "\"users\".\"jwttokenkey\""},
	Metadata:                 whereHelpernull_JSON{field: "\"users\".\"metadata\""},
	Privatemetadata:          whereHelpernull_JSON{field: "\"users\".\"privatemetadata\""},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	DefaultshippingaddressidAddress   string
	UseridWishlist                    string
	UseridCheckouts                   string
	UseridCustomerEvents              string
	UseridCustomerNotes               string
	UseridExportEvents                string
	UseridExportFiles                 string
	UsedbyidGiftcards                 string
	CreatedbyidGiftcards              string
	UseridInvoiceEvents               string
	UseridOrderEvents                 string
	UseridOrders                      string
	StaffidShopStaffs                 string
	UseridStaffNotificationRecipients string
	UseridUserAddresses               string
}{
	DefaultshippingaddressidAddress:   "DefaultshippingaddressidAddress",
	UseridWishlist:                    "UseridWishlist",
	UseridCheckouts:                   "UseridCheckouts",
	UseridCustomerEvents:              "UseridCustomerEvents",
	UseridCustomerNotes:               "UseridCustomerNotes",
	UseridExportEvents:                "UseridExportEvents",
	UseridExportFiles:                 "UseridExportFiles",
	UsedbyidGiftcards:                 "UsedbyidGiftcards",
	CreatedbyidGiftcards:              "CreatedbyidGiftcards",
	UseridInvoiceEvents:               "UseridInvoiceEvents",
	UseridOrderEvents:                 "UseridOrderEvents",
	UseridOrders:                      "UseridOrders",
	StaffidShopStaffs:                 "StaffidShopStaffs",
	UseridStaffNotificationRecipients: "UseridStaffNotificationRecipients",
	UseridUserAddresses:               "UseridUserAddresses",
}

// userR is where relationships are stored.
type userR struct {
	DefaultshippingaddressidAddress   *Address                        `boil:"DefaultshippingaddressidAddress" json:"DefaultshippingaddressidAddress" toml:"DefaultshippingaddressidAddress" yaml:"DefaultshippingaddressidAddress"`
	UseridWishlist                    *Wishlist                       `boil:"UseridWishlist" json:"UseridWishlist" toml:"UseridWishlist" yaml:"UseridWishlist"`
	UseridCheckouts                   CheckoutSlice                   `boil:"UseridCheckouts" json:"UseridCheckouts" toml:"UseridCheckouts" yaml:"UseridCheckouts"`
	UseridCustomerEvents              CustomerEventSlice              `boil:"UseridCustomerEvents" json:"UseridCustomerEvents" toml:"UseridCustomerEvents" yaml:"UseridCustomerEvents"`
	UseridCustomerNotes               CustomerNoteSlice               `boil:"UseridCustomerNotes" json:"UseridCustomerNotes" toml:"UseridCustomerNotes" yaml:"UseridCustomerNotes"`
	UseridExportEvents                ExportEventSlice                `boil:"UseridExportEvents" json:"UseridExportEvents" toml:"UseridExportEvents" yaml:"UseridExportEvents"`
	UseridExportFiles                 ExportFileSlice                 `boil:"UseridExportFiles" json:"UseridExportFiles" toml:"UseridExportFiles" yaml:"UseridExportFiles"`
	UsedbyidGiftcards                 GiftcardSlice                   `boil:"UsedbyidGiftcards" json:"UsedbyidGiftcards" toml:"UsedbyidGiftcards" yaml:"UsedbyidGiftcards"`
	CreatedbyidGiftcards              GiftcardSlice                   `boil:"CreatedbyidGiftcards" json:"CreatedbyidGiftcards" toml:"CreatedbyidGiftcards" yaml:"CreatedbyidGiftcards"`
	UseridInvoiceEvents               InvoiceEventSlice               `boil:"UseridInvoiceEvents" json:"UseridInvoiceEvents" toml:"UseridInvoiceEvents" yaml:"UseridInvoiceEvents"`
	UseridOrderEvents                 OrderEventSlice                 `boil:"UseridOrderEvents" json:"UseridOrderEvents" toml:"UseridOrderEvents" yaml:"UseridOrderEvents"`
	UseridOrders                      OrderSlice                      `boil:"UseridOrders" json:"UseridOrders" toml:"UseridOrders" yaml:"UseridOrders"`
	StaffidShopStaffs                 ShopStaffSlice                  `boil:"StaffidShopStaffs" json:"StaffidShopStaffs" toml:"StaffidShopStaffs" yaml:"StaffidShopStaffs"`
	UseridStaffNotificationRecipients StaffNotificationRecipientSlice `boil:"UseridStaffNotificationRecipients" json:"UseridStaffNotificationRecipients" toml:"UseridStaffNotificationRecipients" yaml:"UseridStaffNotificationRecipients"`
	UseridUserAddresses               UserAddressSlice                `boil:"UseridUserAddresses" json:"UseridUserAddresses" toml:"UseridUserAddresses" yaml:"UseridUserAddresses"`
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

func (r *userR) GetDefaultshippingaddressidAddress() *Address {
	if r == nil {
		return nil
	}
	return r.DefaultshippingaddressidAddress
}

func (r *userR) GetUseridWishlist() *Wishlist {
	if r == nil {
		return nil
	}
	return r.UseridWishlist
}

func (r *userR) GetUseridCheckouts() CheckoutSlice {
	if r == nil {
		return nil
	}
	return r.UseridCheckouts
}

func (r *userR) GetUseridCustomerEvents() CustomerEventSlice {
	if r == nil {
		return nil
	}
	return r.UseridCustomerEvents
}

func (r *userR) GetUseridCustomerNotes() CustomerNoteSlice {
	if r == nil {
		return nil
	}
	return r.UseridCustomerNotes
}

func (r *userR) GetUseridExportEvents() ExportEventSlice {
	if r == nil {
		return nil
	}
	return r.UseridExportEvents
}

func (r *userR) GetUseridExportFiles() ExportFileSlice {
	if r == nil {
		return nil
	}
	return r.UseridExportFiles
}

func (r *userR) GetUsedbyidGiftcards() GiftcardSlice {
	if r == nil {
		return nil
	}
	return r.UsedbyidGiftcards
}

func (r *userR) GetCreatedbyidGiftcards() GiftcardSlice {
	if r == nil {
		return nil
	}
	return r.CreatedbyidGiftcards
}

func (r *userR) GetUseridInvoiceEvents() InvoiceEventSlice {
	if r == nil {
		return nil
	}
	return r.UseridInvoiceEvents
}

func (r *userR) GetUseridOrderEvents() OrderEventSlice {
	if r == nil {
		return nil
	}
	return r.UseridOrderEvents
}

func (r *userR) GetUseridOrders() OrderSlice {
	if r == nil {
		return nil
	}
	return r.UseridOrders
}

func (r *userR) GetStaffidShopStaffs() ShopStaffSlice {
	if r == nil {
		return nil
	}
	return r.StaffidShopStaffs
}

func (r *userR) GetUseridStaffNotificationRecipients() StaffNotificationRecipientSlice {
	if r == nil {
		return nil
	}
	return r.UseridStaffNotificationRecipients
}

func (r *userR) GetUseridUserAddresses() UserAddressSlice {
	if r == nil {
		return nil
	}
	return r.UseridUserAddresses
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"id", "email", "username", "firstname", "lastname", "defaultshippingaddressid", "defaultbillingaddressid", "password", "authdata", "authservice", "emailverified", "nickname", "roles", "props", "notifyprops", "lastpasswordupdate", "lastpictureupdate", "failedattempts", "locale", "timezone", "mfaactive", "mfasecret", "createat", "updateat", "deleteat", "isactive", "note", "jwttokenkey", "metadata", "privatemetadata"}
	userColumnsWithoutDefault = []string{"id"}
	userColumnsWithDefault    = []string{"email", "username", "firstname", "lastname", "defaultshippingaddressid", "defaultbillingaddressid", "password", "authdata", "authservice", "emailverified", "nickname", "roles", "props", "notifyprops", "lastpasswordupdate", "lastpictureupdate", "failedattempts", "locale", "timezone", "mfaactive", "mfasecret", "createat", "updateat", "deleteat", "isactive", "note", "jwttokenkey", "metadata", "privatemetadata"}
	userPrimaryKeyColumns     = []string{"id"}
	userGeneratedColumns      = []string{}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should almost always be used instead of []User.
	UserSlice []*User
	// UserHook is the signature for custom User hook methods
	UserHook func(context.Context, boil.ContextExecutor, *User) error

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var userAfterSelectHooks []UserHook

var userBeforeInsertHooks []UserHook
var userAfterInsertHooks []UserHook

var userBeforeUpdateHooks []UserHook
var userAfterUpdateHooks []UserHook

var userBeforeDeleteHooks []UserHook
var userAfterDeleteHooks []UserHook

var userBeforeUpsertHooks []UserHook
var userAfterUpsertHooks []UserHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *User) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *User) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *User) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *User) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *User) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *User) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *User) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *User) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *User) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserHook registers your hook function for all future operations.
func AddUserHook(hookPoint boil.HookPoint, userHook UserHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		userAfterSelectHooks = append(userAfterSelectHooks, userHook)
	case boil.BeforeInsertHook:
		userBeforeInsertHooks = append(userBeforeInsertHooks, userHook)
	case boil.AfterInsertHook:
		userAfterInsertHooks = append(userAfterInsertHooks, userHook)
	case boil.BeforeUpdateHook:
		userBeforeUpdateHooks = append(userBeforeUpdateHooks, userHook)
	case boil.AfterUpdateHook:
		userAfterUpdateHooks = append(userAfterUpdateHooks, userHook)
	case boil.BeforeDeleteHook:
		userBeforeDeleteHooks = append(userBeforeDeleteHooks, userHook)
	case boil.AfterDeleteHook:
		userAfterDeleteHooks = append(userAfterDeleteHooks, userHook)
	case boil.BeforeUpsertHook:
		userBeforeUpsertHooks = append(userBeforeUpsertHooks, userHook)
	case boil.AfterUpsertHook:
		userAfterUpsertHooks = append(userAfterUpsertHooks, userHook)
	}
}

// One returns a single user record from the query.
func (q userQuery) One(ctx context.Context, exec boil.ContextExecutor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for users")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserSlice, error) {
	var o []*User

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to User slice")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count users rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if users exists")
	}

	return count > 0, nil
}

// DefaultshippingaddressidAddress pointed to by the foreign key.
func (o *User) DefaultshippingaddressidAddress(mods ...qm.QueryMod) addressQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.Defaultshippingaddressid),
	}

	queryMods = append(queryMods, mods...)

	return Addresses(queryMods...)
}

// UseridWishlist pointed to by the foreign key.
func (o *User) UseridWishlist(mods ...qm.QueryMod) wishlistQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"userid\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return Wishlists(queryMods...)
}

// UseridCheckouts retrieves all the checkout's Checkouts with an executor via userid column.
func (o *User) UseridCheckouts(mods ...qm.QueryMod) checkoutQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"checkouts\".\"userid\"=?", o.ID),
	)

	return Checkouts(queryMods...)
}

// UseridCustomerEvents retrieves all the customer_event's CustomerEvents with an executor via userid column.
func (o *User) UseridCustomerEvents(mods ...qm.QueryMod) customerEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"customer_events\".\"userid\"=?", o.ID),
	)

	return CustomerEvents(queryMods...)
}

// UseridCustomerNotes retrieves all the customer_note's CustomerNotes with an executor via userid column.
func (o *User) UseridCustomerNotes(mods ...qm.QueryMod) customerNoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"customer_notes\".\"userid\"=?", o.ID),
	)

	return CustomerNotes(queryMods...)
}

// UseridExportEvents retrieves all the export_event's ExportEvents with an executor via userid column.
func (o *User) UseridExportEvents(mods ...qm.QueryMod) exportEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"export_events\".\"userid\"=?", o.ID),
	)

	return ExportEvents(queryMods...)
}

// UseridExportFiles retrieves all the export_file's ExportFiles with an executor via userid column.
func (o *User) UseridExportFiles(mods ...qm.QueryMod) exportFileQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"export_files\".\"userid\"=?", o.ID),
	)

	return ExportFiles(queryMods...)
}

// UsedbyidGiftcards retrieves all the giftcard's Giftcards with an executor via usedbyid column.
func (o *User) UsedbyidGiftcards(mods ...qm.QueryMod) giftcardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"giftcards\".\"usedbyid\"=?", o.ID),
	)

	return Giftcards(queryMods...)
}

// CreatedbyidGiftcards retrieves all the giftcard's Giftcards with an executor via createdbyid column.
func (o *User) CreatedbyidGiftcards(mods ...qm.QueryMod) giftcardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"giftcards\".\"createdbyid\"=?", o.ID),
	)

	return Giftcards(queryMods...)
}

// UseridInvoiceEvents retrieves all the invoice_event's InvoiceEvents with an executor via userid column.
func (o *User) UseridInvoiceEvents(mods ...qm.QueryMod) invoiceEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"invoice_events\".\"userid\"=?", o.ID),
	)

	return InvoiceEvents(queryMods...)
}

// UseridOrderEvents retrieves all the order_event's OrderEvents with an executor via userid column.
func (o *User) UseridOrderEvents(mods ...qm.QueryMod) orderEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"order_events\".\"userid\"=?", o.ID),
	)

	return OrderEvents(queryMods...)
}

// UseridOrders retrieves all the order's Orders with an executor via userid column.
func (o *User) UseridOrders(mods ...qm.QueryMod) orderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"orders\".\"userid\"=?", o.ID),
	)

	return Orders(queryMods...)
}

// StaffidShopStaffs retrieves all the shop_staff's ShopStaffs with an executor via staffid column.
func (o *User) StaffidShopStaffs(mods ...qm.QueryMod) shopStaffQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"shop_staffs\".\"staffid\"=?", o.ID),
	)

	return ShopStaffs(queryMods...)
}

// UseridStaffNotificationRecipients retrieves all the staff_notification_recipient's StaffNotificationRecipients with an executor via userid column.
func (o *User) UseridStaffNotificationRecipients(mods ...qm.QueryMod) staffNotificationRecipientQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"staff_notification_recipients\".\"userid\"=?", o.ID),
	)

	return StaffNotificationRecipients(queryMods...)
}

// UseridUserAddresses retrieves all the user_address's UserAddresses with an executor via userid column.
func (o *User) UseridUserAddresses(mods ...qm.QueryMod) userAddressQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_addresses\".\"userid\"=?", o.ID),
	)

	return UserAddresses(queryMods...)
}

// LoadDefaultshippingaddressidAddress allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadDefaultshippingaddressidAddress(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.Defaultshippingaddressid) {
			args = append(args, object.Defaultshippingaddressid)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Defaultshippingaddressid) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Defaultshippingaddressid) {
				args = append(args, obj.Defaultshippingaddressid)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`addresses`),
		qm.WhereIn(`addresses.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Address")
	}

	var resultSlice []*Address
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Address")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for addresses")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for addresses")
	}

	if len(addressAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DefaultshippingaddressidAddress = foreign
		if foreign.R == nil {
			foreign.R = &addressR{}
		}
		foreign.R.DefaultshippingaddressidUsers = append(foreign.R.DefaultshippingaddressidUsers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Defaultshippingaddressid, foreign.ID) {
				local.R.DefaultshippingaddressidAddress = foreign
				if foreign.R == nil {
					foreign.R = &addressR{}
				}
				foreign.R.DefaultshippingaddressidUsers = append(foreign.R.DefaultshippingaddressidUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadUseridWishlist allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadUseridWishlist(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`wishlists`),
		qm.WhereIn(`wishlists.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Wishlist")
	}

	var resultSlice []*Wishlist
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Wishlist")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for wishlists")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wishlists")
	}

	if len(wishlistAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UseridWishlist = foreign
		if foreign.R == nil {
			foreign.R = &wishlistR{}
		}
		foreign.R.UseridUser = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridWishlist = foreign
				if foreign.R == nil {
					foreign.R = &wishlistR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridCheckouts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridCheckouts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`checkouts`),
		qm.WhereIn(`checkouts.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load checkouts")
	}

	var resultSlice []*Checkout
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice checkouts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on checkouts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for checkouts")
	}

	if len(checkoutAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridCheckouts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &checkoutR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridCheckouts = append(local.R.UseridCheckouts, foreign)
				if foreign.R == nil {
					foreign.R = &checkoutR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridCustomerEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridCustomerEvents(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`customer_events`),
		qm.WhereIn(`customer_events.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_events")
	}

	var resultSlice []*CustomerEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_events")
	}

	if len(customerEventAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridCustomerEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerEventR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridCustomerEvents = append(local.R.UseridCustomerEvents, foreign)
				if foreign.R == nil {
					foreign.R = &customerEventR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridCustomerNotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridCustomerNotes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`customer_notes`),
		qm.WhereIn(`customer_notes.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_notes")
	}

	var resultSlice []*CustomerNote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_notes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_notes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_notes")
	}

	if len(customerNoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridCustomerNotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerNoteR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridCustomerNotes = append(local.R.UseridCustomerNotes, foreign)
				if foreign.R == nil {
					foreign.R = &customerNoteR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridExportEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridExportEvents(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`export_events`),
		qm.WhereIn(`export_events.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load export_events")
	}

	var resultSlice []*ExportEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice export_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on export_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for export_events")
	}

	if len(exportEventAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridExportEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &exportEventR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridExportEvents = append(local.R.UseridExportEvents, foreign)
				if foreign.R == nil {
					foreign.R = &exportEventR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridExportFiles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridExportFiles(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`export_files`),
		qm.WhereIn(`export_files.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load export_files")
	}

	var resultSlice []*ExportFile
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice export_files")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on export_files")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for export_files")
	}

	if len(exportFileAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridExportFiles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &exportFileR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridExportFiles = append(local.R.UseridExportFiles, foreign)
				if foreign.R == nil {
					foreign.R = &exportFileR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUsedbyidGiftcards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUsedbyidGiftcards(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`giftcards`),
		qm.WhereIn(`giftcards.usedbyid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load giftcards")
	}

	var resultSlice []*Giftcard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice giftcards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on giftcards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for giftcards")
	}

	if len(giftcardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UsedbyidGiftcards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &giftcardR{}
			}
			foreign.R.UsedbyidUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Usedbyid) {
				local.R.UsedbyidGiftcards = append(local.R.UsedbyidGiftcards, foreign)
				if foreign.R == nil {
					foreign.R = &giftcardR{}
				}
				foreign.R.UsedbyidUser = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedbyidGiftcards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedbyidGiftcards(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`giftcards`),
		qm.WhereIn(`giftcards.createdbyid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load giftcards")
	}

	var resultSlice []*Giftcard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice giftcards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on giftcards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for giftcards")
	}

	if len(giftcardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedbyidGiftcards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &giftcardR{}
			}
			foreign.R.CreatedbyidUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Createdbyid) {
				local.R.CreatedbyidGiftcards = append(local.R.CreatedbyidGiftcards, foreign)
				if foreign.R == nil {
					foreign.R = &giftcardR{}
				}
				foreign.R.CreatedbyidUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridInvoiceEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridInvoiceEvents(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`invoice_events`),
		qm.WhereIn(`invoice_events.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load invoice_events")
	}

	var resultSlice []*InvoiceEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice invoice_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on invoice_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for invoice_events")
	}

	if len(invoiceEventAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridInvoiceEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &invoiceEventR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridInvoiceEvents = append(local.R.UseridInvoiceEvents, foreign)
				if foreign.R == nil {
					foreign.R = &invoiceEventR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridOrderEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridOrderEvents(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`order_events`),
		qm.WhereIn(`order_events.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load order_events")
	}

	var resultSlice []*OrderEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice order_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on order_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for order_events")
	}

	if len(orderEventAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridOrderEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderEventR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridOrderEvents = append(local.R.UseridOrderEvents, foreign)
				if foreign.R == nil {
					foreign.R = &orderEventR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridOrders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridOrders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`orders`),
		qm.WhereIn(`orders.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load orders")
	}

	var resultSlice []*Order
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice orders")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on orders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orders")
	}

	if len(orderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridOrders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridOrders = append(local.R.UseridOrders, foreign)
				if foreign.R == nil {
					foreign.R = &orderR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadStaffidShopStaffs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadStaffidShopStaffs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`shop_staffs`),
		qm.WhereIn(`shop_staffs.staffid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load shop_staffs")
	}

	var resultSlice []*ShopStaff
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice shop_staffs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on shop_staffs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for shop_staffs")
	}

	if len(shopStaffAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StaffidShopStaffs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &shopStaffR{}
			}
			foreign.R.StaffidUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Staffid) {
				local.R.StaffidShopStaffs = append(local.R.StaffidShopStaffs, foreign)
				if foreign.R == nil {
					foreign.R = &shopStaffR{}
				}
				foreign.R.StaffidUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridStaffNotificationRecipients allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridStaffNotificationRecipients(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`staff_notification_recipients`),
		qm.WhereIn(`staff_notification_recipients.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load staff_notification_recipients")
	}

	var resultSlice []*StaffNotificationRecipient
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice staff_notification_recipients")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on staff_notification_recipients")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for staff_notification_recipients")
	}

	if len(staffNotificationRecipientAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridStaffNotificationRecipients = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &staffNotificationRecipientR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridStaffNotificationRecipients = append(local.R.UseridStaffNotificationRecipients, foreign)
				if foreign.R == nil {
					foreign.R = &staffNotificationRecipientR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// LoadUseridUserAddresses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUseridUserAddresses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_addresses`),
		qm.WhereIn(`user_addresses.userid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_addresses")
	}

	var resultSlice []*UserAddress
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_addresses")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_addresses")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_addresses")
	}

	if len(userAddressAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UseridUserAddresses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAddressR{}
			}
			foreign.R.UseridUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.Userid) {
				local.R.UseridUserAddresses = append(local.R.UseridUserAddresses, foreign)
				if foreign.R == nil {
					foreign.R = &userAddressR{}
				}
				foreign.R.UseridUser = local
				break
			}
		}
	}

	return nil
}

// SetDefaultshippingaddressidAddress of the user to the related item.
// Sets o.R.DefaultshippingaddressidAddress to related.
// Adds o to related.R.DefaultshippingaddressidUsers.
func (o *User) SetDefaultshippingaddressidAddress(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Address) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"defaultshippingaddressid"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Defaultshippingaddressid, related.ID)
	if o.R == nil {
		o.R = &userR{
			DefaultshippingaddressidAddress: related,
		}
	} else {
		o.R.DefaultshippingaddressidAddress = related
	}

	if related.R == nil {
		related.R = &addressR{
			DefaultshippingaddressidUsers: UserSlice{o},
		}
	} else {
		related.R.DefaultshippingaddressidUsers = append(related.R.DefaultshippingaddressidUsers, o)
	}

	return nil
}

// RemoveDefaultshippingaddressidAddress relationship.
// Sets o.R.DefaultshippingaddressidAddress to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveDefaultshippingaddressidAddress(ctx context.Context, exec boil.ContextExecutor, related *Address) error {
	var err error

	queries.SetScanner(&o.Defaultshippingaddressid, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("defaultshippingaddressid")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DefaultshippingaddressidAddress = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DefaultshippingaddressidUsers {
		if queries.Equal(o.Defaultshippingaddressid, ri.Defaultshippingaddressid) {
			continue
		}

		ln := len(related.R.DefaultshippingaddressidUsers)
		if ln > 1 && i < ln-1 {
			related.R.DefaultshippingaddressidUsers[i] = related.R.DefaultshippingaddressidUsers[ln-1]
		}
		related.R.DefaultshippingaddressidUsers = related.R.DefaultshippingaddressidUsers[:ln-1]
		break
	}
	return nil
}

// SetUseridWishlist of the user to the related item.
// Sets o.R.UseridWishlist to related.
// Adds o to related.R.UseridUser.
func (o *User) SetUseridWishlist(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Wishlist) error {
	var err error

	if insert {
		queries.Assign(&related.Userid, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"wishlists\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
			strmangle.WhereClause("\"", "\"", 2, wishlistPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.Userid, o.ID)
	}

	if o.R == nil {
		o.R = &userR{
			UseridWishlist: related,
		}
	} else {
		o.R.UseridWishlist = related
	}

	if related.R == nil {
		related.R = &wishlistR{
			UseridUser: o,
		}
	} else {
		related.R.UseridUser = o
	}
	return nil
}

// RemoveUseridWishlist relationship.
// Sets o.R.UseridWishlist to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveUseridWishlist(ctx context.Context, exec boil.ContextExecutor, related *Wishlist) error {
	var err error

	queries.SetScanner(&related.Userid, nil)
	if _, err = related.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.UseridWishlist = nil
	}

	if related == nil || related.R == nil {
		return nil
	}

	related.R.UseridUser = nil

	return nil
}

// AddUseridCheckouts adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridCheckouts.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridCheckouts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Checkout) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"checkouts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, checkoutPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.Token}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridCheckouts: related,
		}
	} else {
		o.R.UseridCheckouts = append(o.R.UseridCheckouts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &checkoutR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridCheckouts removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridCheckouts accordingly.
// Replaces o.R.UseridCheckouts with related.
// Sets related.R.UseridUser's UseridCheckouts accordingly.
func (o *User) SetUseridCheckouts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Checkout) error {
	query := "update \"checkouts\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridCheckouts {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridCheckouts = nil
	}

	return o.AddUseridCheckouts(ctx, exec, insert, related...)
}

// RemoveUseridCheckouts relationships from objects passed in.
// Removes related items from R.UseridCheckouts (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridCheckouts(ctx context.Context, exec boil.ContextExecutor, related ...*Checkout) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridCheckouts {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridCheckouts)
			if ln > 1 && i < ln-1 {
				o.R.UseridCheckouts[i] = o.R.UseridCheckouts[ln-1]
			}
			o.R.UseridCheckouts = o.R.UseridCheckouts[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridCustomerEvents adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridCustomerEvents.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridCustomerEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"customer_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, customerEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridCustomerEvents: related,
		}
	} else {
		o.R.UseridCustomerEvents = append(o.R.UseridCustomerEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerEventR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridCustomerEvents removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridCustomerEvents accordingly.
// Replaces o.R.UseridCustomerEvents with related.
// Sets related.R.UseridUser's UseridCustomerEvents accordingly.
func (o *User) SetUseridCustomerEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerEvent) error {
	query := "update \"customer_events\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridCustomerEvents {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridCustomerEvents = nil
	}

	return o.AddUseridCustomerEvents(ctx, exec, insert, related...)
}

// RemoveUseridCustomerEvents relationships from objects passed in.
// Removes related items from R.UseridCustomerEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridCustomerEvents(ctx context.Context, exec boil.ContextExecutor, related ...*CustomerEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridCustomerEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridCustomerEvents)
			if ln > 1 && i < ln-1 {
				o.R.UseridCustomerEvents[i] = o.R.UseridCustomerEvents[ln-1]
			}
			o.R.UseridCustomerEvents = o.R.UseridCustomerEvents[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridCustomerNotes adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridCustomerNotes.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridCustomerNotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerNote) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"customer_notes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, customerNotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridCustomerNotes: related,
		}
	} else {
		o.R.UseridCustomerNotes = append(o.R.UseridCustomerNotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerNoteR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridCustomerNotes removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridCustomerNotes accordingly.
// Replaces o.R.UseridCustomerNotes with related.
// Sets related.R.UseridUser's UseridCustomerNotes accordingly.
func (o *User) SetUseridCustomerNotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerNote) error {
	query := "update \"customer_notes\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridCustomerNotes {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridCustomerNotes = nil
	}

	return o.AddUseridCustomerNotes(ctx, exec, insert, related...)
}

// RemoveUseridCustomerNotes relationships from objects passed in.
// Removes related items from R.UseridCustomerNotes (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridCustomerNotes(ctx context.Context, exec boil.ContextExecutor, related ...*CustomerNote) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridCustomerNotes {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridCustomerNotes)
			if ln > 1 && i < ln-1 {
				o.R.UseridCustomerNotes[i] = o.R.UseridCustomerNotes[ln-1]
			}
			o.R.UseridCustomerNotes = o.R.UseridCustomerNotes[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridExportEvents adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridExportEvents.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridExportEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ExportEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"export_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, exportEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridExportEvents: related,
		}
	} else {
		o.R.UseridExportEvents = append(o.R.UseridExportEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &exportEventR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridExportEvents removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridExportEvents accordingly.
// Replaces o.R.UseridExportEvents with related.
// Sets related.R.UseridUser's UseridExportEvents accordingly.
func (o *User) SetUseridExportEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ExportEvent) error {
	query := "update \"export_events\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridExportEvents {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridExportEvents = nil
	}

	return o.AddUseridExportEvents(ctx, exec, insert, related...)
}

// RemoveUseridExportEvents relationships from objects passed in.
// Removes related items from R.UseridExportEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridExportEvents(ctx context.Context, exec boil.ContextExecutor, related ...*ExportEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridExportEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridExportEvents)
			if ln > 1 && i < ln-1 {
				o.R.UseridExportEvents[i] = o.R.UseridExportEvents[ln-1]
			}
			o.R.UseridExportEvents = o.R.UseridExportEvents[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridExportFiles adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridExportFiles.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridExportFiles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ExportFile) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"export_files\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, exportFilePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridExportFiles: related,
		}
	} else {
		o.R.UseridExportFiles = append(o.R.UseridExportFiles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &exportFileR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridExportFiles removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridExportFiles accordingly.
// Replaces o.R.UseridExportFiles with related.
// Sets related.R.UseridUser's UseridExportFiles accordingly.
func (o *User) SetUseridExportFiles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ExportFile) error {
	query := "update \"export_files\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridExportFiles {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridExportFiles = nil
	}

	return o.AddUseridExportFiles(ctx, exec, insert, related...)
}

// RemoveUseridExportFiles relationships from objects passed in.
// Removes related items from R.UseridExportFiles (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridExportFiles(ctx context.Context, exec boil.ContextExecutor, related ...*ExportFile) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridExportFiles {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridExportFiles)
			if ln > 1 && i < ln-1 {
				o.R.UseridExportFiles[i] = o.R.UseridExportFiles[ln-1]
			}
			o.R.UseridExportFiles = o.R.UseridExportFiles[:ln-1]
			break
		}
	}

	return nil
}

// AddUsedbyidGiftcards adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UsedbyidGiftcards.
// Sets related.R.UsedbyidUser appropriately.
func (o *User) AddUsedbyidGiftcards(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Giftcard) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Usedbyid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"giftcards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"usedbyid"}),
				strmangle.WhereClause("\"", "\"", 2, giftcardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Usedbyid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UsedbyidGiftcards: related,
		}
	} else {
		o.R.UsedbyidGiftcards = append(o.R.UsedbyidGiftcards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &giftcardR{
				UsedbyidUser: o,
			}
		} else {
			rel.R.UsedbyidUser = o
		}
	}
	return nil
}

// SetUsedbyidGiftcards removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UsedbyidUser's UsedbyidGiftcards accordingly.
// Replaces o.R.UsedbyidGiftcards with related.
// Sets related.R.UsedbyidUser's UsedbyidGiftcards accordingly.
func (o *User) SetUsedbyidGiftcards(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Giftcard) error {
	query := "update \"giftcards\" set \"usedbyid\" = null where \"usedbyid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UsedbyidGiftcards {
			queries.SetScanner(&rel.Usedbyid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UsedbyidUser = nil
		}
		o.R.UsedbyidGiftcards = nil
	}

	return o.AddUsedbyidGiftcards(ctx, exec, insert, related...)
}

// RemoveUsedbyidGiftcards relationships from objects passed in.
// Removes related items from R.UsedbyidGiftcards (uses pointer comparison, removal does not keep order)
// Sets related.R.UsedbyidUser.
func (o *User) RemoveUsedbyidGiftcards(ctx context.Context, exec boil.ContextExecutor, related ...*Giftcard) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Usedbyid, nil)
		if rel.R != nil {
			rel.R.UsedbyidUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("usedbyid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UsedbyidGiftcards {
			if rel != ri {
				continue
			}

			ln := len(o.R.UsedbyidGiftcards)
			if ln > 1 && i < ln-1 {
				o.R.UsedbyidGiftcards[i] = o.R.UsedbyidGiftcards[ln-1]
			}
			o.R.UsedbyidGiftcards = o.R.UsedbyidGiftcards[:ln-1]
			break
		}
	}

	return nil
}

// AddCreatedbyidGiftcards adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedbyidGiftcards.
// Sets related.R.CreatedbyidUser appropriately.
func (o *User) AddCreatedbyidGiftcards(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Giftcard) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Createdbyid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"giftcards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"createdbyid"}),
				strmangle.WhereClause("\"", "\"", 2, giftcardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Createdbyid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedbyidGiftcards: related,
		}
	} else {
		o.R.CreatedbyidGiftcards = append(o.R.CreatedbyidGiftcards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &giftcardR{
				CreatedbyidUser: o,
			}
		} else {
			rel.R.CreatedbyidUser = o
		}
	}
	return nil
}

// SetCreatedbyidGiftcards removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CreatedbyidUser's CreatedbyidGiftcards accordingly.
// Replaces o.R.CreatedbyidGiftcards with related.
// Sets related.R.CreatedbyidUser's CreatedbyidGiftcards accordingly.
func (o *User) SetCreatedbyidGiftcards(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Giftcard) error {
	query := "update \"giftcards\" set \"createdbyid\" = null where \"createdbyid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatedbyidGiftcards {
			queries.SetScanner(&rel.Createdbyid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CreatedbyidUser = nil
		}
		o.R.CreatedbyidGiftcards = nil
	}

	return o.AddCreatedbyidGiftcards(ctx, exec, insert, related...)
}

// RemoveCreatedbyidGiftcards relationships from objects passed in.
// Removes related items from R.CreatedbyidGiftcards (uses pointer comparison, removal does not keep order)
// Sets related.R.CreatedbyidUser.
func (o *User) RemoveCreatedbyidGiftcards(ctx context.Context, exec boil.ContextExecutor, related ...*Giftcard) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Createdbyid, nil)
		if rel.R != nil {
			rel.R.CreatedbyidUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("createdbyid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatedbyidGiftcards {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatedbyidGiftcards)
			if ln > 1 && i < ln-1 {
				o.R.CreatedbyidGiftcards[i] = o.R.CreatedbyidGiftcards[ln-1]
			}
			o.R.CreatedbyidGiftcards = o.R.CreatedbyidGiftcards[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridInvoiceEvents adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridInvoiceEvents.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridInvoiceEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*InvoiceEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"invoice_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, invoiceEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridInvoiceEvents: related,
		}
	} else {
		o.R.UseridInvoiceEvents = append(o.R.UseridInvoiceEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &invoiceEventR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridInvoiceEvents removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridInvoiceEvents accordingly.
// Replaces o.R.UseridInvoiceEvents with related.
// Sets related.R.UseridUser's UseridInvoiceEvents accordingly.
func (o *User) SetUseridInvoiceEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*InvoiceEvent) error {
	query := "update \"invoice_events\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridInvoiceEvents {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridInvoiceEvents = nil
	}

	return o.AddUseridInvoiceEvents(ctx, exec, insert, related...)
}

// RemoveUseridInvoiceEvents relationships from objects passed in.
// Removes related items from R.UseridInvoiceEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridInvoiceEvents(ctx context.Context, exec boil.ContextExecutor, related ...*InvoiceEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridInvoiceEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridInvoiceEvents)
			if ln > 1 && i < ln-1 {
				o.R.UseridInvoiceEvents[i] = o.R.UseridInvoiceEvents[ln-1]
			}
			o.R.UseridInvoiceEvents = o.R.UseridInvoiceEvents[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridOrderEvents adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridOrderEvents.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridOrderEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OrderEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"order_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, orderEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridOrderEvents: related,
		}
	} else {
		o.R.UseridOrderEvents = append(o.R.UseridOrderEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderEventR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridOrderEvents removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridOrderEvents accordingly.
// Replaces o.R.UseridOrderEvents with related.
// Sets related.R.UseridUser's UseridOrderEvents accordingly.
func (o *User) SetUseridOrderEvents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OrderEvent) error {
	query := "update \"order_events\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridOrderEvents {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridOrderEvents = nil
	}

	return o.AddUseridOrderEvents(ctx, exec, insert, related...)
}

// RemoveUseridOrderEvents relationships from objects passed in.
// Removes related items from R.UseridOrderEvents (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridOrderEvents(ctx context.Context, exec boil.ContextExecutor, related ...*OrderEvent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridOrderEvents {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridOrderEvents)
			if ln > 1 && i < ln-1 {
				o.R.UseridOrderEvents[i] = o.R.UseridOrderEvents[ln-1]
			}
			o.R.UseridOrderEvents = o.R.UseridOrderEvents[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridOrders adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridOrders.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridOrders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Order) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"orders\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, orderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridOrders: related,
		}
	} else {
		o.R.UseridOrders = append(o.R.UseridOrders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridOrders removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridOrders accordingly.
// Replaces o.R.UseridOrders with related.
// Sets related.R.UseridUser's UseridOrders accordingly.
func (o *User) SetUseridOrders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Order) error {
	query := "update \"orders\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridOrders {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridOrders = nil
	}

	return o.AddUseridOrders(ctx, exec, insert, related...)
}

// RemoveUseridOrders relationships from objects passed in.
// Removes related items from R.UseridOrders (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridOrders(ctx context.Context, exec boil.ContextExecutor, related ...*Order) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridOrders {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridOrders)
			if ln > 1 && i < ln-1 {
				o.R.UseridOrders[i] = o.R.UseridOrders[ln-1]
			}
			o.R.UseridOrders = o.R.UseridOrders[:ln-1]
			break
		}
	}

	return nil
}

// AddStaffidShopStaffs adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.StaffidShopStaffs.
// Sets related.R.StaffidUser appropriately.
func (o *User) AddStaffidShopStaffs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ShopStaff) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Staffid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"shop_staffs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"staffid"}),
				strmangle.WhereClause("\"", "\"", 2, shopStaffPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Staffid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			StaffidShopStaffs: related,
		}
	} else {
		o.R.StaffidShopStaffs = append(o.R.StaffidShopStaffs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &shopStaffR{
				StaffidUser: o,
			}
		} else {
			rel.R.StaffidUser = o
		}
	}
	return nil
}

// SetStaffidShopStaffs removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.StaffidUser's StaffidShopStaffs accordingly.
// Replaces o.R.StaffidShopStaffs with related.
// Sets related.R.StaffidUser's StaffidShopStaffs accordingly.
func (o *User) SetStaffidShopStaffs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ShopStaff) error {
	query := "update \"shop_staffs\" set \"staffid\" = null where \"staffid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.StaffidShopStaffs {
			queries.SetScanner(&rel.Staffid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.StaffidUser = nil
		}
		o.R.StaffidShopStaffs = nil
	}

	return o.AddStaffidShopStaffs(ctx, exec, insert, related...)
}

// RemoveStaffidShopStaffs relationships from objects passed in.
// Removes related items from R.StaffidShopStaffs (uses pointer comparison, removal does not keep order)
// Sets related.R.StaffidUser.
func (o *User) RemoveStaffidShopStaffs(ctx context.Context, exec boil.ContextExecutor, related ...*ShopStaff) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Staffid, nil)
		if rel.R != nil {
			rel.R.StaffidUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("staffid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.StaffidShopStaffs {
			if rel != ri {
				continue
			}

			ln := len(o.R.StaffidShopStaffs)
			if ln > 1 && i < ln-1 {
				o.R.StaffidShopStaffs[i] = o.R.StaffidShopStaffs[ln-1]
			}
			o.R.StaffidShopStaffs = o.R.StaffidShopStaffs[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridStaffNotificationRecipients adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridStaffNotificationRecipients.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridStaffNotificationRecipients(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StaffNotificationRecipient) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"staff_notification_recipients\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, staffNotificationRecipientPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridStaffNotificationRecipients: related,
		}
	} else {
		o.R.UseridStaffNotificationRecipients = append(o.R.UseridStaffNotificationRecipients, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &staffNotificationRecipientR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridStaffNotificationRecipients removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridStaffNotificationRecipients accordingly.
// Replaces o.R.UseridStaffNotificationRecipients with related.
// Sets related.R.UseridUser's UseridStaffNotificationRecipients accordingly.
func (o *User) SetUseridStaffNotificationRecipients(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*StaffNotificationRecipient) error {
	query := "update \"staff_notification_recipients\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridStaffNotificationRecipients {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridStaffNotificationRecipients = nil
	}

	return o.AddUseridStaffNotificationRecipients(ctx, exec, insert, related...)
}

// RemoveUseridStaffNotificationRecipients relationships from objects passed in.
// Removes related items from R.UseridStaffNotificationRecipients (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridStaffNotificationRecipients(ctx context.Context, exec boil.ContextExecutor, related ...*StaffNotificationRecipient) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridStaffNotificationRecipients {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridStaffNotificationRecipients)
			if ln > 1 && i < ln-1 {
				o.R.UseridStaffNotificationRecipients[i] = o.R.UseridStaffNotificationRecipients[ln-1]
			}
			o.R.UseridStaffNotificationRecipients = o.R.UseridStaffNotificationRecipients[:ln-1]
			break
		}
	}

	return nil
}

// AddUseridUserAddresses adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UseridUserAddresses.
// Sets related.R.UseridUser appropriately.
func (o *User) AddUseridUserAddresses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserAddress) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Userid, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_addresses\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"userid"}),
				strmangle.WhereClause("\"", "\"", 2, userAddressPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Userid, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UseridUserAddresses: related,
		}
	} else {
		o.R.UseridUserAddresses = append(o.R.UseridUserAddresses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAddressR{
				UseridUser: o,
			}
		} else {
			rel.R.UseridUser = o
		}
	}
	return nil
}

// SetUseridUserAddresses removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UseridUser's UseridUserAddresses accordingly.
// Replaces o.R.UseridUserAddresses with related.
// Sets related.R.UseridUser's UseridUserAddresses accordingly.
func (o *User) SetUseridUserAddresses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserAddress) error {
	query := "update \"user_addresses\" set \"userid\" = null where \"userid\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UseridUserAddresses {
			queries.SetScanner(&rel.Userid, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UseridUser = nil
		}
		o.R.UseridUserAddresses = nil
	}

	return o.AddUseridUserAddresses(ctx, exec, insert, related...)
}

// RemoveUseridUserAddresses relationships from objects passed in.
// Removes related items from R.UseridUserAddresses (uses pointer comparison, removal does not keep order)
// Sets related.R.UseridUser.
func (o *User) RemoveUseridUserAddresses(ctx context.Context, exec boil.ContextExecutor, related ...*UserAddress) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Userid, nil)
		if rel.R != nil {
			rel.R.UseridUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("userid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UseridUserAddresses {
			if rel != ri {
				continue
			}

			ln := len(o.R.UseridUserAddresses)
			if ln > 1 && i < ln-1 {
				o.R.UseridUserAddresses[i] = o.R.UseridUserAddresses[ln-1]
			}
			o.R.UseridUserAddresses = o.R.UseridUserAddresses[:ln-1]
			break
		}
	}

	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("\"users\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"users\".*"})
	}

	return userQuery{q}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"users\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, userObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from users")
	}

	if err = userObj.doAfterSelectHooks(ctx, exec); err != nil {
		return userObj, err
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no users provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"users\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"users\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into users")
	}

	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update users, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update users row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for users")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for users")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no users provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert users, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(userPrimaryKeyColumns))
			copy(conflict, userPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"users\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert users")
	}

	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no User provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
	sql := "DELETE FROM \"users\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for users")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no userQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for users")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(userBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for users")
	}

	if len(userAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUser(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"users\".* FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"users\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if users exists")
	}

	return exists, nil
}

// Exists checks if the User row exists.
func (o *User) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return UserExists(ctx, exec, o.ID)
}
