// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// OrderLine is an object representing the database table.
type OrderLine struct {
	ID                                string       `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreateAt                          null.Int64   `boil:"create_at" json:"create_at,omitempty" toml:"create_at" yaml:"create_at,omitempty"`
	OrderID                           null.String  `boil:"order_id" json:"order_id,omitempty" toml:"order_id" yaml:"order_id,omitempty"`
	VariantID                         null.String  `boil:"variant_id" json:"variant_id,omitempty" toml:"variant_id" yaml:"variant_id,omitempty"`
	ProductName                       null.String  `boil:"product_name" json:"product_name,omitempty" toml:"product_name" yaml:"product_name,omitempty"`
	VariantName                       null.String  `boil:"variant_name" json:"variant_name,omitempty" toml:"variant_name" yaml:"variant_name,omitempty"`
	TranslatedProductName             null.String  `boil:"translated_product_name" json:"translated_product_name,omitempty" toml:"translated_product_name" yaml:"translated_product_name,omitempty"`
	TranslatedVariantName             null.String  `boil:"translated_variant_name" json:"translated_variant_name,omitempty" toml:"translated_variant_name" yaml:"translated_variant_name,omitempty"`
	ProductSku                        null.String  `boil:"product_sku" json:"product_sku,omitempty" toml:"product_sku" yaml:"product_sku,omitempty"`
	ProductVariantID                  null.String  `boil:"product_variant_id" json:"product_variant_id,omitempty" toml:"product_variant_id" yaml:"product_variant_id,omitempty"`
	IsShippingRequired                null.Bool    `boil:"is_shipping_required" json:"is_shipping_required,omitempty" toml:"is_shipping_required" yaml:"is_shipping_required,omitempty"`
	IsGiftcard                        null.Bool    `boil:"is_giftcard" json:"is_giftcard,omitempty" toml:"is_giftcard" yaml:"is_giftcard,omitempty"`
	Quantity                          null.Int     `boil:"quantity" json:"quantity,omitempty" toml:"quantity" yaml:"quantity,omitempty"`
	QuantityFulfilled                 null.Int     `boil:"quantity_fulfilled" json:"quantity_fulfilled,omitempty" toml:"quantity_fulfilled" yaml:"quantity_fulfilled,omitempty"`
	Currency                          null.String  `boil:"currency" json:"currency,omitempty" toml:"currency" yaml:"currency,omitempty"`
	UnitDiscountAmount                null.Float64 `boil:"unit_discount_amount" json:"unit_discount_amount,omitempty" toml:"unit_discount_amount" yaml:"unit_discount_amount,omitempty"`
	UnitDiscountType                  null.String  `boil:"unit_discount_type" json:"unit_discount_type,omitempty" toml:"unit_discount_type" yaml:"unit_discount_type,omitempty"`
	UnitDiscountReason                null.String  `boil:"unit_discount_reason" json:"unit_discount_reason,omitempty" toml:"unit_discount_reason" yaml:"unit_discount_reason,omitempty"`
	UnitPriceNetAmount                null.Float64 `boil:"unit_price_net_amount" json:"unit_price_net_amount,omitempty" toml:"unit_price_net_amount" yaml:"unit_price_net_amount,omitempty"`
	UnitDiscountValue                 null.Float64 `boil:"unit_discount_value" json:"unit_discount_value,omitempty" toml:"unit_discount_value" yaml:"unit_discount_value,omitempty"`
	UnitPriceGrossAmount              null.Float64 `boil:"unit_price_gross_amount" json:"unit_price_gross_amount,omitempty" toml:"unit_price_gross_amount" yaml:"unit_price_gross_amount,omitempty"`
	TotalPriceNetAmount               null.Float64 `boil:"total_price_net_amount" json:"total_price_net_amount,omitempty" toml:"total_price_net_amount" yaml:"total_price_net_amount,omitempty"`
	TotalPriceGrossAmount             null.Float64 `boil:"total_price_gross_amount" json:"total_price_gross_amount,omitempty" toml:"total_price_gross_amount" yaml:"total_price_gross_amount,omitempty"`
	UndiscountedUnitPriceGrossAmount  null.Float64 `boil:"undiscounted_unit_price_gross_amount" json:"undiscounted_unit_price_gross_amount,omitempty" toml:"undiscounted_unit_price_gross_amount" yaml:"undiscounted_unit_price_gross_amount,omitempty"`
	UndiscountedUnitPriceNetAmount    null.Float64 `boil:"undiscounted_unit_price_net_amount" json:"undiscounted_unit_price_net_amount,omitempty" toml:"undiscounted_unit_price_net_amount" yaml:"undiscounted_unit_price_net_amount,omitempty"`
	UndiscountedTotalPriceGrossAmount null.Float64 `boil:"undiscounted_total_price_gross_amount" json:"undiscounted_total_price_gross_amount,omitempty" toml:"undiscounted_total_price_gross_amount" yaml:"undiscounted_total_price_gross_amount,omitempty"`
	UndiscountedTotalPriceNetAmount   null.Float64 `boil:"undiscounted_total_price_net_amount" json:"undiscounted_total_price_net_amount,omitempty" toml:"undiscounted_total_price_net_amount" yaml:"undiscounted_total_price_net_amount,omitempty"`
	TaxRate                           null.Float64 `boil:"tax_rate" json:"tax_rate,omitempty" toml:"tax_rate" yaml:"tax_rate,omitempty"`

	R *orderLineR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L orderLineL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var OrderLineColumns = struct {
	ID                                string
	CreateAt                          string
	OrderID                           string
	VariantID                         string
	ProductName                       string
	VariantName                       string
	TranslatedProductName             string
	TranslatedVariantName             string
	ProductSku                        string
	ProductVariantID                  string
	IsShippingRequired                string
	IsGiftcard                        string
	Quantity                          string
	QuantityFulfilled                 string
	Currency                          string
	UnitDiscountAmount                string
	UnitDiscountType                  string
	UnitDiscountReason                string
	UnitPriceNetAmount                string
	UnitDiscountValue                 string
	UnitPriceGrossAmount              string
	TotalPriceNetAmount               string
	TotalPriceGrossAmount             string
	UndiscountedUnitPriceGrossAmount  string
	UndiscountedUnitPriceNetAmount    string
	UndiscountedTotalPriceGrossAmount string
	UndiscountedTotalPriceNetAmount   string
	TaxRate                           string
}{
	ID:                                "id",
	CreateAt:                          "create_at",
	OrderID:                           "order_id",
	VariantID:                         "variant_id",
	ProductName:                       "product_name",
	VariantName:                       "variant_name",
	TranslatedProductName:             "translated_product_name",
	TranslatedVariantName:             "translated_variant_name",
	ProductSku:                        "product_sku",
	ProductVariantID:                  "product_variant_id",
	IsShippingRequired:                "is_shipping_required",
	IsGiftcard:                        "is_giftcard",
	Quantity:                          "quantity",
	QuantityFulfilled:                 "quantity_fulfilled",
	Currency:                          "currency",
	UnitDiscountAmount:                "unit_discount_amount",
	UnitDiscountType:                  "unit_discount_type",
	UnitDiscountReason:                "unit_discount_reason",
	UnitPriceNetAmount:                "unit_price_net_amount",
	UnitDiscountValue:                 "unit_discount_value",
	UnitPriceGrossAmount:              "unit_price_gross_amount",
	TotalPriceNetAmount:               "total_price_net_amount",
	TotalPriceGrossAmount:             "total_price_gross_amount",
	UndiscountedUnitPriceGrossAmount:  "undiscounted_unit_price_gross_amount",
	UndiscountedUnitPriceNetAmount:    "undiscounted_unit_price_net_amount",
	UndiscountedTotalPriceGrossAmount: "undiscounted_total_price_gross_amount",
	UndiscountedTotalPriceNetAmount:   "undiscounted_total_price_net_amount",
	TaxRate:                           "tax_rate",
}

var OrderLineTableColumns = struct {
	ID                                string
	CreateAt                          string
	OrderID                           string
	VariantID                         string
	ProductName                       string
	VariantName                       string
	TranslatedProductName             string
	TranslatedVariantName             string
	ProductSku                        string
	ProductVariantID                  string
	IsShippingRequired                string
	IsGiftcard                        string
	Quantity                          string
	QuantityFulfilled                 string
	Currency                          string
	UnitDiscountAmount                string
	UnitDiscountType                  string
	UnitDiscountReason                string
	UnitPriceNetAmount                string
	UnitDiscountValue                 string
	UnitPriceGrossAmount              string
	TotalPriceNetAmount               string
	TotalPriceGrossAmount             string
	UndiscountedUnitPriceGrossAmount  string
	UndiscountedUnitPriceNetAmount    string
	UndiscountedTotalPriceGrossAmount string
	UndiscountedTotalPriceNetAmount   string
	TaxRate                           string
}{
	ID:                                "order_lines.id",
	CreateAt:                          "order_lines.create_at",
	OrderID:                           "order_lines.order_id",
	VariantID:                         "order_lines.variant_id",
	ProductName:                       "order_lines.product_name",
	VariantName:                       "order_lines.variant_name",
	TranslatedProductName:             "order_lines.translated_product_name",
	TranslatedVariantName:             "order_lines.translated_variant_name",
	ProductSku:                        "order_lines.product_sku",
	ProductVariantID:                  "order_lines.product_variant_id",
	IsShippingRequired:                "order_lines.is_shipping_required",
	IsGiftcard:                        "order_lines.is_giftcard",
	Quantity:                          "order_lines.quantity",
	QuantityFulfilled:                 "order_lines.quantity_fulfilled",
	Currency:                          "order_lines.currency",
	UnitDiscountAmount:                "order_lines.unit_discount_amount",
	UnitDiscountType:                  "order_lines.unit_discount_type",
	UnitDiscountReason:                "order_lines.unit_discount_reason",
	UnitPriceNetAmount:                "order_lines.unit_price_net_amount",
	UnitDiscountValue:                 "order_lines.unit_discount_value",
	UnitPriceGrossAmount:              "order_lines.unit_price_gross_amount",
	TotalPriceNetAmount:               "order_lines.total_price_net_amount",
	TotalPriceGrossAmount:             "order_lines.total_price_gross_amount",
	UndiscountedUnitPriceGrossAmount:  "order_lines.undiscounted_unit_price_gross_amount",
	UndiscountedUnitPriceNetAmount:    "order_lines.undiscounted_unit_price_net_amount",
	UndiscountedTotalPriceGrossAmount: "order_lines.undiscounted_total_price_gross_amount",
	UndiscountedTotalPriceNetAmount:   "order_lines.undiscounted_total_price_net_amount",
	TaxRate:                           "order_lines.tax_rate",
}

// Generated where

var OrderLineWhere = struct {
	ID                                whereHelperstring
	CreateAt                          whereHelpernull_Int64
	OrderID                           whereHelpernull_String
	VariantID                         whereHelpernull_String
	ProductName                       whereHelpernull_String
	VariantName                       whereHelpernull_String
	TranslatedProductName             whereHelpernull_String
	TranslatedVariantName             whereHelpernull_String
	ProductSku                        whereHelpernull_String
	ProductVariantID                  whereHelpernull_String
	IsShippingRequired                whereHelpernull_Bool
	IsGiftcard                        whereHelpernull_Bool
	Quantity                          whereHelpernull_Int
	QuantityFulfilled                 whereHelpernull_Int
	Currency                          whereHelpernull_String
	UnitDiscountAmount                whereHelpernull_Float64
	UnitDiscountType                  whereHelpernull_String
	UnitDiscountReason                whereHelpernull_String
	UnitPriceNetAmount                whereHelpernull_Float64
	UnitDiscountValue                 whereHelpernull_Float64
	UnitPriceGrossAmount              whereHelpernull_Float64
	TotalPriceNetAmount               whereHelpernull_Float64
	TotalPriceGrossAmount             whereHelpernull_Float64
	UndiscountedUnitPriceGrossAmount  whereHelpernull_Float64
	UndiscountedUnitPriceNetAmount    whereHelpernull_Float64
	UndiscountedTotalPriceGrossAmount whereHelpernull_Float64
	UndiscountedTotalPriceNetAmount   whereHelpernull_Float64
	TaxRate                           whereHelpernull_Float64
}{
	ID:                                whereHelperstring{field: "\"order_lines\".\"id\""},
	CreateAt:                          whereHelpernull_Int64{field: "\"order_lines\".\"create_at\""},
	OrderID:                           whereHelpernull_String{field: "\"order_lines\".\"order_id\""},
	VariantID:                         whereHelpernull_String{field: "\"order_lines\".\"variant_id\""},
	ProductName:                       whereHelpernull_String{field: "\"order_lines\".\"product_name\""},
	VariantName:                       whereHelpernull_String{field: "\"order_lines\".\"variant_name\""},
	TranslatedProductName:             whereHelpernull_String{field: "\"order_lines\".\"translated_product_name\""},
	TranslatedVariantName:             whereHelpernull_String{field: "\"order_lines\".\"translated_variant_name\""},
	ProductSku:                        whereHelpernull_String{field: "\"order_lines\".\"product_sku\""},
	ProductVariantID:                  whereHelpernull_String{field: "\"order_lines\".\"product_variant_id\""},
	IsShippingRequired:                whereHelpernull_Bool{field: "\"order_lines\".\"is_shipping_required\""},
	IsGiftcard:                        whereHelpernull_Bool{field: "\"order_lines\".\"is_giftcard\""},
	Quantity:                          whereHelpernull_Int{field: "\"order_lines\".\"quantity\""},
	QuantityFulfilled:                 whereHelpernull_Int{field: "\"order_lines\".\"quantity_fulfilled\""},
	Currency:                          whereHelpernull_String{field: "\"order_lines\".\"currency\""},
	UnitDiscountAmount:                whereHelpernull_Float64{field: "\"order_lines\".\"unit_discount_amount\""},
	UnitDiscountType:                  whereHelpernull_String{field: "\"order_lines\".\"unit_discount_type\""},
	UnitDiscountReason:                whereHelpernull_String{field: "\"order_lines\".\"unit_discount_reason\""},
	UnitPriceNetAmount:                whereHelpernull_Float64{field: "\"order_lines\".\"unit_price_net_amount\""},
	UnitDiscountValue:                 whereHelpernull_Float64{field: "\"order_lines\".\"unit_discount_value\""},
	UnitPriceGrossAmount:              whereHelpernull_Float64{field: "\"order_lines\".\"unit_price_gross_amount\""},
	TotalPriceNetAmount:               whereHelpernull_Float64{field: "\"order_lines\".\"total_price_net_amount\""},
	TotalPriceGrossAmount:             whereHelpernull_Float64{field: "\"order_lines\".\"total_price_gross_amount\""},
	UndiscountedUnitPriceGrossAmount:  whereHelpernull_Float64{field: "\"order_lines\".\"undiscounted_unit_price_gross_amount\""},
	UndiscountedUnitPriceNetAmount:    whereHelpernull_Float64{field: "\"order_lines\".\"undiscounted_unit_price_net_amount\""},
	UndiscountedTotalPriceGrossAmount: whereHelpernull_Float64{field: "\"order_lines\".\"undiscounted_total_price_gross_amount\""},
	UndiscountedTotalPriceNetAmount:   whereHelpernull_Float64{field: "\"order_lines\".\"undiscounted_total_price_net_amount\""},
	TaxRate:                           whereHelpernull_Float64{field: "\"order_lines\".\"tax_rate\""},
}

// OrderLineRels is where relationship names are stored.
var OrderLineRels = struct {
	Order                 string
	Variant               string
	LineDigitalContentURL string
	Allocations           string
	FulfillmentLines      string
}{
	Order:                 "Order",
	Variant:               "Variant",
	LineDigitalContentURL: "LineDigitalContentURL",
	Allocations:           "Allocations",
	FulfillmentLines:      "FulfillmentLines",
}

// orderLineR is where relationships are stored.
type orderLineR struct {
	Order                 *Order               `boil:"Order" json:"Order" toml:"Order" yaml:"Order"`
	Variant               *ProductVariant      `boil:"Variant" json:"Variant" toml:"Variant" yaml:"Variant"`
	LineDigitalContentURL *DigitalContentURL   `boil:"LineDigitalContentURL" json:"LineDigitalContentURL" toml:"LineDigitalContentURL" yaml:"LineDigitalContentURL"`
	Allocations           AllocationSlice      `boil:"Allocations" json:"Allocations" toml:"Allocations" yaml:"Allocations"`
	FulfillmentLines      FulfillmentLineSlice `boil:"FulfillmentLines" json:"FulfillmentLines" toml:"FulfillmentLines" yaml:"FulfillmentLines"`
}

// NewStruct creates a new relationship struct
func (*orderLineR) NewStruct() *orderLineR {
	return &orderLineR{}
}

func (r *orderLineR) GetOrder() *Order {
	if r == nil {
		return nil
	}
	return r.Order
}

func (r *orderLineR) GetVariant() *ProductVariant {
	if r == nil {
		return nil
	}
	return r.Variant
}

func (r *orderLineR) GetLineDigitalContentURL() *DigitalContentURL {
	if r == nil {
		return nil
	}
	return r.LineDigitalContentURL
}

func (r *orderLineR) GetAllocations() AllocationSlice {
	if r == nil {
		return nil
	}
	return r.Allocations
}

func (r *orderLineR) GetFulfillmentLines() FulfillmentLineSlice {
	if r == nil {
		return nil
	}
	return r.FulfillmentLines
}

// orderLineL is where Load methods for each relationship are stored.
type orderLineL struct{}

var (
	orderLineAllColumns            = []string{"id", "create_at", "order_id", "variant_id", "product_name", "variant_name", "translated_product_name", "translated_variant_name", "product_sku", "product_variant_id", "is_shipping_required", "is_giftcard", "quantity", "quantity_fulfilled", "currency", "unit_discount_amount", "unit_discount_type", "unit_discount_reason", "unit_price_net_amount", "unit_discount_value", "unit_price_gross_amount", "total_price_net_amount", "total_price_gross_amount", "undiscounted_unit_price_gross_amount", "undiscounted_unit_price_net_amount", "undiscounted_total_price_gross_amount", "undiscounted_total_price_net_amount", "tax_rate"}
	orderLineColumnsWithoutDefault = []string{"id"}
	orderLineColumnsWithDefault    = []string{"create_at", "order_id", "variant_id", "product_name", "variant_name", "translated_product_name", "translated_variant_name", "product_sku", "product_variant_id", "is_shipping_required", "is_giftcard", "quantity", "quantity_fulfilled", "currency", "unit_discount_amount", "unit_discount_type", "unit_discount_reason", "unit_price_net_amount", "unit_discount_value", "unit_price_gross_amount", "total_price_net_amount", "total_price_gross_amount", "undiscounted_unit_price_gross_amount", "undiscounted_unit_price_net_amount", "undiscounted_total_price_gross_amount", "undiscounted_total_price_net_amount", "tax_rate"}
	orderLinePrimaryKeyColumns     = []string{"id"}
	orderLineGeneratedColumns      = []string{}
)

type (
	// OrderLineSlice is an alias for a slice of pointers to OrderLine.
	// This should almost always be used instead of []OrderLine.
	OrderLineSlice []*OrderLine
	// OrderLineHook is the signature for custom OrderLine hook methods
	OrderLineHook func(context.Context, boil.ContextExecutor, *OrderLine) error

	orderLineQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	orderLineType                 = reflect.TypeOf(&OrderLine{})
	orderLineMapping              = queries.MakeStructMapping(orderLineType)
	orderLinePrimaryKeyMapping, _ = queries.BindMapping(orderLineType, orderLineMapping, orderLinePrimaryKeyColumns)
	orderLineInsertCacheMut       sync.RWMutex
	orderLineInsertCache          = make(map[string]insertCache)
	orderLineUpdateCacheMut       sync.RWMutex
	orderLineUpdateCache          = make(map[string]updateCache)
	orderLineUpsertCacheMut       sync.RWMutex
	orderLineUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var orderLineAfterSelectHooks []OrderLineHook

var orderLineBeforeInsertHooks []OrderLineHook
var orderLineAfterInsertHooks []OrderLineHook

var orderLineBeforeUpdateHooks []OrderLineHook
var orderLineAfterUpdateHooks []OrderLineHook

var orderLineBeforeDeleteHooks []OrderLineHook
var orderLineAfterDeleteHooks []OrderLineHook

var orderLineBeforeUpsertHooks []OrderLineHook
var orderLineAfterUpsertHooks []OrderLineHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *OrderLine) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *OrderLine) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *OrderLine) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *OrderLine) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *OrderLine) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *OrderLine) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *OrderLine) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *OrderLine) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *OrderLine) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range orderLineAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddOrderLineHook registers your hook function for all future operations.
func AddOrderLineHook(hookPoint boil.HookPoint, orderLineHook OrderLineHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		orderLineAfterSelectHooks = append(orderLineAfterSelectHooks, orderLineHook)
	case boil.BeforeInsertHook:
		orderLineBeforeInsertHooks = append(orderLineBeforeInsertHooks, orderLineHook)
	case boil.AfterInsertHook:
		orderLineAfterInsertHooks = append(orderLineAfterInsertHooks, orderLineHook)
	case boil.BeforeUpdateHook:
		orderLineBeforeUpdateHooks = append(orderLineBeforeUpdateHooks, orderLineHook)
	case boil.AfterUpdateHook:
		orderLineAfterUpdateHooks = append(orderLineAfterUpdateHooks, orderLineHook)
	case boil.BeforeDeleteHook:
		orderLineBeforeDeleteHooks = append(orderLineBeforeDeleteHooks, orderLineHook)
	case boil.AfterDeleteHook:
		orderLineAfterDeleteHooks = append(orderLineAfterDeleteHooks, orderLineHook)
	case boil.BeforeUpsertHook:
		orderLineBeforeUpsertHooks = append(orderLineBeforeUpsertHooks, orderLineHook)
	case boil.AfterUpsertHook:
		orderLineAfterUpsertHooks = append(orderLineAfterUpsertHooks, orderLineHook)
	}
}

// One returns a single orderLine record from the query.
func (q orderLineQuery) One(ctx context.Context, exec boil.ContextExecutor) (*OrderLine, error) {
	o := &OrderLine{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for order_lines")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all OrderLine records from the query.
func (q orderLineQuery) All(ctx context.Context, exec boil.ContextExecutor) (OrderLineSlice, error) {
	var o []*OrderLine

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to OrderLine slice")
	}

	if len(orderLineAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all OrderLine records in the query.
func (q orderLineQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count order_lines rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q orderLineQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if order_lines exists")
	}

	return count > 0, nil
}

// Order pointed to by the foreign key.
func (o *OrderLine) Order(mods ...qm.QueryMod) orderQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OrderID),
	}

	queryMods = append(queryMods, mods...)

	return Orders(queryMods...)
}

// Variant pointed to by the foreign key.
func (o *OrderLine) Variant(mods ...qm.QueryMod) productVariantQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.VariantID),
	}

	queryMods = append(queryMods, mods...)

	return ProductVariants(queryMods...)
}

// LineDigitalContentURL pointed to by the foreign key.
func (o *OrderLine) LineDigitalContentURL(mods ...qm.QueryMod) digitalContentURLQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"line_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return DigitalContentUrls(queryMods...)
}

// Allocations retrieves all the allocation's Allocations with an executor.
func (o *OrderLine) Allocations(mods ...qm.QueryMod) allocationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"allocations\".\"order_line_id\"=?", o.ID),
	)

	return Allocations(queryMods...)
}

// FulfillmentLines retrieves all the fulfillment_line's FulfillmentLines with an executor.
func (o *OrderLine) FulfillmentLines(mods ...qm.QueryMod) fulfillmentLineQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"fulfillment_lines\".\"order_line_id\"=?", o.ID),
	)

	return FulfillmentLines(queryMods...)
}

// LoadOrder allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orderLineL) LoadOrder(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		if !queries.IsNil(object.OrderID) {
			args = append(args, object.OrderID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OrderID) {
				args = append(args, obj.OrderID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`orders`),
		qm.WhereIn(`orders.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Order")
	}

	var resultSlice []*Order
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Order")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for orders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orders")
	}

	if len(orderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Order = foreign
		if foreign.R == nil {
			foreign.R = &orderR{}
		}
		foreign.R.OrderLines = append(foreign.R.OrderLines, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OrderID, foreign.ID) {
				local.R.Order = foreign
				if foreign.R == nil {
					foreign.R = &orderR{}
				}
				foreign.R.OrderLines = append(foreign.R.OrderLines, local)
				break
			}
		}
	}

	return nil
}

// LoadVariant allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (orderLineL) LoadVariant(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		if !queries.IsNil(object.VariantID) {
			args = append(args, object.VariantID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.VariantID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.VariantID) {
				args = append(args, obj.VariantID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`product_variants`),
		qm.WhereIn(`product_variants.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ProductVariant")
	}

	var resultSlice []*ProductVariant
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ProductVariant")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for product_variants")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_variants")
	}

	if len(productVariantAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Variant = foreign
		if foreign.R == nil {
			foreign.R = &productVariantR{}
		}
		foreign.R.VariantOrderLines = append(foreign.R.VariantOrderLines, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.VariantID, foreign.ID) {
				local.R.Variant = foreign
				if foreign.R == nil {
					foreign.R = &productVariantR{}
				}
				foreign.R.VariantOrderLines = append(foreign.R.VariantOrderLines, local)
				break
			}
		}
	}

	return nil
}

// LoadLineDigitalContentURL allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (orderLineL) LoadLineDigitalContentURL(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`digital_content_urls`),
		qm.WhereIn(`digital_content_urls.line_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DigitalContentURL")
	}

	var resultSlice []*DigitalContentURL
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DigitalContentURL")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for digital_content_urls")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for digital_content_urls")
	}

	if len(digitalContentURLAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.LineDigitalContentURL = foreign
		if foreign.R == nil {
			foreign.R = &digitalContentURLR{}
		}
		foreign.R.Line = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.LineID) {
				local.R.LineDigitalContentURL = foreign
				if foreign.R == nil {
					foreign.R = &digitalContentURLR{}
				}
				foreign.R.Line = local
				break
			}
		}
	}

	return nil
}

// LoadAllocations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orderLineL) LoadAllocations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`allocations`),
		qm.WhereIn(`allocations.order_line_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load allocations")
	}

	var resultSlice []*Allocation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice allocations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on allocations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for allocations")
	}

	if len(allocationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Allocations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &allocationR{}
			}
			foreign.R.OrderLine = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OrderLineID {
				local.R.Allocations = append(local.R.Allocations, foreign)
				if foreign.R == nil {
					foreign.R = &allocationR{}
				}
				foreign.R.OrderLine = local
				break
			}
		}
	}

	return nil
}

// LoadFulfillmentLines allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (orderLineL) LoadFulfillmentLines(ctx context.Context, e boil.ContextExecutor, singular bool, maybeOrderLine interface{}, mods queries.Applicator) error {
	var slice []*OrderLine
	var object *OrderLine

	if singular {
		var ok bool
		object, ok = maybeOrderLine.(*OrderLine)
		if !ok {
			object = new(OrderLine)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeOrderLine))
			}
		}
	} else {
		s, ok := maybeOrderLine.(*[]*OrderLine)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeOrderLine)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeOrderLine))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &orderLineR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &orderLineR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`fulfillment_lines`),
		qm.WhereIn(`fulfillment_lines.order_line_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load fulfillment_lines")
	}

	var resultSlice []*FulfillmentLine
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice fulfillment_lines")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on fulfillment_lines")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for fulfillment_lines")
	}

	if len(fulfillmentLineAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FulfillmentLines = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fulfillmentLineR{}
			}
			foreign.R.OrderLine = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.OrderLineID) {
				local.R.FulfillmentLines = append(local.R.FulfillmentLines, foreign)
				if foreign.R == nil {
					foreign.R = &fulfillmentLineR{}
				}
				foreign.R.OrderLine = local
				break
			}
		}
	}

	return nil
}

// SetOrder of the orderLine to the related item.
// Sets o.R.Order to related.
// Adds o to related.R.OrderLines.
func (o *OrderLine) SetOrder(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Order) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"order_lines\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"order_id"}),
		strmangle.WhereClause("\"", "\"", 2, orderLinePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OrderID, related.ID)
	if o.R == nil {
		o.R = &orderLineR{
			Order: related,
		}
	} else {
		o.R.Order = related
	}

	if related.R == nil {
		related.R = &orderR{
			OrderLines: OrderLineSlice{o},
		}
	} else {
		related.R.OrderLines = append(related.R.OrderLines, o)
	}

	return nil
}

// RemoveOrder relationship.
// Sets o.R.Order to nil.
// Removes o from all passed in related items' relationships struct.
func (o *OrderLine) RemoveOrder(ctx context.Context, exec boil.ContextExecutor, related *Order) error {
	var err error

	queries.SetScanner(&o.OrderID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("order_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Order = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.OrderLines {
		if queries.Equal(o.OrderID, ri.OrderID) {
			continue
		}

		ln := len(related.R.OrderLines)
		if ln > 1 && i < ln-1 {
			related.R.OrderLines[i] = related.R.OrderLines[ln-1]
		}
		related.R.OrderLines = related.R.OrderLines[:ln-1]
		break
	}
	return nil
}

// SetVariant of the orderLine to the related item.
// Sets o.R.Variant to related.
// Adds o to related.R.VariantOrderLines.
func (o *OrderLine) SetVariant(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ProductVariant) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"order_lines\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"variant_id"}),
		strmangle.WhereClause("\"", "\"", 2, orderLinePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.VariantID, related.ID)
	if o.R == nil {
		o.R = &orderLineR{
			Variant: related,
		}
	} else {
		o.R.Variant = related
	}

	if related.R == nil {
		related.R = &productVariantR{
			VariantOrderLines: OrderLineSlice{o},
		}
	} else {
		related.R.VariantOrderLines = append(related.R.VariantOrderLines, o)
	}

	return nil
}

// RemoveVariant relationship.
// Sets o.R.Variant to nil.
// Removes o from all passed in related items' relationships struct.
func (o *OrderLine) RemoveVariant(ctx context.Context, exec boil.ContextExecutor, related *ProductVariant) error {
	var err error

	queries.SetScanner(&o.VariantID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("variant_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Variant = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.VariantOrderLines {
		if queries.Equal(o.VariantID, ri.VariantID) {
			continue
		}

		ln := len(related.R.VariantOrderLines)
		if ln > 1 && i < ln-1 {
			related.R.VariantOrderLines[i] = related.R.VariantOrderLines[ln-1]
		}
		related.R.VariantOrderLines = related.R.VariantOrderLines[:ln-1]
		break
	}
	return nil
}

// SetLineDigitalContentURL of the orderLine to the related item.
// Sets o.R.LineDigitalContentURL to related.
// Adds o to related.R.Line.
func (o *OrderLine) SetLineDigitalContentURL(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DigitalContentURL) error {
	var err error

	if insert {
		queries.Assign(&related.LineID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"digital_content_urls\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"line_id"}),
			strmangle.WhereClause("\"", "\"", 2, digitalContentURLPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.LineID, o.ID)
	}

	if o.R == nil {
		o.R = &orderLineR{
			LineDigitalContentURL: related,
		}
	} else {
		o.R.LineDigitalContentURL = related
	}

	if related.R == nil {
		related.R = &digitalContentURLR{
			Line: o,
		}
	} else {
		related.R.Line = o
	}
	return nil
}

// RemoveLineDigitalContentURL relationship.
// Sets o.R.LineDigitalContentURL to nil.
// Removes o from all passed in related items' relationships struct.
func (o *OrderLine) RemoveLineDigitalContentURL(ctx context.Context, exec boil.ContextExecutor, related *DigitalContentURL) error {
	var err error

	queries.SetScanner(&related.LineID, nil)
	if _, err = related.Update(ctx, exec, boil.Whitelist("line_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.LineDigitalContentURL = nil
	}

	if related == nil || related.R == nil {
		return nil
	}

	related.R.Line = nil

	return nil
}

// AddAllocations adds the given related objects to the existing relationships
// of the order_line, optionally inserting them as new records.
// Appends related to o.R.Allocations.
// Sets related.R.OrderLine appropriately.
func (o *OrderLine) AddAllocations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Allocation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderLineID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"allocations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"order_line_id"}),
				strmangle.WhereClause("\"", "\"", 2, allocationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderLineID = o.ID
		}
	}

	if o.R == nil {
		o.R = &orderLineR{
			Allocations: related,
		}
	} else {
		o.R.Allocations = append(o.R.Allocations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &allocationR{
				OrderLine: o,
			}
		} else {
			rel.R.OrderLine = o
		}
	}
	return nil
}

// AddFulfillmentLines adds the given related objects to the existing relationships
// of the order_line, optionally inserting them as new records.
// Appends related to o.R.FulfillmentLines.
// Sets related.R.OrderLine appropriately.
func (o *OrderLine) AddFulfillmentLines(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FulfillmentLine) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderLineID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"fulfillment_lines\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"order_line_id"}),
				strmangle.WhereClause("\"", "\"", 2, fulfillmentLinePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderLineID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &orderLineR{
			FulfillmentLines: related,
		}
	} else {
		o.R.FulfillmentLines = append(o.R.FulfillmentLines, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fulfillmentLineR{
				OrderLine: o,
			}
		} else {
			rel.R.OrderLine = o
		}
	}
	return nil
}

// SetFulfillmentLines removes all previously related items of the
// order_line replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderLine's FulfillmentLines accordingly.
// Replaces o.R.FulfillmentLines with related.
// Sets related.R.OrderLine's FulfillmentLines accordingly.
func (o *OrderLine) SetFulfillmentLines(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*FulfillmentLine) error {
	query := "update \"fulfillment_lines\" set \"order_line_id\" = null where \"order_line_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FulfillmentLines {
			queries.SetScanner(&rel.OrderLineID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.OrderLine = nil
		}
		o.R.FulfillmentLines = nil
	}

	return o.AddFulfillmentLines(ctx, exec, insert, related...)
}

// RemoveFulfillmentLines relationships from objects passed in.
// Removes related items from R.FulfillmentLines (uses pointer comparison, removal does not keep order)
// Sets related.R.OrderLine.
func (o *OrderLine) RemoveFulfillmentLines(ctx context.Context, exec boil.ContextExecutor, related ...*FulfillmentLine) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderLineID, nil)
		if rel.R != nil {
			rel.R.OrderLine = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("order_line_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FulfillmentLines {
			if rel != ri {
				continue
			}

			ln := len(o.R.FulfillmentLines)
			if ln > 1 && i < ln-1 {
				o.R.FulfillmentLines[i] = o.R.FulfillmentLines[ln-1]
			}
			o.R.FulfillmentLines = o.R.FulfillmentLines[:ln-1]
			break
		}
	}

	return nil
}

// OrderLines retrieves all the records using an executor.
func OrderLines(mods ...qm.QueryMod) orderLineQuery {
	mods = append(mods, qm.From("\"order_lines\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"order_lines\".*"})
	}

	return orderLineQuery{q}
}

// FindOrderLine retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindOrderLine(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*OrderLine, error) {
	orderLineObj := &OrderLine{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"order_lines\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, orderLineObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from order_lines")
	}

	if err = orderLineObj.doAfterSelectHooks(ctx, exec); err != nil {
		return orderLineObj, err
	}

	return orderLineObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *OrderLine) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no order_lines provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(orderLineColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	orderLineInsertCacheMut.RLock()
	cache, cached := orderLineInsertCache[key]
	orderLineInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			orderLineAllColumns,
			orderLineColumnsWithDefault,
			orderLineColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(orderLineType, orderLineMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"order_lines\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"order_lines\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into order_lines")
	}

	if !cached {
		orderLineInsertCacheMut.Lock()
		orderLineInsertCache[key] = cache
		orderLineInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the OrderLine.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *OrderLine) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	orderLineUpdateCacheMut.RLock()
	cache, cached := orderLineUpdateCache[key]
	orderLineUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			orderLineAllColumns,
			orderLinePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update order_lines, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"order_lines\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, orderLinePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, append(wl, orderLinePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update order_lines row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for order_lines")
	}

	if !cached {
		orderLineUpdateCacheMut.Lock()
		orderLineUpdateCache[key] = cache
		orderLineUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q orderLineQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for order_lines")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o OrderLineSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"order_lines\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, orderLinePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in orderLine slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all orderLine")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *OrderLine) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no order_lines provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(orderLineColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	orderLineUpsertCacheMut.RLock()
	cache, cached := orderLineUpsertCache[key]
	orderLineUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			orderLineAllColumns,
			orderLineColumnsWithDefault,
			orderLineColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			orderLineAllColumns,
			orderLinePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert order_lines, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(orderLinePrimaryKeyColumns))
			copy(conflict, orderLinePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"order_lines\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(orderLineType, orderLineMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(orderLineType, orderLineMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert order_lines")
	}

	if !cached {
		orderLineUpsertCacheMut.Lock()
		orderLineUpsertCache[key] = cache
		orderLineUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single OrderLine record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *OrderLine) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no OrderLine provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), orderLinePrimaryKeyMapping)
	sql := "DELETE FROM \"order_lines\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for order_lines")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q orderLineQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no orderLineQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from order_lines")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for order_lines")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o OrderLineSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(orderLineBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"order_lines\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orderLinePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from orderLine slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for order_lines")
	}

	if len(orderLineAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *OrderLine) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindOrderLine(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *OrderLineSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := OrderLineSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), orderLinePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"order_lines\".* FROM \"order_lines\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, orderLinePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in OrderLineSlice")
	}

	*o = slice

	return nil
}

// OrderLineExists checks if the OrderLine row exists.
func OrderLineExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"order_lines\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if order_lines exists")
	}

	return exists, nil
}

// Exists checks if the OrderLine row exists.
func (o *OrderLine) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return OrderLineExists(ctx, exec, o.ID)
}
