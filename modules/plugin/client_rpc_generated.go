// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make pluginapi"
// DO NOT EDIT

package plugin

import (
	"fmt"
	"log"

	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/model/account"
	"github.com/sitename/sitename/model/file"
	"github.com/sitename/sitename/model/plugins"
	"github.com/sitename/sitename/modules/slog"
)

func init() {
	hookNameToId["OnDeactivate"] = OnDeactivateID
}

type Z_OnDeactivateArgs struct {
}

type Z_OnDeactivateReturns struct {
	A error
}

func (g *hooksRPCClient) OnDeactivate() error {
	_args := &Z_OnDeactivateArgs{}
	_returns := &Z_OnDeactivateReturns{}
	if g.implemented[OnDeactivateID] {
		if err := g.client.Call("Plugin.OnDeactivate", _args, _returns); err != nil {
			g.log.Error("RPC call OnDeactivate to plugin failed.", slog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) OnDeactivate(args *Z_OnDeactivateArgs, returns *Z_OnDeactivateReturns) error {
	if hook, ok := s.impl.(interface {
		OnDeactivate() error
	}); ok {
		returns.A = hook.OnDeactivate()
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("Hook OnDeactivate called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["OnConfigurationChange"] = OnConfigurationChangeID
}

type Z_OnConfigurationChangeArgs struct {
}

type Z_OnConfigurationChangeReturns struct {
	A error
}

func (g *hooksRPCClient) OnConfigurationChange() error {
	_args := &Z_OnConfigurationChangeArgs{}
	_returns := &Z_OnConfigurationChangeReturns{}
	if g.implemented[OnConfigurationChangeID] {
		if err := g.client.Call("Plugin.OnConfigurationChange", _args, _returns); err != nil {
			g.log.Error("RPC call OnConfigurationChange to plugin failed.", slog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) OnConfigurationChange(args *Z_OnConfigurationChangeArgs, returns *Z_OnConfigurationChangeReturns) error {
	if hook, ok := s.impl.(interface {
		OnConfigurationChange() error
	}); ok {
		returns.A = hook.OnConfigurationChange()
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("Hook OnConfigurationChange called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasBeenCreated"] = UserHasBeenCreatedID
}

type Z_UserHasBeenCreatedArgs struct {
	A *Context
	B *account.User
}

type Z_UserHasBeenCreatedReturns struct {
}

func (g *hooksRPCClient) UserHasBeenCreated(c *Context, user *account.User) {
	_args := &Z_UserHasBeenCreatedArgs{c, user}
	_returns := &Z_UserHasBeenCreatedReturns{}
	if g.implemented[UserHasBeenCreatedID] {
		if err := g.client.Call("Plugin.UserHasBeenCreated", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasBeenCreated to plugin failed.", slog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasBeenCreated(args *Z_UserHasBeenCreatedArgs, returns *Z_UserHasBeenCreatedReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasBeenCreated(c *Context, user *account.User)
	}); ok {
		hook.UserHasBeenCreated(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook UserHasBeenCreated called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserWillLogIn"] = UserWillLogInID
}

type Z_UserWillLogInArgs struct {
	A *Context
	B *account.User
}

type Z_UserWillLogInReturns struct {
	A string
}

func (g *hooksRPCClient) UserWillLogIn(c *Context, user *account.User) string {
	_args := &Z_UserWillLogInArgs{c, user}
	_returns := &Z_UserWillLogInReturns{}
	if g.implemented[UserWillLogInID] {
		if err := g.client.Call("Plugin.UserWillLogIn", _args, _returns); err != nil {
			g.log.Error("RPC call UserWillLogIn to plugin failed.", slog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) UserWillLogIn(args *Z_UserWillLogInArgs, returns *Z_UserWillLogInReturns) error {
	if hook, ok := s.impl.(interface {
		UserWillLogIn(c *Context, user *account.User) string
	}); ok {
		returns.A = hook.UserWillLogIn(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook UserWillLogIn called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasLoggedIn"] = UserHasLoggedInID
}

type Z_UserHasLoggedInArgs struct {
	A *Context
	B *account.User
}

type Z_UserHasLoggedInReturns struct {
}

func (g *hooksRPCClient) UserHasLoggedIn(c *Context, user *account.User) {
	_args := &Z_UserHasLoggedInArgs{c, user}
	_returns := &Z_UserHasLoggedInReturns{}
	if g.implemented[UserHasLoggedInID] {
		if err := g.client.Call("Plugin.UserHasLoggedIn", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasLoggedIn to plugin failed.", slog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasLoggedIn(args *Z_UserHasLoggedInArgs, returns *Z_UserHasLoggedInReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasLoggedIn(c *Context, user *account.User)
	}); ok {
		hook.UserHasLoggedIn(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook UserHasLoggedIn called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["OnPluginClusterEvent"] = OnPluginClusterEventID
}

type Z_OnPluginClusterEventArgs struct {
	A *Context
	B plugins.PluginClusterEvent
}

type Z_OnPluginClusterEventReturns struct {
}

func (g *hooksRPCClient) OnPluginClusterEvent(c *Context, ev plugins.PluginClusterEvent) {
	_args := &Z_OnPluginClusterEventArgs{c, ev}
	_returns := &Z_OnPluginClusterEventReturns{}
	if g.implemented[OnPluginClusterEventID] {
		if err := g.client.Call("Plugin.OnPluginClusterEvent", _args, _returns); err != nil {
			g.log.Error("RPC call OnPluginClusterEvent to plugin failed.", slog.Err(err))
		}
	}

}

func (s *hooksRPCServer) OnPluginClusterEvent(args *Z_OnPluginClusterEventArgs, returns *Z_OnPluginClusterEventReturns) error {
	if hook, ok := s.impl.(interface {
		OnPluginClusterEvent(c *Context, ev plugins.PluginClusterEvent)
	}); ok {
		hook.OnPluginClusterEvent(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("Hook OnPluginClusterEvent called but not implemented."))
	}
	return nil
}

type Z_GetSessionArgs struct {
	A string
}

type Z_GetSessionReturns struct {
	A *model.Session
	B *model.AppError
}

func (g *apiRPCClient) GetSession(sessionID string) (*model.Session, *model.AppError) {
	_args := &Z_GetSessionArgs{sessionID}
	_returns := &Z_GetSessionReturns{}
	if err := g.client.Call("Plugin.GetSession", _args, _returns); err != nil {
		log.Printf("RPC call to GetSession API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetSession(args *Z_GetSessionArgs, returns *Z_GetSessionReturns) error {
	if hook, ok := s.impl.(interface {
		GetSession(sessionID string) (*model.Session, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetSession(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetSession called but not implemented."))
	}
	return nil
}

type Z_GetConfigArgs struct {
}

type Z_GetConfigReturns struct {
	A *model.Config
}

func (g *apiRPCClient) GetConfig() *model.Config {
	_args := &Z_GetConfigArgs{}
	_returns := &Z_GetConfigReturns{}
	if err := g.client.Call("Plugin.GetConfig", _args, _returns); err != nil {
		log.Printf("RPC call to GetConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetConfig(args *Z_GetConfigArgs, returns *Z_GetConfigReturns) error {
	if hook, ok := s.impl.(interface {
		GetConfig() *model.Config
	}); ok {
		returns.A = hook.GetConfig()
	} else {
		return encodableError(fmt.Errorf("API GetConfig called but not implemented."))
	}
	return nil
}

type Z_GetUnsanitizedConfigArgs struct {
}

type Z_GetUnsanitizedConfigReturns struct {
	A *model.Config
}

func (g *apiRPCClient) GetUnsanitizedConfig() *model.Config {
	_args := &Z_GetUnsanitizedConfigArgs{}
	_returns := &Z_GetUnsanitizedConfigReturns{}
	if err := g.client.Call("Plugin.GetUnsanitizedConfig", _args, _returns); err != nil {
		log.Printf("RPC call to GetUnsanitizedConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetUnsanitizedConfig(args *Z_GetUnsanitizedConfigArgs, returns *Z_GetUnsanitizedConfigReturns) error {
	if hook, ok := s.impl.(interface {
		GetUnsanitizedConfig() *model.Config
	}); ok {
		returns.A = hook.GetUnsanitizedConfig()
	} else {
		return encodableError(fmt.Errorf("API GetUnsanitizedConfig called but not implemented."))
	}
	return nil
}

type Z_SaveConfigArgs struct {
	A *model.Config
}

type Z_SaveConfigReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SaveConfig(config *model.Config) *model.AppError {
	_args := &Z_SaveConfigArgs{config}
	_returns := &Z_SaveConfigReturns{}
	if err := g.client.Call("Plugin.SaveConfig", _args, _returns); err != nil {
		log.Printf("RPC call to SaveConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SaveConfig(args *Z_SaveConfigArgs, returns *Z_SaveConfigReturns) error {
	if hook, ok := s.impl.(interface {
		SaveConfig(config *model.Config) *model.AppError
	}); ok {
		returns.A = hook.SaveConfig(args.A)
	} else {
		return encodableError(fmt.Errorf("API SaveConfig called but not implemented."))
	}
	return nil
}

type Z_GetPluginConfigArgs struct {
}

type Z_GetPluginConfigReturns struct {
	A map[string]interface{}
}

func (g *apiRPCClient) GetPluginConfig() map[string]interface{} {
	_args := &Z_GetPluginConfigArgs{}
	_returns := &Z_GetPluginConfigReturns{}
	if err := g.client.Call("Plugin.GetPluginConfig", _args, _returns); err != nil {
		log.Printf("RPC call to GetPluginConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetPluginConfig(args *Z_GetPluginConfigArgs, returns *Z_GetPluginConfigReturns) error {
	if hook, ok := s.impl.(interface {
		GetPluginConfig() map[string]interface{}
	}); ok {
		returns.A = hook.GetPluginConfig()
	} else {
		return encodableError(fmt.Errorf("API GetPluginConfig called but not implemented."))
	}
	return nil
}

type Z_SavePluginConfigArgs struct {
	A map[string]interface{}
}

type Z_SavePluginConfigReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SavePluginConfig(config map[string]interface{}) *model.AppError {
	_args := &Z_SavePluginConfigArgs{config}
	_returns := &Z_SavePluginConfigReturns{}
	if err := g.client.Call("Plugin.SavePluginConfig", _args, _returns); err != nil {
		log.Printf("RPC call to SavePluginConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SavePluginConfig(args *Z_SavePluginConfigArgs, returns *Z_SavePluginConfigReturns) error {
	if hook, ok := s.impl.(interface {
		SavePluginConfig(config map[string]interface{}) *model.AppError
	}); ok {
		returns.A = hook.SavePluginConfig(args.A)
	} else {
		return encodableError(fmt.Errorf("API SavePluginConfig called but not implemented."))
	}
	return nil
}

type Z_GetBundlePathArgs struct {
}

type Z_GetBundlePathReturns struct {
	A string
	B error
}

func (g *apiRPCClient) GetBundlePath() (string, error) {
	_args := &Z_GetBundlePathArgs{}
	_returns := &Z_GetBundlePathReturns{}
	if err := g.client.Call("Plugin.GetBundlePath", _args, _returns); err != nil {
		log.Printf("RPC call to GetBundlePath API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetBundlePath(args *Z_GetBundlePathArgs, returns *Z_GetBundlePathReturns) error {
	if hook, ok := s.impl.(interface {
		GetBundlePath() (string, error)
	}); ok {
		returns.A, returns.B = hook.GetBundlePath()
		returns.B = encodableError(returns.B)
	} else {
		return encodableError(fmt.Errorf("API GetBundlePath called but not implemented."))
	}
	return nil
}

type Z_GetServerVersionArgs struct {
}

type Z_GetServerVersionReturns struct {
	A string
}

func (g *apiRPCClient) GetServerVersion() string {
	_args := &Z_GetServerVersionArgs{}
	_returns := &Z_GetServerVersionReturns{}
	if err := g.client.Call("Plugin.GetServerVersion", _args, _returns); err != nil {
		log.Printf("RPC call to GetServerVersion API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetServerVersion(args *Z_GetServerVersionArgs, returns *Z_GetServerVersionReturns) error {
	if hook, ok := s.impl.(interface {
		GetServerVersion() string
	}); ok {
		returns.A = hook.GetServerVersion()
	} else {
		return encodableError(fmt.Errorf("API GetServerVersion called but not implemented."))
	}
	return nil
}

type Z_GetSystemInstallDateArgs struct {
}

type Z_GetSystemInstallDateReturns struct {
	A int64
	B *model.AppError
}

func (g *apiRPCClient) GetSystemInstallDate() (int64, *model.AppError) {
	_args := &Z_GetSystemInstallDateArgs{}
	_returns := &Z_GetSystemInstallDateReturns{}
	if err := g.client.Call("Plugin.GetSystemInstallDate", _args, _returns); err != nil {
		log.Printf("RPC call to GetSystemInstallDate API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetSystemInstallDate(args *Z_GetSystemInstallDateArgs, returns *Z_GetSystemInstallDateReturns) error {
	if hook, ok := s.impl.(interface {
		GetSystemInstallDate() (int64, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetSystemInstallDate()
	} else {
		return encodableError(fmt.Errorf("API GetSystemInstallDate called but not implemented."))
	}
	return nil
}

type Z_CreateUserArgs struct {
	A *account.User
}

type Z_CreateUserReturns struct {
	A *account.User
	B *model.AppError
}

func (g *apiRPCClient) CreateUser(user *account.User) (*account.User, *model.AppError) {
	_args := &Z_CreateUserArgs{user}
	_returns := &Z_CreateUserReturns{}
	if err := g.client.Call("Plugin.CreateUser", _args, _returns); err != nil {
		log.Printf("RPC call to CreateUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateUser(args *Z_CreateUserArgs, returns *Z_CreateUserReturns) error {
	if hook, ok := s.impl.(interface {
		CreateUser(user *account.User) (*account.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateUser called but not implemented."))
	}
	return nil
}

type Z_DeleteUserArgs struct {
	A string
}

type Z_DeleteUserReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteUser(userID string) *model.AppError {
	_args := &Z_DeleteUserArgs{userID}
	_returns := &Z_DeleteUserReturns{}
	if err := g.client.Call("Plugin.DeleteUser", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteUser API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteUser(args *Z_DeleteUserArgs, returns *Z_DeleteUserReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteUser(userID string) *model.AppError
	}); ok {
		returns.A = hook.DeleteUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteUser called but not implemented."))
	}
	return nil
}

type Z_GetUsersArgs struct {
	A *account.UserGetOptions
}

type Z_GetUsersReturns struct {
	A []*account.User
	B *model.AppError
}

func (g *apiRPCClient) GetUsers(options *account.UserGetOptions) ([]*account.User, *model.AppError) {
	_args := &Z_GetUsersArgs{options}
	_returns := &Z_GetUsersReturns{}
	if err := g.client.Call("Plugin.GetUsers", _args, _returns); err != nil {
		log.Printf("RPC call to GetUsers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUsers(args *Z_GetUsersArgs, returns *Z_GetUsersReturns) error {
	if hook, ok := s.impl.(interface {
		GetUsers(options *account.UserGetOptions) ([]*account.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUsers(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUsers called but not implemented."))
	}
	return nil
}

type Z_GetUserArgs struct {
	A string
}

type Z_GetUserReturns struct {
	A *account.User
	B *model.AppError
}

func (g *apiRPCClient) GetUser(userID string) (*account.User, *model.AppError) {
	_args := &Z_GetUserArgs{userID}
	_returns := &Z_GetUserReturns{}
	if err := g.client.Call("Plugin.GetUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUser(args *Z_GetUserArgs, returns *Z_GetUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetUser(userID string) (*account.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUser called but not implemented."))
	}
	return nil
}

type Z_GetUserByEmailArgs struct {
	A string
}

type Z_GetUserByEmailReturns struct {
	A *account.User
	B *model.AppError
}

func (g *apiRPCClient) GetUserByEmail(email string) (*account.User, *model.AppError) {
	_args := &Z_GetUserByEmailArgs{email}
	_returns := &Z_GetUserByEmailReturns{}
	if err := g.client.Call("Plugin.GetUserByEmail", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserByEmail API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserByEmail(args *Z_GetUserByEmailArgs, returns *Z_GetUserByEmailReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserByEmail(email string) (*account.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserByEmail(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserByEmail called but not implemented."))
	}
	return nil
}

type Z_GetUserByUsernameArgs struct {
	A string
}

type Z_GetUserByUsernameReturns struct {
	A *account.User
	B *model.AppError
}

func (g *apiRPCClient) GetUserByUsername(name string) (*account.User, *model.AppError) {
	_args := &Z_GetUserByUsernameArgs{name}
	_returns := &Z_GetUserByUsernameReturns{}
	if err := g.client.Call("Plugin.GetUserByUsername", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserByUsername API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserByUsername(args *Z_GetUserByUsernameArgs, returns *Z_GetUserByUsernameReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserByUsername(name string) (*account.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserByUsername(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserByUsername called but not implemented."))
	}
	return nil
}

type Z_GetUsersByUsernamesArgs struct {
	A []string
}

type Z_GetUsersByUsernamesReturns struct {
	A []*account.User
	B *model.AppError
}

func (g *apiRPCClient) GetUsersByUsernames(usernames []string) ([]*account.User, *model.AppError) {
	_args := &Z_GetUsersByUsernamesArgs{usernames}
	_returns := &Z_GetUsersByUsernamesReturns{}
	if err := g.client.Call("Plugin.GetUsersByUsernames", _args, _returns); err != nil {
		log.Printf("RPC call to GetUsersByUsernames API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUsersByUsernames(args *Z_GetUsersByUsernamesArgs, returns *Z_GetUsersByUsernamesReturns) error {
	if hook, ok := s.impl.(interface {
		GetUsersByUsernames(usernames []string) ([]*account.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUsersByUsernames(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUsersByUsernames called but not implemented."))
	}
	return nil
}

type Z_GetPreferencesForUserArgs struct {
	A string
}

type Z_GetPreferencesForUserReturns struct {
	A []model.Preference
	B *model.AppError
}

func (g *apiRPCClient) GetPreferencesForUser(userID string) ([]model.Preference, *model.AppError) {
	_args := &Z_GetPreferencesForUserArgs{userID}
	_returns := &Z_GetPreferencesForUserReturns{}
	if err := g.client.Call("Plugin.GetPreferencesForUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetPreferencesForUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPreferencesForUser(args *Z_GetPreferencesForUserArgs, returns *Z_GetPreferencesForUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetPreferencesForUser(userID string) ([]model.Preference, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPreferencesForUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetPreferencesForUser called but not implemented."))
	}
	return nil
}

type Z_UpdatePreferencesForUserArgs struct {
	A string
	B []model.Preference
}

type Z_UpdatePreferencesForUserReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) UpdatePreferencesForUser(userID string, preferences []model.Preference) *model.AppError {
	_args := &Z_UpdatePreferencesForUserArgs{userID, preferences}
	_returns := &Z_UpdatePreferencesForUserReturns{}
	if err := g.client.Call("Plugin.UpdatePreferencesForUser", _args, _returns); err != nil {
		log.Printf("RPC call to UpdatePreferencesForUser API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) UpdatePreferencesForUser(args *Z_UpdatePreferencesForUserArgs, returns *Z_UpdatePreferencesForUserReturns) error {
	if hook, ok := s.impl.(interface {
		UpdatePreferencesForUser(userID string, preferences []model.Preference) *model.AppError
	}); ok {
		returns.A = hook.UpdatePreferencesForUser(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdatePreferencesForUser called but not implemented."))
	}
	return nil
}

type Z_DeletePreferencesForUserArgs struct {
	A string
	B []model.Preference
}

type Z_DeletePreferencesForUserReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeletePreferencesForUser(userID string, preferences []model.Preference) *model.AppError {
	_args := &Z_DeletePreferencesForUserArgs{userID, preferences}
	_returns := &Z_DeletePreferencesForUserReturns{}
	if err := g.client.Call("Plugin.DeletePreferencesForUser", _args, _returns); err != nil {
		log.Printf("RPC call to DeletePreferencesForUser API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeletePreferencesForUser(args *Z_DeletePreferencesForUserArgs, returns *Z_DeletePreferencesForUserReturns) error {
	if hook, ok := s.impl.(interface {
		DeletePreferencesForUser(userID string, preferences []model.Preference) *model.AppError
	}); ok {
		returns.A = hook.DeletePreferencesForUser(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API DeletePreferencesForUser called but not implemented."))
	}
	return nil
}

type Z_CreateUserAccessTokenArgs struct {
	A *account.UserAccessToken
}

type Z_CreateUserAccessTokenReturns struct {
	A *account.UserAccessToken
	B *model.AppError
}

func (g *apiRPCClient) CreateUserAccessToken(token *account.UserAccessToken) (*account.UserAccessToken, *model.AppError) {
	_args := &Z_CreateUserAccessTokenArgs{token}
	_returns := &Z_CreateUserAccessTokenReturns{}
	if err := g.client.Call("Plugin.CreateUserAccessToken", _args, _returns); err != nil {
		log.Printf("RPC call to CreateUserAccessToken API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateUserAccessToken(args *Z_CreateUserAccessTokenArgs, returns *Z_CreateUserAccessTokenReturns) error {
	if hook, ok := s.impl.(interface {
		CreateUserAccessToken(token *account.UserAccessToken) (*account.UserAccessToken, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateUserAccessToken(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateUserAccessToken called but not implemented."))
	}
	return nil
}

type Z_RevokeUserAccessTokenArgs struct {
	A string
}

type Z_RevokeUserAccessTokenReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) RevokeUserAccessToken(tokenID string) *model.AppError {
	_args := &Z_RevokeUserAccessTokenArgs{tokenID}
	_returns := &Z_RevokeUserAccessTokenReturns{}
	if err := g.client.Call("Plugin.RevokeUserAccessToken", _args, _returns); err != nil {
		log.Printf("RPC call to RevokeUserAccessToken API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) RevokeUserAccessToken(args *Z_RevokeUserAccessTokenArgs, returns *Z_RevokeUserAccessTokenReturns) error {
	if hook, ok := s.impl.(interface {
		RevokeUserAccessToken(tokenID string) *model.AppError
	}); ok {
		returns.A = hook.RevokeUserAccessToken(args.A)
	} else {
		return encodableError(fmt.Errorf("API RevokeUserAccessToken called but not implemented."))
	}
	return nil
}

type Z_UpdateUserArgs struct {
	A *account.User
}

type Z_UpdateUserReturns struct {
	A *account.User
	B *model.AppError
}

func (g *apiRPCClient) UpdateUser(user *account.User) (*account.User, *model.AppError) {
	_args := &Z_UpdateUserArgs{user}
	_returns := &Z_UpdateUserReturns{}
	if err := g.client.Call("Plugin.UpdateUser", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateUser(args *Z_UpdateUserArgs, returns *Z_UpdateUserReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUser(user *account.User) (*account.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdateUser called but not implemented."))
	}
	return nil
}

type Z_GetUserStatusArgs struct {
	A string
}

type Z_GetUserStatusReturns struct {
	A *account.Status
	B *model.AppError
}

func (g *apiRPCClient) GetUserStatus(userID string) (*account.Status, *model.AppError) {
	_args := &Z_GetUserStatusArgs{userID}
	_returns := &Z_GetUserStatusReturns{}
	if err := g.client.Call("Plugin.GetUserStatus", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserStatus API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserStatus(args *Z_GetUserStatusArgs, returns *Z_GetUserStatusReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserStatus(userID string) (*account.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserStatus(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserStatus called but not implemented."))
	}
	return nil
}

type Z_GetUserStatusesByIdsArgs struct {
	A []string
}

type Z_GetUserStatusesByIdsReturns struct {
	A []*account.Status
	B *model.AppError
}

func (g *apiRPCClient) GetUserStatusesByIds(userIds []string) ([]*account.Status, *model.AppError) {
	_args := &Z_GetUserStatusesByIdsArgs{userIds}
	_returns := &Z_GetUserStatusesByIdsReturns{}
	if err := g.client.Call("Plugin.GetUserStatusesByIds", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserStatusesByIds API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserStatusesByIds(args *Z_GetUserStatusesByIdsArgs, returns *Z_GetUserStatusesByIdsReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserStatusesByIds(userIds []string) ([]*account.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserStatusesByIds(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserStatusesByIds called but not implemented."))
	}
	return nil
}

type Z_UpdateUserStatusArgs struct {
	A string
	B string
}

type Z_UpdateUserStatusReturns struct {
	A *account.Status
	B *model.AppError
}

func (g *apiRPCClient) UpdateUserStatus(userID, status string) (*account.Status, *model.AppError) {
	_args := &Z_UpdateUserStatusArgs{userID, status}
	_returns := &Z_UpdateUserStatusReturns{}
	if err := g.client.Call("Plugin.UpdateUserStatus", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateUserStatus API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateUserStatus(args *Z_UpdateUserStatusArgs, returns *Z_UpdateUserStatusReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUserStatus(userID, status string) (*account.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateUserStatus(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdateUserStatus called but not implemented."))
	}
	return nil
}

type Z_UpdateUserActiveArgs struct {
	A string
	B bool
}

type Z_UpdateUserActiveReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) UpdateUserActive(userID string, active bool) *model.AppError {
	_args := &Z_UpdateUserActiveArgs{userID, active}
	_returns := &Z_UpdateUserActiveReturns{}
	if err := g.client.Call("Plugin.UpdateUserActive", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateUserActive API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) UpdateUserActive(args *Z_UpdateUserActiveArgs, returns *Z_UpdateUserActiveReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUserActive(userID string, active bool) *model.AppError
	}); ok {
		returns.A = hook.UpdateUserActive(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdateUserActive called but not implemented."))
	}
	return nil
}

type Z_GetLDAPUserAttributesArgs struct {
	A string
	B []string
}

type Z_GetLDAPUserAttributesReturns struct {
	A map[string]string
	B *model.AppError
}

func (g *apiRPCClient) GetLDAPUserAttributes(userID string, attributes []string) (map[string]string, *model.AppError) {
	_args := &Z_GetLDAPUserAttributesArgs{userID, attributes}
	_returns := &Z_GetLDAPUserAttributesReturns{}
	if err := g.client.Call("Plugin.GetLDAPUserAttributes", _args, _returns); err != nil {
		log.Printf("RPC call to GetLDAPUserAttributes API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetLDAPUserAttributes(args *Z_GetLDAPUserAttributesArgs, returns *Z_GetLDAPUserAttributesReturns) error {
	if hook, ok := s.impl.(interface {
		GetLDAPUserAttributes(userID string, attributes []string) (map[string]string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetLDAPUserAttributes(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetLDAPUserAttributes called but not implemented."))
	}
	return nil
}

type Z_SearchUsersArgs struct {
	A *account.UserSearch
}

type Z_SearchUsersReturns struct {
	A []*account.User
	B *model.AppError
}

func (g *apiRPCClient) SearchUsers(search *account.UserSearch) ([]*account.User, *model.AppError) {
	_args := &Z_SearchUsersArgs{search}
	_returns := &Z_SearchUsersReturns{}
	if err := g.client.Call("Plugin.SearchUsers", _args, _returns); err != nil {
		log.Printf("RPC call to SearchUsers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) SearchUsers(args *Z_SearchUsersArgs, returns *Z_SearchUsersReturns) error {
	if hook, ok := s.impl.(interface {
		SearchUsers(search *account.UserSearch) ([]*account.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.SearchUsers(args.A)
	} else {
		return encodableError(fmt.Errorf("API SearchUsers called but not implemented."))
	}
	return nil
}

type Z_GetProfileImageArgs struct {
	A string
}

type Z_GetProfileImageReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) GetProfileImage(userID string) ([]byte, *model.AppError) {
	_args := &Z_GetProfileImageArgs{userID}
	_returns := &Z_GetProfileImageReturns{}
	if err := g.client.Call("Plugin.GetProfileImage", _args, _returns); err != nil {
		log.Printf("RPC call to GetProfileImage API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetProfileImage(args *Z_GetProfileImageArgs, returns *Z_GetProfileImageReturns) error {
	if hook, ok := s.impl.(interface {
		GetProfileImage(userID string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetProfileImage(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetProfileImage called but not implemented."))
	}
	return nil
}

type Z_SetProfileImageArgs struct {
	A string
	B []byte
}

type Z_SetProfileImageReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SetProfileImage(userID string, data []byte) *model.AppError {
	_args := &Z_SetProfileImageArgs{userID, data}
	_returns := &Z_SetProfileImageReturns{}
	if err := g.client.Call("Plugin.SetProfileImage", _args, _returns); err != nil {
		log.Printf("RPC call to SetProfileImage API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SetProfileImage(args *Z_SetProfileImageArgs, returns *Z_SetProfileImageReturns) error {
	if hook, ok := s.impl.(interface {
		SetProfileImage(userID string, data []byte) *model.AppError
	}); ok {
		returns.A = hook.SetProfileImage(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API SetProfileImage called but not implemented."))
	}
	return nil
}

type Z_CopyFileInfosArgs struct {
	A string
	B []string
}

type Z_CopyFileInfosReturns struct {
	A []string
	B *model.AppError
}

func (g *apiRPCClient) CopyFileInfos(userID string, fileIds []string) ([]string, *model.AppError) {
	_args := &Z_CopyFileInfosArgs{userID, fileIds}
	_returns := &Z_CopyFileInfosReturns{}
	if err := g.client.Call("Plugin.CopyFileInfos", _args, _returns); err != nil {
		log.Printf("RPC call to CopyFileInfos API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CopyFileInfos(args *Z_CopyFileInfosArgs, returns *Z_CopyFileInfosReturns) error {
	if hook, ok := s.impl.(interface {
		CopyFileInfos(userID string, fileIds []string) ([]string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CopyFileInfos(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API CopyFileInfos called but not implemented."))
	}
	return nil
}

type Z_GetFileInfoArgs struct {
	A string
}

type Z_GetFileInfoReturns struct {
	A *file.FileInfo
	B *model.AppError
}

func (g *apiRPCClient) GetFileInfo(fileId string) (*file.FileInfo, *model.AppError) {
	_args := &Z_GetFileInfoArgs{fileId}
	_returns := &Z_GetFileInfoReturns{}
	if err := g.client.Call("Plugin.GetFileInfo", _args, _returns); err != nil {
		log.Printf("RPC call to GetFileInfo API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFileInfo(args *Z_GetFileInfoArgs, returns *Z_GetFileInfoReturns) error {
	if hook, ok := s.impl.(interface {
		GetFileInfo(fileId string) (*file.FileInfo, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFileInfo(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetFileInfo called but not implemented."))
	}
	return nil
}

type Z_GetFileInfosArgs struct {
	A int
	B int
	C *file.GetFileInfosOptions
}

type Z_GetFileInfosReturns struct {
	A []*file.FileInfo
	B *model.AppError
}

func (g *apiRPCClient) GetFileInfos(page, perPage int, opt *file.GetFileInfosOptions) ([]*file.FileInfo, *model.AppError) {
	_args := &Z_GetFileInfosArgs{page, perPage, opt}
	_returns := &Z_GetFileInfosReturns{}
	if err := g.client.Call("Plugin.GetFileInfos", _args, _returns); err != nil {
		log.Printf("RPC call to GetFileInfos API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFileInfos(args *Z_GetFileInfosArgs, returns *Z_GetFileInfosReturns) error {
	if hook, ok := s.impl.(interface {
		GetFileInfos(page, perPage int, opt *file.GetFileInfosOptions) ([]*file.FileInfo, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFileInfos(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetFileInfos called but not implemented."))
	}
	return nil
}

type Z_GetFileArgs struct {
	A string
}

type Z_GetFileReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) GetFile(fileId string) ([]byte, *model.AppError) {
	_args := &Z_GetFileArgs{fileId}
	_returns := &Z_GetFileReturns{}
	if err := g.client.Call("Plugin.GetFile", _args, _returns); err != nil {
		log.Printf("RPC call to GetFile API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFile(args *Z_GetFileArgs, returns *Z_GetFileReturns) error {
	if hook, ok := s.impl.(interface {
		GetFile(fileId string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFile(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetFile called but not implemented."))
	}
	return nil
}

type Z_GetFileLinkArgs struct {
	A string
}

type Z_GetFileLinkReturns struct {
	A string
	B *model.AppError
}

func (g *apiRPCClient) GetFileLink(fileId string) (string, *model.AppError) {
	_args := &Z_GetFileLinkArgs{fileId}
	_returns := &Z_GetFileLinkReturns{}
	if err := g.client.Call("Plugin.GetFileLink", _args, _returns); err != nil {
		log.Printf("RPC call to GetFileLink API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFileLink(args *Z_GetFileLinkArgs, returns *Z_GetFileLinkReturns) error {
	if hook, ok := s.impl.(interface {
		GetFileLink(fileId string) (string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFileLink(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetFileLink called but not implemented."))
	}
	return nil
}

type Z_ReadFileArgs struct {
	A string
}

type Z_ReadFileReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) ReadFile(path string) ([]byte, *model.AppError) {
	_args := &Z_ReadFileArgs{path}
	_returns := &Z_ReadFileReturns{}
	if err := g.client.Call("Plugin.ReadFile", _args, _returns); err != nil {
		log.Printf("RPC call to ReadFile API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) ReadFile(args *Z_ReadFileArgs, returns *Z_ReadFileReturns) error {
	if hook, ok := s.impl.(interface {
		ReadFile(path string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.ReadFile(args.A)
	} else {
		return encodableError(fmt.Errorf("API ReadFile called but not implemented."))
	}
	return nil
}

type Z_GetPluginsArgs struct {
}

type Z_GetPluginsReturns struct {
	A []*plugins.Manifest
	B *model.AppError
}

func (g *apiRPCClient) GetPlugins() ([]*plugins.Manifest, *model.AppError) {
	_args := &Z_GetPluginsArgs{}
	_returns := &Z_GetPluginsReturns{}
	if err := g.client.Call("Plugin.GetPlugins", _args, _returns); err != nil {
		log.Printf("RPC call to GetPlugins API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPlugins(args *Z_GetPluginsArgs, returns *Z_GetPluginsReturns) error {
	if hook, ok := s.impl.(interface {
		GetPlugins() ([]*plugins.Manifest, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPlugins()
	} else {
		return encodableError(fmt.Errorf("API GetPlugins called but not implemented."))
	}
	return nil
}

type Z_EnablePluginArgs struct {
	A string
}

type Z_EnablePluginReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) EnablePlugin(id string) *model.AppError {
	_args := &Z_EnablePluginArgs{id}
	_returns := &Z_EnablePluginReturns{}
	if err := g.client.Call("Plugin.EnablePlugin", _args, _returns); err != nil {
		log.Printf("RPC call to EnablePlugin API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) EnablePlugin(args *Z_EnablePluginArgs, returns *Z_EnablePluginReturns) error {
	if hook, ok := s.impl.(interface {
		EnablePlugin(id string) *model.AppError
	}); ok {
		returns.A = hook.EnablePlugin(args.A)
	} else {
		return encodableError(fmt.Errorf("API EnablePlugin called but not implemented."))
	}
	return nil
}

type Z_DisablePluginArgs struct {
	A string
}

type Z_DisablePluginReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DisablePlugin(id string) *model.AppError {
	_args := &Z_DisablePluginArgs{id}
	_returns := &Z_DisablePluginReturns{}
	if err := g.client.Call("Plugin.DisablePlugin", _args, _returns); err != nil {
		log.Printf("RPC call to DisablePlugin API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DisablePlugin(args *Z_DisablePluginArgs, returns *Z_DisablePluginReturns) error {
	if hook, ok := s.impl.(interface {
		DisablePlugin(id string) *model.AppError
	}); ok {
		returns.A = hook.DisablePlugin(args.A)
	} else {
		return encodableError(fmt.Errorf("API DisablePlugin called but not implemented."))
	}
	return nil
}

type Z_RemovePluginArgs struct {
	A string
}

type Z_RemovePluginReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) RemovePlugin(id string) *model.AppError {
	_args := &Z_RemovePluginArgs{id}
	_returns := &Z_RemovePluginReturns{}
	if err := g.client.Call("Plugin.RemovePlugin", _args, _returns); err != nil {
		log.Printf("RPC call to RemovePlugin API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) RemovePlugin(args *Z_RemovePluginArgs, returns *Z_RemovePluginReturns) error {
	if hook, ok := s.impl.(interface {
		RemovePlugin(id string) *model.AppError
	}); ok {
		returns.A = hook.RemovePlugin(args.A)
	} else {
		return encodableError(fmt.Errorf("API RemovePlugin called but not implemented."))
	}
	return nil
}

type Z_GetPluginStatusArgs struct {
	A string
}

type Z_GetPluginStatusReturns struct {
	A *plugins.PluginStatus
	B *model.AppError
}

func (g *apiRPCClient) GetPluginStatus(id string) (*plugins.PluginStatus, *model.AppError) {
	_args := &Z_GetPluginStatusArgs{id}
	_returns := &Z_GetPluginStatusReturns{}
	if err := g.client.Call("Plugin.GetPluginStatus", _args, _returns); err != nil {
		log.Printf("RPC call to GetPluginStatus API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPluginStatus(args *Z_GetPluginStatusArgs, returns *Z_GetPluginStatusReturns) error {
	if hook, ok := s.impl.(interface {
		GetPluginStatus(id string) (*plugins.PluginStatus, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPluginStatus(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetPluginStatus called but not implemented."))
	}
	return nil
}

type Z_KVSetArgs struct {
	A string
	B []byte
}

type Z_KVSetReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVSet(key string, value []byte) *model.AppError {
	_args := &Z_KVSetArgs{key, value}
	_returns := &Z_KVSetReturns{}
	if err := g.client.Call("Plugin.KVSet", _args, _returns); err != nil {
		log.Printf("RPC call to KVSet API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVSet(args *Z_KVSetArgs, returns *Z_KVSetReturns) error {
	if hook, ok := s.impl.(interface {
		KVSet(key string, value []byte) *model.AppError
	}); ok {
		returns.A = hook.KVSet(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API KVSet called but not implemented."))
	}
	return nil
}

type Z_KVCompareAndSetArgs struct {
	A string
	B []byte
	C []byte
}

type Z_KVCompareAndSetReturns struct {
	A bool
	B *model.AppError
}

func (g *apiRPCClient) KVCompareAndSet(key string, oldValue, newValue []byte) (bool, *model.AppError) {
	_args := &Z_KVCompareAndSetArgs{key, oldValue, newValue}
	_returns := &Z_KVCompareAndSetReturns{}
	if err := g.client.Call("Plugin.KVCompareAndSet", _args, _returns); err != nil {
		log.Printf("RPC call to KVCompareAndSet API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVCompareAndSet(args *Z_KVCompareAndSetArgs, returns *Z_KVCompareAndSetReturns) error {
	if hook, ok := s.impl.(interface {
		KVCompareAndSet(key string, oldValue, newValue []byte) (bool, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVCompareAndSet(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API KVCompareAndSet called but not implemented."))
	}
	return nil
}

type Z_KVCompareAndDeleteArgs struct {
	A string
	B []byte
}

type Z_KVCompareAndDeleteReturns struct {
	A bool
	B *model.AppError
}

func (g *apiRPCClient) KVCompareAndDelete(key string, oldValue []byte) (bool, *model.AppError) {
	_args := &Z_KVCompareAndDeleteArgs{key, oldValue}
	_returns := &Z_KVCompareAndDeleteReturns{}
	if err := g.client.Call("Plugin.KVCompareAndDelete", _args, _returns); err != nil {
		log.Printf("RPC call to KVCompareAndDelete API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVCompareAndDelete(args *Z_KVCompareAndDeleteArgs, returns *Z_KVCompareAndDeleteReturns) error {
	if hook, ok := s.impl.(interface {
		KVCompareAndDelete(key string, oldValue []byte) (bool, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVCompareAndDelete(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API KVCompareAndDelete called but not implemented."))
	}
	return nil
}

type Z_KVSetWithOptionsArgs struct {
	A string
	B []byte
	C plugins.PluginKVSetOptions
}

type Z_KVSetWithOptionsReturns struct {
	A bool
	B *model.AppError
}

func (g *apiRPCClient) KVSetWithOptions(key string, value []byte, options plugins.PluginKVSetOptions) (bool, *model.AppError) {
	_args := &Z_KVSetWithOptionsArgs{key, value, options}
	_returns := &Z_KVSetWithOptionsReturns{}
	if err := g.client.Call("Plugin.KVSetWithOptions", _args, _returns); err != nil {
		log.Printf("RPC call to KVSetWithOptions API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVSetWithOptions(args *Z_KVSetWithOptionsArgs, returns *Z_KVSetWithOptionsReturns) error {
	if hook, ok := s.impl.(interface {
		KVSetWithOptions(key string, value []byte, options plugins.PluginKVSetOptions) (bool, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVSetWithOptions(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API KVSetWithOptions called but not implemented."))
	}
	return nil
}

type Z_KVSetWithExpiryArgs struct {
	A string
	B []byte
	C int64
}

type Z_KVSetWithExpiryReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVSetWithExpiry(key string, value []byte, expireInSeconds int64) *model.AppError {
	_args := &Z_KVSetWithExpiryArgs{key, value, expireInSeconds}
	_returns := &Z_KVSetWithExpiryReturns{}
	if err := g.client.Call("Plugin.KVSetWithExpiry", _args, _returns); err != nil {
		log.Printf("RPC call to KVSetWithExpiry API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVSetWithExpiry(args *Z_KVSetWithExpiryArgs, returns *Z_KVSetWithExpiryReturns) error {
	if hook, ok := s.impl.(interface {
		KVSetWithExpiry(key string, value []byte, expireInSeconds int64) *model.AppError
	}); ok {
		returns.A = hook.KVSetWithExpiry(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API KVSetWithExpiry called but not implemented."))
	}
	return nil
}

type Z_KVGetArgs struct {
	A string
}

type Z_KVGetReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) KVGet(key string) ([]byte, *model.AppError) {
	_args := &Z_KVGetArgs{key}
	_returns := &Z_KVGetReturns{}
	if err := g.client.Call("Plugin.KVGet", _args, _returns); err != nil {
		log.Printf("RPC call to KVGet API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVGet(args *Z_KVGetArgs, returns *Z_KVGetReturns) error {
	if hook, ok := s.impl.(interface {
		KVGet(key string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVGet(args.A)
	} else {
		return encodableError(fmt.Errorf("API KVGet called but not implemented."))
	}
	return nil
}

type Z_KVDeleteArgs struct {
	A string
}

type Z_KVDeleteReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVDelete(key string) *model.AppError {
	_args := &Z_KVDeleteArgs{key}
	_returns := &Z_KVDeleteReturns{}
	if err := g.client.Call("Plugin.KVDelete", _args, _returns); err != nil {
		log.Printf("RPC call to KVDelete API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVDelete(args *Z_KVDeleteArgs, returns *Z_KVDeleteReturns) error {
	if hook, ok := s.impl.(interface {
		KVDelete(key string) *model.AppError
	}); ok {
		returns.A = hook.KVDelete(args.A)
	} else {
		return encodableError(fmt.Errorf("API KVDelete called but not implemented."))
	}
	return nil
}

type Z_KVDeleteAllArgs struct {
}

type Z_KVDeleteAllReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVDeleteAll() *model.AppError {
	_args := &Z_KVDeleteAllArgs{}
	_returns := &Z_KVDeleteAllReturns{}
	if err := g.client.Call("Plugin.KVDeleteAll", _args, _returns); err != nil {
		log.Printf("RPC call to KVDeleteAll API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVDeleteAll(args *Z_KVDeleteAllArgs, returns *Z_KVDeleteAllReturns) error {
	if hook, ok := s.impl.(interface {
		KVDeleteAll() *model.AppError
	}); ok {
		returns.A = hook.KVDeleteAll()
	} else {
		return encodableError(fmt.Errorf("API KVDeleteAll called but not implemented."))
	}
	return nil
}

type Z_KVListArgs struct {
	A int
	B int
}

type Z_KVListReturns struct {
	A []string
	B *model.AppError
}

func (g *apiRPCClient) KVList(page, perPage int) ([]string, *model.AppError) {
	_args := &Z_KVListArgs{page, perPage}
	_returns := &Z_KVListReturns{}
	if err := g.client.Call("Plugin.KVList", _args, _returns); err != nil {
		log.Printf("RPC call to KVList API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVList(args *Z_KVListArgs, returns *Z_KVListReturns) error {
	if hook, ok := s.impl.(interface {
		KVList(page, perPage int) ([]string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVList(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API KVList called but not implemented."))
	}
	return nil
}

type Z_PublishWebSocketEventArgs struct {
	A string
	B map[string]interface{}
	C *model.WebsocketBroadcast
}

type Z_PublishWebSocketEventReturns struct {
}

func (g *apiRPCClient) PublishWebSocketEvent(event string, payload map[string]interface{}, broadcast *model.WebsocketBroadcast) {
	_args := &Z_PublishWebSocketEventArgs{event, payload, broadcast}
	_returns := &Z_PublishWebSocketEventReturns{}
	if err := g.client.Call("Plugin.PublishWebSocketEvent", _args, _returns); err != nil {
		log.Printf("RPC call to PublishWebSocketEvent API failed: %s", err.Error())
	}

}

func (s *apiRPCServer) PublishWebSocketEvent(args *Z_PublishWebSocketEventArgs, returns *Z_PublishWebSocketEventReturns) error {
	if hook, ok := s.impl.(interface {
		PublishWebSocketEvent(event string, payload map[string]interface{}, broadcast *model.WebsocketBroadcast)
	}); ok {
		hook.PublishWebSocketEvent(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API PublishWebSocketEvent called but not implemented."))
	}
	return nil
}

type Z_HasPermissionToArgs struct {
	A string
	B *model.Permission
}

type Z_HasPermissionToReturns struct {
	A bool
}

func (g *apiRPCClient) HasPermissionTo(userID string, permission *model.Permission) bool {
	_args := &Z_HasPermissionToArgs{userID, permission}
	_returns := &Z_HasPermissionToReturns{}
	if err := g.client.Call("Plugin.HasPermissionTo", _args, _returns); err != nil {
		log.Printf("RPC call to HasPermissionTo API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) HasPermissionTo(args *Z_HasPermissionToArgs, returns *Z_HasPermissionToReturns) error {
	if hook, ok := s.impl.(interface {
		HasPermissionTo(userID string, permission *model.Permission) bool
	}); ok {
		returns.A = hook.HasPermissionTo(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API HasPermissionTo called but not implemented."))
	}
	return nil
}

type Z_SendMailArgs struct {
	A string
	B string
	C string
}

type Z_SendMailReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SendMail(to, subject, htmlBody string) *model.AppError {
	_args := &Z_SendMailArgs{to, subject, htmlBody}
	_returns := &Z_SendMailReturns{}
	if err := g.client.Call("Plugin.SendMail", _args, _returns); err != nil {
		log.Printf("RPC call to SendMail API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SendMail(args *Z_SendMailArgs, returns *Z_SendMailReturns) error {
	if hook, ok := s.impl.(interface {
		SendMail(to, subject, htmlBody string) *model.AppError
	}); ok {
		returns.A = hook.SendMail(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API SendMail called but not implemented."))
	}
	return nil
}
