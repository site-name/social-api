extend type Mutation {
  productTypeCreate(input: ProductTypeInput!): ProductTypeCreate
  productTypeDelete(id: String!): ProductTypeDelete
  productTypeBulkDelete(ids: [String]!): ProductTypeBulkDelete
  productTypeUpdate(id: String!, input: ProductTypeInput!): ProductTypeUpdate
  productTypeReorderAttributes(moves: [ReorderInput]!, productTypeId: String!, type: ProductAttributeType!): ProductTypeReorderAttributes
}

extend type Query {
  productType(id: String!): ProductType
  productTypes(filter: ProductTypeFilterInput, sortBy: ProductTypeSortingInput, before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection
}

type ProductType implements Node & ObjectWithMetadata {
  id: String!
  name: String!
  slug: String!
  hasVariants: Boolean!
  isShippingRequired: Boolean!
  isDigital: Boolean!
  weight: Weight
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  kind: ProductTypeKindEnum!
  taxType: TaxType
  variantAttributes(variantSelection: VariantAttributeScope): [Attribute]
  productAttributes: [Attribute]
  availableAttributes(filter: AttributeFilterInput, before: String, after: String, first: Int, last: Int): AttributeCountableConnection
}

input ProductTypeInput {
  name: String
  slug: String
  kind: ProductTypeKindEnum
  hasVariants: Boolean
  productAttributes: [String]
  variantAttributes: [String]
  isShippingRequired: Boolean
  isDigital: Boolean
  weight: WeightScalar
  taxCode: String
}

enum ProductTypeKindEnum {
  NORMAL
  GIFT_CARD
}

type ProductTypeCreate {
  errors: [ProductError!]!
  productType: ProductType
}

type ProductTypeDelete {
  errors: [ProductError!]!
  productType: ProductType
}

type ProductTypeBulkDelete {
  count: Int!
  errors: [ProductError!]!
}

type ProductTypeUpdate {
  errors: [ProductError!]!
  productType: ProductType
}

input ReorderInput {
  id: String!
  sortOrder: Int
}

type ProductTypeReorderAttributes {
  productType: ProductType
  errors: [ProductError!]!
}

enum ProductTypeEnum {
  DIGITAL
  SHIPPABLE
}

input ProductTypeFilterInput {
  search: String
  configurable: ProductTypeConfigurable
  productType: ProductTypeEnum
  metadata: [MetadataInput]
  kind: ProductTypeKindEnum
  ids: [String]
}

enum ProductTypeSortField {
  NAME
  DIGITAL
  SHIPPING_REQUIRED
}

input ProductTypeSortingInput {
  direction: OrderDirection!
  field: ProductTypeSortField!
}

type ProductTypeCountableConnection {
  pageInfo: PageInfo!
  edges: [ProductTypeCountableEdge!]!
  totalCount: Int
}

type ProductTypeCountableEdge {
  node: ProductType!
  cursor: String!
}

enum ProductTypeConfigurable {
  CONFIGURABLE
  SIMPLE
}
