extend type Mutation {
  collectionAddProducts(collectionId: String!, products: [String!]!): CollectionAddProducts @hasRoleAny(roles: [shop_admin, shop_staff])
  collectionCreate(input: CollectionCreateInput!): CollectionCreate @hasRoleAny(roles: [shop_admin, shop_staff])
  collectionDelete(id: String!): CollectionDelete @hasRoles(roles: [shop_admin])
  collectionReorderProducts(collectionId: String!, moves: [MoveProductInput]!): CollectionReorderProducts @hasRoles(roles: [shop_admin])
  collectionBulkDelete(ids: [String!]!): CollectionBulkDelete @hasRoles(roles: [shop_admin])
  collectionRemoveProducts(collectionId: String!, products: [String!]!): CollectionRemoveProducts @hasRoles(roles: [shop_admin])
  collectionUpdate(id: String!, input: CollectionInput!): CollectionUpdate @hasRoleAny(roles: [shop_admin, shop_staff])
  collectionTranslate(id: String!, input: TranslationInput!, languageCode: LanguageCodeEnum!): CollectionTranslate
  collectionChannelListingUpdate(id: String!, input: CollectionChannelListingUpdateInput!): CollectionChannelListingUpdate @hasRoles(roles: [shop_admin])
}

extend type Query {
  collection(id: String, slug: String, channel: String): Collection
  collections(filter: CollectionFilterInput, sortBy: CollectionSortingInput, channel: String, before: String, after: String, first: Int, last: Int): CollectionCountableConnection
}

type Collection  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String!
  description: JSONString!
  slug: String!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  channel: String
  products(filter: ProductFilterInput, sortBy: ProductOrder, before: String, after: String, first: Int, last: Int): ProductCountableConnection
  backgroundImage(size: Int): Image
  translation(languageCode: LanguageCodeEnum!): CollectionTranslation
  channelListings: [CollectionChannelListing!]!
}

type CollectionAddProducts {
  collection: Collection
  errors: [CollectionError!]!
}

input CollectionCreateInput {
  isPublished: Boolean
  name: String
  slug: String
  description: JSONString!
  backgroundImage: Upload
  backgroundImageAlt: String
  seo: SeoInput
  publicationDate: Date
  products: [String!]!
}

type CollectionCreate {
  errors: [CollectionError!]!
  collection: Collection
}

type CollectionDelete {
  errors: [CollectionError!]!
  collection: Collection
}

input MoveProductInput {
  productId: String!
  sortOrder: Int
}

type CollectionReorderProducts {
  collection: Collection
  errors: [CollectionError!]!
}

type CollectionBulkDelete {
  count: Int!
  errors: [CollectionError!]!
}

type CollectionRemoveProducts {
  collection: Collection
  errors: [CollectionError!]!
}

input CollectionInput {
  isPublished: Boolean
  name: String
  slug: String
  description: JSONString!
  backgroundImage: Upload
  backgroundImageAlt: String
  seo: SeoInput
  publicationDate: Date
}

type CollectionUpdate {
  errors: [CollectionError!]!
  collection: Collection
}

type CollectionTranslate {
  errors: [TranslationError!]!
  collection: Collection
}

input CollectionChannelListingUpdateInput {
  addChannels: [PublishableChannelListingInput!]!
  removeChannels: [String!]!
}

type CollectionChannelListingUpdate {
  collection: Collection
  errors: [CollectionChannelListingError!]!
}

input CollectionFilterInput {
  published: CollectionPublished
  search: String
  metadata: [MetadataInput]!
  ids: [String!]!
  # channel: String # Deprecated
}

enum CollectionPublished {
  PUBLISHED
  HIDDEN
}

enum CollectionSortField {
  NAME
  AVAILABILITY
  PRODUCT_COUNT
  PUBLICATION_DATE
}

input CollectionSortingInput {
  direction: OrderDirection!
  field: CollectionSortField!
  # channel: String # Deprecated
}

type CollectionCountableConnection {
  pageInfo: PageInfo!
  edges: [CollectionCountableEdge!]!
  totalCount: Int
}

type CollectionTranslation  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String
  description: JSONString!
  language: LanguageDisplay!
}

type CollectionChannelListing  {
  id: String!
  publicationDate: Date
  isPublished: Boolean!
  channel: Channel!
}

type CollectionError {
  field: String
  message: String
  products: [String!]!
  code: CollectionErrorCode!
}

enum CollectionErrorCode {
  DUPLICATED_INPUT_ITEM
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
  CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT
}

input PublishableChannelListingInput {
  channelId: String!
  isPublished: Boolean
  publicationDate: Date
}

type CollectionChannelListingError {
  field: String
  message: String
  code: ProductErrorCode!
  attributes: [String!]!
  values: [String!]!
  channels: [String!]!
}

type CollectionCountableEdge {
  node: Collection!
  cursor: String!
}
