// Code generated by mockery v1.0.0. DO NOT EDIT.

// Regenerate this file using `make einterfaces-mocks`.

package mocks

import (
	einterfaces "github.com/sitename/sitename/einterfaces"
	checkout "github.com/sitename/sitename/model/checkout"

	mock "github.com/stretchr/testify/mock"
)

// PaymentInterface is an autogenerated mock type for the PaymentInterface type
type PaymentInterface struct {
	mock.Mock
}

// AuthorizePayment provides a mock function with given fields: gateway, paymentInformation
func (_m *PaymentInterface) AuthorizePayment(gateway string, paymentInformation *einterfaces.PaymentData) *einterfaces.GatewayResponse {
	ret := _m.Called(gateway, paymentInformation)

	var r0 *einterfaces.GatewayResponse
	if rf, ok := ret.Get(0).(func(string, *einterfaces.PaymentData) *einterfaces.GatewayResponse); ok {
		r0 = rf(gateway, paymentInformation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*einterfaces.GatewayResponse)
		}
	}

	return r0
}

// CapturePayment provides a mock function with given fields: gateway, paymentInformation
func (_m *PaymentInterface) CapturePayment(gateway string, paymentInformation *einterfaces.PaymentData) *einterfaces.GatewayResponse {
	ret := _m.Called(gateway, paymentInformation)

	var r0 *einterfaces.GatewayResponse
	if rf, ok := ret.Get(0).(func(string, *einterfaces.PaymentData) *einterfaces.GatewayResponse); ok {
		r0 = rf(gateway, paymentInformation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*einterfaces.GatewayResponse)
		}
	}

	return r0
}

// ConfirmPayment provides a mock function with given fields: gateway, paymentInformation
func (_m *PaymentInterface) ConfirmPayment(gateway string, paymentInformation *einterfaces.PaymentData) *einterfaces.GatewayResponse {
	ret := _m.Called(gateway, paymentInformation)

	var r0 *einterfaces.GatewayResponse
	if rf, ok := ret.Get(0).(func(string, *einterfaces.PaymentData) *einterfaces.GatewayResponse); ok {
		r0 = rf(gateway, paymentInformation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*einterfaces.GatewayResponse)
		}
	}

	return r0
}

// GetClientToken provides a mock function with given fields: gateway, tokenConfig
func (_m *PaymentInterface) GetClientToken(gateway string, tokenConfig *einterfaces.TokenConfig) string {
	ret := _m.Called(gateway, tokenConfig)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, *einterfaces.TokenConfig) string); ok {
		r0 = rf(gateway, tokenConfig)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ListPaymentGateWays provides a mock function with given fields: currency, _a1, activeOnly
func (_m *PaymentInterface) ListPaymentGateWays(currency string, _a1 *checkout.Checkout, activeOnly bool) []*einterfaces.PaymentGateway {
	ret := _m.Called(currency, _a1, activeOnly)

	var r0 []*einterfaces.PaymentGateway
	if rf, ok := ret.Get(0).(func(string, *checkout.Checkout, bool) []*einterfaces.PaymentGateway); ok {
		r0 = rf(currency, _a1, activeOnly)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*einterfaces.PaymentGateway)
		}
	}

	return r0
}

// ListPaymentSources provides a mock function with given fields: gateway, customerId
func (_m *PaymentInterface) ListPaymentSources(gateway string, customerId string) []*einterfaces.CustomerSource {
	ret := _m.Called(gateway, customerId)

	var r0 []*einterfaces.CustomerSource
	if rf, ok := ret.Get(0).(func(string, string) []*einterfaces.CustomerSource); ok {
		r0 = rf(gateway, customerId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*einterfaces.CustomerSource)
		}
	}

	return r0
}

// ProcessPayment provides a mock function with given fields: gateway, paymentInformation
func (_m *PaymentInterface) ProcessPayment(gateway string, paymentInformation *einterfaces.PaymentData) *einterfaces.GatewayResponse {
	ret := _m.Called(gateway, paymentInformation)

	var r0 *einterfaces.GatewayResponse
	if rf, ok := ret.Get(0).(func(string, *einterfaces.PaymentData) *einterfaces.GatewayResponse); ok {
		r0 = rf(gateway, paymentInformation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*einterfaces.GatewayResponse)
		}
	}

	return r0
}

// RefundPayent provides a mock function with given fields: gateway, paymentInformation
func (_m *PaymentInterface) RefundPayent(gateway string, paymentInformation *einterfaces.PaymentData) *einterfaces.GatewayResponse {
	ret := _m.Called(gateway, paymentInformation)

	var r0 *einterfaces.GatewayResponse
	if rf, ok := ret.Get(0).(func(string, *einterfaces.PaymentData) *einterfaces.GatewayResponse); ok {
		r0 = rf(gateway, paymentInformation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*einterfaces.GatewayResponse)
		}
	}

	return r0
}

// TokenIsRequiredAsPaymentInput provides a mock function with given fields: gateway
func (_m *PaymentInterface) TokenIsRequiredAsPaymentInput(gateway string) bool {
	ret := _m.Called(gateway)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(gateway)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// VoidPayment provides a mock function with given fields: gateway, paymentInformation
func (_m *PaymentInterface) VoidPayment(gateway string, paymentInformation *einterfaces.PaymentData) *einterfaces.GatewayResponse {
	ret := _m.Called(gateway, paymentInformation)

	var r0 *einterfaces.GatewayResponse
	if rf, ok := ret.Get(0).(func(string, *einterfaces.PaymentData) *einterfaces.GatewayResponse); ok {
		r0 = rf(gateway, paymentInformation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*einterfaces.GatewayResponse)
		}
	}

	return r0
}
