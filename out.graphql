extend type Mutation {
  accountAddressCreate(input: AddressInput!, type: AddressTypeEnum): AccountAddressCreate
  accountAddressUpdate(id: String!, input: AddressInput!): AccountAddressUpdate
  accountAddressDelete(id: String!): AccountAddressDelete
  accountSetDefaultAddress(id: String!, type: AddressTypeEnum!): AccountSetDefaultAddress
  accountRegister(input: AccountRegisterInput!): AccountRegister
  accountUpdate(input: AccountInput!): AccountUpdate
  accountRequestDeletion(channel: String, redirectUrl: String!): AccountRequestDeletion
  accountDelete(token: String!): AccountDelete
}

type AccountAddressCreate {
  user: User
  # errors: [AccountError!]!
  address: Address
}

type AccountAddressUpdate {
  user: User
  # errors: [AccountError!]!
  address: Address
}

type AccountAddressDelete {
  ok: Boolean!
  # user: User
  # errors: [AccountError!]!
  # address: Address
}

type AccountSetDefaultAddress {
  user: User
  # errors: [AccountError!]!
}

input AccountRegisterInput {
  firstName: String
  lastName: String
  userName: String!
  email: String!
  password: String!
  redirectUrl: String
  languageCode: LanguageCodeEnum
  metadata: [MetadataInput]!
  channel: String
}

type AccountRegister {
  requiresConfirmation: Boolean
  # errors: [AccountError!]!
  user: User
}

input AccountInput {
  firstName: String
  lastName: String
  defaultBillingAddress: AddressInput
  defaultShippingAddress: AddressInput
  languageCode: LanguageCodeEnum
}

type AccountUpdate {
  # errors: [AccountError!]!
  user: User
}

type AccountRequestDeletion {
  # errors: [AccountError!]!
  ok: Boolean!
}

type AccountDelete {
  # errors: [AccountError!]!
  user: User
}

type AccountError {
  field: String
  message: String
  code: AccountErrorCode!
  # addressType: AddressTypeEnum
}

enum AccountErrorCode {
  ACTIVATE_OWN_ACCOUNT
  ACTIVATE_SUPERUSER_ACCOUNT
  DUPLICATED_INPUT_ITEM
  DEACTIVATE_OWN_ACCOUNT
  DEACTIVATE_SUPERUSER_ACCOUNT
  DELETE_NON_STAFF_USER
  DELETE_OWN_ACCOUNT
  DELETE_STAFF_ACCOUNT
  DELETE_SUPERUSER_ACCOUNT
  GRAPHQL_ERROR
  INACTIVE
  INVALID
  INVALID_PASSWORD
  LEFT_NOT_MANAGEABLE_PERMISSION
  INVALID_CREDENTIALS
  NOT_FOUND
  OUT_OF_SCOPE_USER
  OUT_OF_SCOPE_GROUP
  OUT_OF_SCOPE_PERMISSION
  PASSWORD_ENTIRELY_NUMERIC
  PASSWORD_TOO_COMMON
  PASSWORD_TOO_SHORT
  PASSWORD_TOO_SIMILAR
  REQUIRED
  UNIQUE
  JWT_SIGNATURE_EXPIRED
  JWT_INVALID_TOKEN
  JWT_DECODE_ERROR
  JWT_MISSING_TOKEN
  JWT_INVALID_CSRF_TOKEN
  CHANNEL_INACTIVE
  MISSING_CHANNEL_SLUG
}

extend type Mutation {
  addressCreate(input: AddressInput!, userId: String!): AddressCreate
  addressUpdate(id: String!, input: AddressInput!): AddressUpdate
  addressDelete(id: String!): AddressDelete
  addressSetDefault(addressId: String!, type: AddressTypeEnum!, userId: String!): AddressSetDefault
}

extend type Query {
  addressValidationRules(countryCode: CountryCode!, countryArea: String, city: String, cityArea: String): AddressValidationData
  address(id: String!): Address
}

type Address {
  id: String!
  firstName: String!
  lastName: String!
  companyName: String!
  streetAddress1: String!
  streetAddress2: String!
  city: String!
  cityArea: String!
  postalCode: String!
  country: CountryDisplay!
  countryArea: String!
  phone: String!
  isDefaultShippingAddress: Boolean
  isDefaultBillingAddress: Boolean
}

input AddressInput {
  firstName: String
  lastName: String
  companyName: String
  streetAddress1: String
  streetAddress2: String
  city: String
  cityArea: String
  postalCode: String
  country: CountryCode
  countryArea: String
  phone: String
}

type AddressCreate {
  user: User
  errors: [AccountError!]!
  address: Address
}

type AddressDelete {
  user: User
  errors: [AccountError!]!
  address: Address
}

type AddressUpdate {
  user: User
  errors: [AccountError!]!
  address: Address
}

enum AddressTypeEnum {
  billing
  shipping
}

type AddressSetDefault {
  user: User
  errors: [AccountError!]!
}

type AddressValidationData {
  countryCode: String
  countryName: String
  addressFormat: String
  addressLatinFormat: String
  allowedFields: [String!]!
  requiredFields: [String!]!
  upperFields: [String!]!
  countryAreaType: String
  countryAreaChoices: [ChoiceValue]!
  cityType: String
  cityChoices: [ChoiceValue]!
  cityAreaType: String
  cityAreaChoices: [ChoiceValue]!
  postalCodeType: String
  postalCodeMatchers: [String!]!
  postalCodeExamples: [String!]!
  postalCodePrefix: String
}

type ChoiceValue {
  raw: String
  verbose: String
}

type CountryDisplay {
  code: String!
  country: String!
  vat: VAT
}

type VAT {
  countryCode: String!
  standardRate: Float
  reducedRates: [ReducedRate]!
}

type ReducedRate {
  rate: Float!
  rateType: String!
}

extend type Mutation {
  appCreate(input: AppInput!): AppCreate
  appUpdate(id: String!, input: AppInput!): AppUpdate
  appDelete(id: String!): AppDelete
  appTokenCreate(input: AppTokenInput!): AppTokenCreate
  appTokenDelete(id: String!): AppTokenDelete
  appTokenVerify(token: String!): AppTokenVerify
  appInstall(input: AppInstallInput!): AppInstall
  appRetryInstall(activateAfterInstallation: Boolean!, id: String!): AppRetryInstall
  appDeleteFailedInstallation(id: String!): AppDeleteFailedInstallation
  appFetchManifest(manifestUrl: String!): AppFetchManifest
  appActivate(id: String!): AppActivate
  appDeactivate(id: String!): AppDeactivate
}

extend type Query {
  appsInstallations: [AppInstallation!]!
  apps(filter: AppFilterInput, sortBy: AppSortingInput, before: String, after: String, first: Int, last: Int): AppCountableConnection
  app(id: String): App
  appExtensions(filter: AppExtensionFilterInput, before: String, after: String, first: Int, last: Int): AppExtensionCountableConnection
  appExtension(id: String!): AppExtension
}

type App {
  id: String!
  name: String
  created: DateTime
  isActive: Boolean
  permissions: [Permission]!
  tokens: [AppToken]!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  type: AppTypeEnum
  webhooks: [Webhook]!
  aboutApp: String
  dataPrivacy: String
  dataPrivacyUrl: String
  homepageUrl: String
  supportUrl: String
  configurationUrl: String
  appUrl: String
  version: String
  accessToken: String
  extensions: [AppExtension!]!
}

type AppExtension {
  id: String!
  app: App!
  label: String!
  url: String!
  view: AppExtensionViewEnum!
  type: AppExtensionTypeEnum!
  target: AppExtensionTargetEnum!
  permissions: [Permission!]!
  accessToken: String
}

type AppExtensionCountableConnection {
  pageInfo: PageInfo!
  edges: [AppExtensionCountableEdge!]!
  totalCount: Int
}

type AppExtensionCountableEdge {
  node: AppExtension!
  cursor: String!
}

input AppExtensionFilterInput {
  view: AppExtensionViewEnum
  type: AppExtensionTypeEnum
  target: AppExtensionTargetEnum
}

enum AppExtensionTargetEnum {
  MORE_ACTIONS
  CREATE
}

enum AppExtensionTypeEnum {
  OVERVIEW
  DETAILS
}

enum AppExtensionViewEnum {
  PRODUCT
}

type AppManifestExtension {
  permissions: [Permission!]!
  label: String!
  url: String!
  view: AppExtensionViewEnum!
  type: AppExtensionTypeEnum!
  target: AppExtensionTargetEnum!
}

input AppInput {
  name: String
  permissions: [PermissionEnum]!
}

type AppCreate {
  authToken: String
  errors: [AppError!]!
  app: App
}

type AppUpdate {
  errors: [AppError!]!
  app: App
}

input AppTokenInput {
  name: String
  app: String!
}

type AppTokenCreate {
  authToken: String
  errors: [AppError!]!
  appToken: AppToken
}

type AppTokenDelete {
  errors: [AppError!]!
  appToken: AppToken
}

type AppTokenVerify {
  valid: Boolean!
  errors: [AppError!]!
}

type AppInstall {
  errors: [AppError!]!
  appInstallation: AppInstallation
}

type AppRetryInstall {
  errors: [AppError!]!
  appInstallation: AppInstallation
}

type AppDeleteFailedInstallation {
  errors: [AppError!]!
  appInstallation: AppInstallation
}

type AppFetchManifest {
  manifest: Manifest
  errors: [AppError!]!
}

type AppActivate {
  errors: [AppError!]!
  app: App
}

type AppDeactivate {
  errors: [AppError!]!
  app: App
}

type AppInstallation  {
  appName: String!
  manifestUrl: String!
  id: String!
  status: JobStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  message: String
}

input AppFilterInput {
  search: String
  isActive: Boolean
  type: AppTypeEnum
}

enum AppSortField {
  NAME
  CREATION_DATE
}

input AppSortingInput {
  direction: OrderDirection!
  field: AppSortField!
}

type AppCountableConnection {
  pageInfo: PageInfo!
  edges: [AppCountableEdge!]!
  totalCount: Int
}

type AppCountableEdge {
  node: App!
  cursor: String!
}

enum AppTypeEnum {
  LOCAL
  THIRDPARTY
}

type AppDelete {
  errors: [AppError!]!
  app: App
}

type AppError {
  field: String
  message: String
  code: AppErrorCode!
  permissions: [PermissionEnum!]!
}

enum AppErrorCode {
  FORBIDDEN
  GRAPHQL_ERROR
  INVALID
  INVALID_STATUS
  INVALID_PERMISSION
  INVALID_URL_FORMAT
  INVALID_MANIFEST_FORMAT
  MANIFEST_URL_CANT_CONNECT
  NOT_FOUND
  REQUIRED
  UNIQUE
  OUT_OF_SCOPE_APP
  OUT_OF_SCOPE_PERMISSION
}

type AppToken  {
  name: String
  authToken: String
  id: String!
}

input AppInstallInput {
  appName: String
  manifestUrl: String
  activateAfterInstallation: Boolean
  permissions: [PermissionEnum]!
}

type Manifest {
  identifier: String!
  version: String!
  name: String!
  about: String
  permissions: [Permission]!
  appUrl: String
  configurationUrl: String
  tokenTargetUrl: String
  dataPrivacy: String
  dataPrivacyUrl: String
  homepageUrl: String
  supportUrl: String
  extensions: [AppManifestExtension!]!
}

extend type Mutation {
  attributeCreate(input: AttributeCreateInput!): AttributeCreate
  attributeDelete(id: String!): AttributeDelete
  attributeUpdate(id: String!, input: AttributeUpdateInput!): AttributeUpdate
  attributeTranslate(id: String!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): AttributeTranslate
  attributeBulkDelete(ids: [String!]!): AttributeBulkDelete
  attributeValueBulkDelete(ids: [String!]!): AttributeValueBulkDelete
  attributeValueCreate(attributeID: String!, input: AttributeValueCreateInput!): AttributeValueCreate
  attributeValueDelete(id: String!): AttributeValueDelete
  attributeValueUpdate(id: String!, input: AttributeValueUpdateInput!): AttributeValueUpdate
  attributeValueTranslate(id: String!, input: AttributeValueTranslationInput!, languageCode: LanguageCodeEnum!): AttributeValueTranslate
  attributeReorderValues(attributeId: String!, moves: [ReorderInput]!): AttributeReorderValues
}

extend type Query {
  attributes(filter: AttributeFilterInput, sortBy: AttributeSortingInput, chanelSlug: String, before: String, after: String, first: Int, last: Int): AttributeCountableConnection
  attribute(id: String, slug: String): Attribute
}

type Attribute  {
  id: String!
  productTypes(before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection!
  productVariantTypes(before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  inputType: AttributeInputTypeEnum
  entityType: AttributeEntityTypeEnum
  name: String
  slug: String
  type: AttributeTypeEnum
  unit: MeasurementUnitsEnum
  choices(sortBy: AttributeChoicesSortingInput, filter: AttributeValueFilterInput, before: String, after: String, first: Int, last: Int): AttributeValueCountableConnection
  valueRequired: Boolean!
  visibleInStorefront: Boolean!
  filterableInStorefront: Boolean!
  filterableInDashboard: Boolean!
  availableInGrid: Boolean!
  translation(languageCode: LanguageCodeEnum!): AttributeTranslation
  storefrontSearchPosition: Int!
  withChoices: Boolean!
}

input AttributeValueFilterInput {
  search: String
}

enum AttributeChoicesSortField {
  NAME
  SLUG
}

input AttributeChoicesSortingInput {
  direction: OrderDirection!
  field: AttributeChoicesSortField!
}

type AttributeValueCountableConnection {
  pageInfo: PageInfo!
  edges: [AttributeValueCountableEdge!]!
  totalCount: Int
}

type AttributeValueCountableEdge {
  node: AttributeValue!
  cursor: String!
}

type SelectedAttribute {
  attribute: Attribute!
  values: [AttributeValue]!
}

input AttributeCreateInput {
  inputType: AttributeInputTypeEnum
  entityType: AttributeEntityTypeEnum
  name: String!
  slug: String
  type: AttributeTypeEnum!
  unit: MeasurementUnitsEnum
  values: [AttributeValueCreateInput]!
  valueRequired: Boolean
  isVariantOnly: Boolean
  visibleInStorefront: Boolean
  filterableInStorefront: Boolean
  filterableInDashboard: Boolean
  storefrontSearchPosition: Int
  availableInGrid: Boolean
}

type AttributeCreate {
  attribute: Attribute
  errors: [AttributeError!]!
}

type AttributeDelete {
  errors: [AttributeError!]!
  attribute: Attribute
}

input AttributeUpdateInput {
  name: String
  slug: String
  unit: MeasurementUnitsEnum
  removeValues: [String!]!
  addValues: [AttributeValueUpdateInput]!
  valueRequired: Boolean
  isVariantOnly: Boolean
  visibleInStorefront: Boolean
  filterableInStorefront: Boolean
  filterableInDashboard: Boolean
  storefrontSearchPosition: Int
  availableInGrid: Boolean
}

input AttributeValueUpdateInput {
  value: String
  richText: JSONString!
  fileUrl: String
  contentType: String
  name: String!
}

type AttributeUpdate {
  attribute: Attribute
  errors: [AttributeError!]!
}

type AttributeTranslate {
  errors: [TranslationError!]!
  attribute: Attribute
}

type AttributeBulkDelete {
  count: Int!
  errors: [AttributeError!]!
}

type AttributeValueBulkDelete {
  count: Int!
  errors: [AttributeError!]!
}

input AttributeValueCreateInput {
  name: String!
  value: String
  richText: JSONString!
  fileUrl: String
  contentType: String
}

type AttributeValueUpdate {
  attribute: Attribute
  errors: [AttributeError!]!
  attributeValue: AttributeValue
}

input AttributeValueTranslationInput {
  name: String
  richText: JSONString!
}

type AttributeValueTranslate {
  errors: [TranslationError!]!
  attributeValue: AttributeValue
}

type AttributeReorderValues {
  attribute: Attribute
  errors: [AttributeError!]!
}

enum AttributeEntityTypeEnum {
  page
  product
}

type AttributeError {
  field: String
  message: String
  code: AttributeErrorCode!
}

enum AttributeErrorCode {
  already_exists
  graphql_error
  invalid
  not_found
  required
  unique
}

input AttributeFilterInput {
  valueRequired: Boolean
  isVariantOnly: Boolean
  visibleInStorefront: Boolean
  filterableInStorefront: Boolean
  filterableInDashboard: Boolean
  availableInGrid: Boolean
  metadata: [MetadataInput]!
  search: String
  ids: [String!]!
  type: AttributeTypeEnum
  inCollection: String
  inCategory: String
  channel: String
}

enum AttributeSortField {
  NAME
  SLUG
  VALUE_REQUIRED
  IS_VARIANT_ONLY
  VISIBLE_IN_STOREFRONT
  FILTERABLE_IN_STOREFRONT
  FILTERABLE_IN_DASHBOARD
  STOREFRONT_SEARCH_POSITION
  AVAILABLE_IN_GRID
}

input AttributeSortingInput {
  direction: OrderDirection!
  field: AttributeSortField!
}

type AttributeCountableConnection {
  pageInfo: PageInfo!
  edges: [AttributeCountableEdge!]!
  totalCount: Int
}

type AttributeCountableEdge {
  node: Attribute!
  cursor: String!
}

input AttributeInput {
  slug: String!
  values: [String!]!
  valuesRange: IntRangeInput
  dateTime: DateTimeRangeInput
  date: DateRangeInput
  boolean: Boolean
}

enum AttributeInputTypeEnum {
  dropdown
  multiselect
  file
  reference
  numeric
  rich_text
  swatch
  boolean
  date
  date_time
}

type AttributeTranslation  {
  id: String!
  name: String!
  language: LanguageDisplay!
}

enum AttributeTypeEnum {
  product_type
  page_type
}

type AttributeValue  {
  id: String!
  name: String!
  slug: String!
  value: String!
  translation(languageCode: LanguageCodeEnum!): AttributeValueTranslation
  inputType: AttributeInputTypeEnum
  reference: String
  file: File
  richText: JSONString!
  boolean: Boolean
  date: Date
  dateTime: DateTime
}

type AttributeValueTranslation  {
  id: String!
  name: String!
  richText: JSONString!
  language: LanguageDisplay!
}

type AttributeValueDelete {
  attribute: Attribute
  errors: [AttributeError!]!
  attributeValue: AttributeValue
}

type AttributeValueCreate {
  attribute: Attribute
  errors: [AttributeError!]!
  attributeValue: AttributeValue
}

extend type Mutation {
  # NOTE: tokenCreate mutation is borrowed from mattermost
  tokenCreate(input: TokenCreateInput!): CreateToken # tokenCreate(email: String!, password: String!): CreateToken
  tokenRefresh(csrfToken: String, refreshToken: String): RefreshToken
  tokenVerify(token: String!): VerifyToken
  tokensDeactivateAll: DeactivateAllUserTokens
  externalAuthenticationUrl(input: JSONString!, pluginId: String!): ExternalAuthenticationUrl
  externalObtainAccessTokens(input: JSONString!, pluginId: String!): ExternalObtainAccessTokens
  externalRefresh(input: JSONString!, pluginId: String!): ExternalRefresh
  externalLogout(input: JSONString!, pluginId: String!): ExternalLogout
  externalVerify(input: JSONString!, pluginId: String!): ExternalVerify
  requestPasswordReset(channel: String, email: String!, redirectUrl: String!): RequestPasswordReset
  confirmAccount(email: String!, token: String!): ConfirmAccount
  setPassword(email: String!, password: String!, token: String!): SetPassword
  passwordChange(newPassword: String!, oldPassword: String!): PasswordChange
  requestEmailChange(channel: String, newEmail: String!, password: String!, redirectUrl: String!): RequestEmailChange
  confirmEmailChange(channel: String, token: String!): ConfirmEmailChange
}

# This input type idea is borrowed from Mattermost
input TokenCreateInput {
  id: String!
  loginId: String!
  password: String!
  token: String!
  deviceId: String!
  ldapOnly: String!
}

type CreateToken {
  token: String
  refreshToken: String
  csrfToken: String
  user: User
  # errors: [AccountError!]!
}

type RefreshToken {
  token: String
  user: User
  # errors: [AccountError!]!
}

type VerifyToken {
  user: User
  isValid: Boolean!
  payload: JSONString!
  # errors: [AccountError!]!
}

type DeactivateAllUserTokens {
  ok: Boolean! # errors: [AccountError!]!
}

type ExternalAuthenticationUrl {
  authenticationData: JSONString!
  # errors: [AccountError!]!
}

type ExternalObtainAccessTokens {
  token: String
  refreshToken: String
  csrfToken: String
  user: User
  # errors: [AccountError!]!
}

type ExternalRefresh {
  token: String
  refreshToken: String
  csrfToken: String
  user: User
  # errors: [AccountError!]!
}

type ExternalLogout {
  logoutData: JSONString!
  # errors: [AccountError!]!
}

type ExternalVerify {
  user: User
  isValid: Boolean!
  verifyData: JSONString!
  # errors: [AccountError!]!
}

type RequestPasswordReset {
  ok: Boolean! # errors: [AccountError!]!
}

type ConfirmAccount {
  user: User
  # errors: [AccountError!]!
}

type SetPassword {
  token: String
  refreshToken: String
  csrfToken: String
  user: User
  # errors: [AccountError!]!
}

type PasswordChange {
  user: User
  # errors: [AccountError!]!
}

type RequestEmailChange {
  user: User
  # errors: [AccountError!]!
}

type ConfirmEmailChange {
  user: User
  # errors: [AccountError!]!
}

extend type Mutation {
  categoryCreate(input: CategoryInput!, parent: String): CategoryCreate
  categoryDelete(id: String!): CategoryDelete
  categoryBulkDelete(ids: [String!]!): CategoryBulkDelete
  categoryUpdate(id: String!, input: CategoryInput!): CategoryUpdate
  categoryTranslate(id: String!, input: TranslationInput!, languageCode: LanguageCodeEnum!): CategoryTranslate
}

extend type Query {
  categories(filter: CategoryFilterInput, sortBy: CategorySortingInput!, level: Int, before: String, after: String, first: Int, last: Int): CategoryCountableConnection
  category(id: String, slug: String): Category
}

type Category  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String!
  description: JSONString!
  slug: String!
  parent: Category
  level: Int!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  ancestors(before: String, after: String, first: Int, last: Int): CategoryCountableConnection
  products(channel: String, before: String, after: String, first: Int, last: Int): ProductCountableConnection
  children(before: String, after: String, first: Int, last: Int): CategoryCountableConnection
  backgroundImage(size: Int): Image
  translation(languageCode: LanguageCodeEnum!): CategoryTranslation
}

input CategoryInput {
  description: JSONString!
  name: String
  slug: String
  seo: SeoInput
  backgroundImage: Upload
  backgroundImageAlt: String
}

type CategoryCreate {
  errors: [ProductError!]!
  category: Category
}

type CategoryDelete {
  errors: [ProductError!]!
  category: Category
}

type CategoryBulkDelete {
  count: Int!
  errors: [ProductError!]!
}

type CategoryUpdate {
  errors: [ProductError!]!
  category: Category
}

type CategoryTranslate {
  errors: [TranslationError!]!
  category: Category
}

input CategoryFilterInput {
  search: String
  # metadata: [MetadataInput]! // TODO: add support this field
  ids: [String!]!
}

input CategorySortingInput {
  direction: OrderDirection!
  # channel: String
  field: CategorySortField!
}

type CategoryCountableConnection {
  pageInfo: PageInfo!
  edges: [CategoryCountableEdge!]!
  totalCount: Int
}

type CategoryTranslation  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String
  description: JSONString!
  language: LanguageDisplay!
}

type CategoryCountableEdge {
  node: Category!
  cursor: String!
}

extend type Mutation {
  channelCreate(input: ChannelCreateInput!): ChannelCreate
  channelUpdate(id: String!, input: ChannelUpdateInput!): ChannelUpdate
  channelDelete(id: String!, input: ChannelDeleteInput): ChannelDelete
  channelActivate(id: String!): ChannelActivate
  channelDeactivate(id: String!): ChannelDeactivate
}

extend type Query {
  channel(id: String): Channel
  channels: [Channel]!
}

type Channel  {
  id: String!
  name: String!
  isActive: Boolean!
  slug: String!
  currencyCode: String!
  hasOrders: Boolean!
  defaultCountry: CountryDisplay!
}

input ChannelCreateInput {
  isActive: Boolean
  name: String!
  slug: String!
  currencyCode: String!
  defaultCountry: CountryCode!
  addShippingZones: [String!]!
}

type ChannelCreate {
  errors: [ChannelError!]!
  channel: Channel
}

input ChannelUpdateInput {
  isActive: Boolean
  name: String
  slug: String
  defaultCountry: CountryCode
  addShippingZones: [String!]!
  removeShippingZones: [String!]!
}

type ChannelUpdate {
  errors: [ChannelError!]!
  channel: Channel
}

input ChannelDeleteInput {
  channelId: String!
}

type ChannelDelete {
  errors: [ChannelError!]!
  channel: Channel
}

type ChannelActivate {
  channel: Channel
  errors: [ChannelError!]!
}

type ChannelDeactivate {
  channel: Channel
  errors: [ChannelError!]!
}

type ChannelError {
  field: String
  message: String
  code: ChannelErrorCode!
  shippingZones: [String!]!
}

enum ChannelErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
  CHANNELS_CURRENCY_MUST_BE_THE_SAME
  CHANNEL_WITH_ORDERS
  DUPLICATED_INPUT_ITEM
}

extend type Mutation {
  checkoutAddPromoCode(promoCode: String!, token: String): CheckoutAddPromoCode
  checkoutBillingAddressUpdate(billingAddress: AddressInput!, token: String): CheckoutBillingAddressUpdate
  checkoutComplete(paymentData: JSONString!, redirectUrl: String, storeSource: Boolean, token: String): CheckoutComplete
  checkoutCreate(input: CheckoutCreateInput!): CheckoutCreate
  checkoutCustomerAttach(customerId: String, token: String): CheckoutCustomerAttach
  checkoutCustomerDetach(token: String): CheckoutCustomerDetach
  checkoutEmailUpdate(email: String!, token: String): CheckoutEmailUpdate
  checkoutRemovePromoCode(promoCode: String!, token: String): CheckoutRemovePromoCode
  checkoutPaymentCreate(input: PaymentInput!, token: String): CheckoutPaymentCreate
  checkoutShippingAddressUpdate(shippingAddress: AddressInput!, token: String): CheckoutShippingAddressUpdate
  # checkoutShippingMethodUpdate(shippingMethodId: String!, token: String): CheckoutShippingMethodUpdate
  checkoutDeliveryMethodUpdate(deliveryMethodId: String, token: String): CheckoutDeliveryMethodUpdate
  checkoutLanguageCodeUpdate(languageCode: LanguageCodeEnum!, token: String): CheckoutLanguageCodeUpdate
}

extend type Query {
  checkout(token: String): Checkout
  checkouts(channel: String, before: String, after: String, first: Int, last: Int): CheckoutCountableConnection
}

type CheckoutDeliveryMethodUpdate {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type Checkout  {
  created: DateTime!
  lastChange: DateTime!
  user: User
  channel: Channel!
  billingAddress: Address
  shippingAddress: Address
  note: String!
  discount: Money
  discountName: String
  translatedDiscountName: String
  voucherCode: String
  giftCards: [GiftCard]!
  id: String!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  availableShippingMethods: [ShippingMethod]!
  availableCollectionPoints: [Warehouse!]!
  availablePaymentGateways: [PaymentGateway!]!
  email: String!
  isShippingRequired: Boolean!
  quantity: Int!
  lines: [CheckoutLine]!
  shippingPrice: TaxedMoney
  # shippingMethod: ShippingMethod
  deliveryMethod: DeliveryMethod
  subtotalPrice: TaxedMoney
  token: String!
  totalPrice: TaxedMoney
  languageCode: LanguageCodeEnum!
}

type CheckoutAddPromoCode {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutBillingAddressUpdate {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutComplete {
  order: Order
  confirmationNeeded: Boolean!
  confirmationData: JSONString!
  errors: [CheckoutError!]!
}

input CheckoutCreateInput {
  channel: String
  lines: [CheckoutLineInput]!
  email: String
  shippingAddress: AddressInput
  billingAddress: AddressInput
  languageCode: LanguageCodeEnum
}

type CheckoutCreate {
  # created: Boolean
  errors: [CheckoutError!]!
  checkout: Checkout
}

type CheckoutCustomerAttach {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutCustomerDetach {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutEmailUpdate {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutRemovePromoCode {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutPaymentCreate {
  checkout: Checkout
  payment: Payment
  errors: [PaymentError!]!
}

input PaymentInput {
  gateway: String!
  token: String
  amount: PositiveDecimal
  returnUrl: String
  storePaymentMethod: StorePaymentMethodEnum
  metadata: [MetadataInput!]!
}

enum StorePaymentMethodEnum {
  ON_SESSION
  OFF_SESSION
  NONE
}

type CheckoutShippingAddressUpdate {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutShippingMethodUpdate {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutLanguageCodeUpdate {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutCountableConnection {
  pageInfo: PageInfo!
  edges: [CheckoutCountableEdge!]!
  totalCount: Int
}

type CheckoutCountableEdge {
  node: Checkout!
  cursor: String!
}

type PaymentGateway {
  name: String!
  id: String!
  config: [GatewayConfigLine!]!
  currencies: [String!]!
}

type CheckoutError {
  field: String
  message: String
  code: CheckoutErrorCode!
  variants: [String!]!
  addressType: AddressTypeEnum
}

enum CheckoutErrorCode {
  BILLING_ADDRESS_NOT_SET
  CHECKOUT_NOT_FULLY_PAID
  GRAPHQL_ERROR
  PRODUCT_NOT_PUBLISHED
  PRODUCT_UNAVAILABLE_FOR_PURCHASE
  INSUFFICIENT_STOCK
  INVALID
  INVALID_SHIPPING_METHOD
  NOT_FOUND
  PAYMENT_ERROR
  QUANTITY_GREATER_THAN_LIMIT
  REQUIRED
  SHIPPING_ADDRESS_NOT_SET
  SHIPPING_METHOD_NOT_APPLICABLE
  DELIVERY_METHOD_NOT_APPLICABLE
  SHIPPING_METHOD_NOT_SET
  SHIPPING_NOT_REQUIRED
  TAX_ERROR
  UNIQUE
  VOUCHER_NOT_APPLICABLE
  GIFT_CARD_NOT_APPLICABLE
  ZERO_QUANTITY
  MISSING_CHANNEL_SLUG
  CHANNEL_INACTIVE
  UNAVAILABLE_VARIANT_IN_CHANNEL
}

type GatewayConfigLine {
  field: String!
  value: String
}

extend type Mutation {
  checkoutLineDelete(checkoutId: String, lineId: String, token: String): CheckoutLineDelete
  checkoutLinesAdd(checkoutId: String, lines: [CheckoutLineInput]!, token: String): CheckoutLinesAdd
  checkoutLinesUpdate(checkoutId: String, lines: [CheckoutLineInput]!, token: String): CheckoutLinesUpdate
}

extend type Query {
  # checkoutLine(id: String): CheckoutLine
  checkoutLines(before: String, after: String, first: Int, last: Int): CheckoutLineCountableConnection
}

type CheckoutLine  {
  id: String!
  variant: ProductVariant!
  quantity: Int!
  totalPrice: TaxedMoney
  requiresShipping: Boolean
}

type CheckoutLineDelete {
  checkout: Checkout
  errors: [CheckoutError!]!
}

input CheckoutLineInput {
  quantity: Int!
  variantId: String!
}

type CheckoutLinesAdd {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutLinesUpdate {
  checkout: Checkout
  errors: [CheckoutError!]!
}

type CheckoutLineCountableConnection {
  pageInfo: PageInfo!
  edges: [CheckoutLineCountableEdge!]!
  totalCount: Int
}

type CheckoutLineCountableEdge {
  node: CheckoutLine!
  cursor: String!
}

extend type Mutation {
  collectionAddProducts(collectionId: String!, products: [String!]!): CollectionAddProducts
  collectionCreate(input: CollectionCreateInput!): CollectionCreate
  collectionDelete(id: String!): CollectionDelete
  collectionReorderProducts(collectionId: String!, moves: [MoveProductInput]!): CollectionReorderProducts
  collectionBulkDelete(ids: [String!]!): CollectionBulkDelete
  collectionRemoveProducts(collectionId: String!, products: [String!]!): CollectionRemoveProducts
  collectionUpdate(id: String!, input: CollectionInput!): CollectionUpdate
  collectionTranslate(id: String!, input: TranslationInput!, languageCode: LanguageCodeEnum!): CollectionTranslate
  collectionChannelListingUpdate(id: String!, input: CollectionChannelListingUpdateInput!): CollectionChannelListingUpdate
}

extend type Query {
  collection(id: String, slug: String, channel: String): Collection
  collections(filter: CollectionFilterInput, sortBy: CollectionSortingInput, channel: String, before: String, after: String, first: Int, last: Int): CollectionCountableConnection
}

type Collection  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String!
  description: JSONString!
  slug: String!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  channel: String
  products(
    # filter: ProductFilterInput, sortBy: ProductOrder, 
    before: String, after: String, first: Int, last: Int): ProductCountableConnection
  backgroundImage(size: Int): Image
  translation(languageCode: LanguageCodeEnum!): CollectionTranslation
  channelListings: [CollectionChannelListing!]!
}

type CollectionAddProducts {
  collection: Collection
  errors: [CollectionError!]!
}

input CollectionCreateInput {
  isPublished: Boolean
  name: String
  slug: String
  description: JSONString!
  backgroundImage: Upload
  backgroundImageAlt: String
  seo: SeoInput
  publicationDate: Date
  products: [String!]!
}

type CollectionCreate {
  errors: [CollectionError!]!
  collection: Collection
}

type CollectionDelete {
  errors: [CollectionError!]!
  collection: Collection
}

input MoveProductInput {
  productId: String!
  sortOrder: Int
}

type CollectionReorderProducts {
  collection: Collection
  errors: [CollectionError!]!
}

type CollectionBulkDelete {
  count: Int!
  errors: [CollectionError!]!
}

type CollectionRemoveProducts {
  collection: Collection
  errors: [CollectionError!]!
}

input CollectionInput {
  isPublished: Boolean
  name: String
  slug: String
  description: JSONString!
  backgroundImage: Upload
  backgroundImageAlt: String
  seo: SeoInput
  publicationDate: Date
}

type CollectionUpdate {
  errors: [CollectionError!]!
  collection: Collection
}

type CollectionTranslate {
  errors: [TranslationError!]!
  collection: Collection
}

input CollectionChannelListingUpdateInput {
  addChannels: [PublishableChannelListingInput!]!
  removeChannels: [String!]!
}

type CollectionChannelListingUpdate {
  collection: Collection
  errors: [CollectionChannelListingError!]!
}

input CollectionFilterInput {
  published: CollectionPublished
  search: String
  metadata: [MetadataInput]!
  ids: [String!]!
  channel: String
}

enum CollectionPublished {
  PUBLISHED
  HIDDEN
}

enum CollectionSortField {
  NAME
  AVAILABILITY
  PRODUCT_COUNT
  PUBLICATION_DATE
}

input CollectionSortingInput {
  direction: OrderDirection!
  channel: String
  field: CollectionSortField!
}

type CollectionCountableConnection {
  pageInfo: PageInfo!
  edges: [CollectionCountableEdge!]!
  totalCount: Int
}

type CollectionTranslation  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String
  description: JSONString!
  language: LanguageDisplay!
}

type CollectionChannelListing  {
  id: String!
  publicationDate: Date
  isPublished: Boolean!
  channel: Channel!
}

type CollectionError {
  field: String
  message: String
  products: [String!]!
  code: CollectionErrorCode!
}

enum CollectionErrorCode {
  DUPLICATED_INPUT_ITEM
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
  CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT
}

input PublishableChannelListingInput {
  channelId: String!
  isPublished: Boolean
  publicationDate: Date
}

type CollectionChannelListingError {
  field: String
  message: String
  code: ProductErrorCode!
  attributes: [String!]!
  values: [String!]!
  channels: [String!]!
}

type CollectionCountableEdge {
  node: Collection!
  cursor: String!
}

extend type Mutation {
  exportProducts(input: ExportProductsInput!): ExportProducts # @hasPermissions(permissions: [MANAGE_PRODUCTS])
}

extend type Query {
  exportFile(id: String!): ExportFile @hasPermissions(permissions: [MANAGE_PRODUCTS])
  exportFiles(filter: ExportFileFilterInput, sortBy: ExportFileSortingInput, before: String, after: String, first: Int, last: Int): ExportFileCountableConnection @hasPermissions(permissions: [MANAGE_PRODUCTS])
}

input ExportProductsInput {
  scope: ExportScope!
  filter: ProductFilterInput
  ids: [String!]!
  exportInfo: ExportInfoInput
  fileType: FileTypesEnum!
}

enum ExportScope {
  ALL
  IDS
  FILTER
}

type ExportProducts {
  exportFile: ExportFile
  # errors: [ExportError!]!
}

type ExportFile  {
  id: String!
  user: User
  # app: App
  status: JobStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  message: String
  url: String
  events: [ExportEvent!]!
}

input ExportFileFilterInput {
  createdAt: DateTimeRangeInput
  updatedAt: DateTimeRangeInput
  status: JobStatusEnum
  user: String
  # app: String
}

input ExportFileSortingInput {
  direction: OrderDirection!
  field: ExportFileSortField!
}

type ExportFileCountableConnection {
  pageInfo: PageInfo!
  edges: [ExportFileCountableEdge!]!
  totalCount: Int
}

enum FileTypesEnum {
  csv
  xlsx
}

# type ExportError {
#   field: String
#   message: String
#   code: ExportErrorCode!
# }

# enum ExportErrorCode {
#   GRAPHQL_ERROR
#   INVALID
#   NOT_FOUND
#   REQUIRED
# }

type ExportEvent  {
  id: String!
  date: DateTime!
  type: ExportEventsEnum!
  user: User
  # app: App
  message: String!
}

enum ExportEventsEnum {
  export_pending
  export_success
  export_failed
  export_deleted
  exported_file_sent
  export_failed_info_sent
}

enum ExportFileSortField {
  STATUS
  CREATED_AT
  UPDATED_AT
}

type ExportFileCountableEdge {
  node: ExportFile!
  cursor: String!
}

input ExportInfoInput {
  attributes: [String!]!
  warehouses: [String!]!
  channels: [String!]!
  fields: [ProductFieldEnum!]!
}

enum ProductFieldEnum {
  NAME
  DESCRIPTION
  PRODUCT_TYPE
  CATEGORY
  PRODUCT_WEIGHT
  COLLECTIONS
  CHARGE_TAXES
  PRODUCT_MEDIA
  VARIANT_ID
  VARIANT_SKU
  VARIANT_WEIGHT
  VARIANT_MEDIA
}

extend type Mutation {
  customerCreate(input: UserCreateInput!): CustomerCreate
  customerUpdate(id: String!, input: CustomerInput!): CustomerUpdate
  customerDelete(id: String!): CustomerDelete
  customerBulkDelete(ids: [String!]!): CustomerBulkDelete
}

extend type Query {
  customers(filter: CustomerFilterInput, sortBy: UserSortingInput, before: String, after: String, first: Int, last: Int): UserCountableConnection
}

input UserCreateInput {
  defaultBillingAddress: AddressInput
  defaultShippingAddress: AddressInput
  firstName: String
  lastName: String
  email: String
  isActive: Boolean
  note: String
  languageCode: LanguageCodeEnum
  redirectUrl: String
  channel: String
}

type CustomerCreate {
  errors: [AccountError!]!
  user: User
}

input CustomerInput {
  defaultBillingAddress: AddressInput
  defaultShippingAddress: AddressInput
  firstName: String
  lastName: String
  email: String
  isActive: Boolean
  note: String
  languageCode: LanguageCodeEnum
}

type CustomerUpdate {
  errors: [AccountError!]!
  user: User
}

type CustomerDelete {
  errors: [AccountError!]!
  user: User
}

type CustomerBulkDelete {
  count: Int!
  errors: [AccountError!]!
}

input CustomerFilterInput {
  dateJoined: DateRangeInput
  numberOfOrders: IntRangeInput
  placedOrders: DateRangeInput
  search: String
  metadata: [MetadataInput]!
}

input UserSortingInput {
  direction: OrderDirection!
  field: UserSortField!
}

type UserCountableConnection {
  pageInfo: PageInfo!
  edges: [UserCountableEdge!]!
  totalCount: Int
}

enum UserSortField {
  FIRST_NAME
  LAST_NAME
  EMAIL
  ORDER_COUNT
}

type UserCountableEdge {
  node: User!
  cursor: String!
}

extend type Mutation {
  digitalContentCreate(input: DigitalContentUploadInput!, variantId: String!): DigitalContentCreate
  digitalContentDelete(variantId: String!): DigitalContentDelete
  digitalContentUpdate(input: DigitalContentInput!, variantId: String!): DigitalContentUpdate
  digitalContentUrlCreate(input: DigitalContentUrlCreateInput!): DigitalContentUrlCreate
}

extend type Query {
  digitalContent(id: String!): DigitalContent
  digitalContents(before: String, after: String, first: Int, last: Int): DigitalContentCountableConnection
}

type DigitalContent  {
  useDefaultSettings: Boolean!
  automaticFulfillment: Boolean!
  contentFile: String!
  maxDownloads: Int
  urlValidDays: Int
  urls: [DigitalContentUrl]!
  id: String!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  productVariant: ProductVariant!
}

input DigitalContentUploadInput {
  useDefaultSettings: Boolean!
  maxDownloads: Int
  urlValidDays: Int
  automaticFulfillment: Boolean
  contentFile: Upload!
}

type DigitalContentCreate {
  variant: ProductVariant
  content: DigitalContent
  errors: [ProductError!]!
}

type DigitalContentDelete {
  variant: ProductVariant
  errors: [ProductError!]!
}

input DigitalContentInput {
  useDefaultSettings: Boolean!
  maxDownloads: Int
  urlValidDays: Int
  automaticFulfillment: Boolean
}

type DigitalContentUpdate {
  variant: ProductVariant
  content: DigitalContent
  errors: [ProductError!]!
}

input DigitalContentUrlCreateInput {
  content: String!
}

type DigitalContentUrlCreate {
  errors: [ProductError!]!
  digitalContentUrl: DigitalContentUrl
}

type DigitalContentCountableConnection {
  pageInfo: PageInfo!
  edges: [DigitalContentCountableEdge!]!
  totalCount: Int
}

type DigitalContentCountableEdge {
  node: DigitalContent!
  cursor: String!
}

type DigitalContentUrl  {
  content: DigitalContent!
  created: DateTime!
  downloadNum: Int!
  id: String!
  url: String
  token: String!
}

# hasPermissions checks user is authenticated and has permissions
directive @hasPermissions(permissions: [PermissionEnum!]!) on FIELD_DEFINITION

# authenticated checks if user is authenticated
directive @authenticated(hi: Boolean!) on FIELD_DEFINITION

extend type Mutation {
  voucherCreate(input: VoucherInput!): VoucherCreate
  voucherDelete(id: String!): VoucherDelete
  voucherBulkDelete(ids: [String!]!): VoucherBulkDelete
  voucherUpdate(id: String!, input: VoucherInput!): VoucherUpdate
  voucherCataloguesAdd(id: String!, input: CatalogueInput!): VoucherAddCatalogues
  voucherCataloguesRemove(id: String!, input: CatalogueInput!): VoucherRemoveCatalogues
  voucherTranslate(id: String!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): VoucherTranslate
  voucherChannelListingUpdate(id: String!, input: VoucherChannelListingInput!): VoucherChannelListingUpdate
}

extend type Query {
  voucher(id: String!, channel: String): Voucher
  vouchers(filter: VoucherFilterInput, sortBy: VoucherSortingInput, query: String, channel: String, before: String, after: String, first: Int, last: Int): VoucherCountableConnection
}

type Voucher  {
  id: String!
  name: String
  type: VoucherTypeEnum!
  code: String!
  usageLimit: Int
  used: Int!
  startDate: DateTime!
  endDate: DateTime
  applyOncePerOrder: Boolean!
  applyOncePerCustomer: Boolean!
  discountValueType: DiscountValueTypeEnum!
  minCheckoutItemsQuantity: Int
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  categories(before: String, after: String, first: Int, last: Int): CategoryCountableConnection
  collections(before: String, after: String, first: Int, last: Int): CollectionCountableConnection
  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection
  variants(before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection
  countries: [CountryDisplay]!
  translation(languageCode: LanguageCodeEnum!): VoucherTranslation
  discountValue: Float
  currency: String
  minSpent: Money
  channelListings: [VoucherChannelListing!]!
}

input VoucherInput {
  type: VoucherTypeEnum
  name: String
  code: String
  startDate: DateTime
  endDate: DateTime
  discountValueType: DiscountValueTypeEnum
  products: [String!]!
  variants: [String!]!
  collections: [String!]!
  categories: [String!]!
  minCheckoutItemsQuantity: Int
  countries: [String!]!
  applyOncePerOrder: Boolean
  applyOncePerCustomer: Boolean
  usageLimit: Int
}

type VoucherCreate {
  errors: [DiscountError!]!
  voucher: Voucher
}

type VoucherDelete {
  errors: [DiscountError!]!
  voucher: Voucher
}

type VoucherBulkDelete {
  count: Int!
  errors: [DiscountError!]!
}

type VoucherUpdate {
  errors: [DiscountError!]!
  voucher: Voucher
}

type VoucherAddCatalogues {
  voucher: Voucher
  errors: [DiscountError!]!
}

type VoucherRemoveCatalogues {
  voucher: Voucher
  errors: [DiscountError!]!
}

type VoucherTranslate {
  errors: [TranslationError!]!
  voucher: Voucher
}

input VoucherChannelListingInput {
  addChannels: [VoucherChannelListingAddInput!]!
  removeChannels: [String!]!
}

type VoucherChannelListingUpdate {
  voucher: Voucher
  errors: [DiscountError!]!
}

input VoucherFilterInput {
  status: [DiscountStatusEnum]!
  timesUsed: IntRangeInput
  discountType: [VoucherDiscountType]!
  started: DateTimeRangeInput
  search: String
  metadata: [MetadataFilter]!
}

enum VoucherSortField {
  CODE
  START_DATE
  END_DATE
  VALUE
  TYPE
  USAGE_LIMIT
  MINIMUM_SPENT_AMOUNT
}

input VoucherSortingInput {
  direction: OrderDirection!
  channel: String
  field: VoucherSortField!
}

type VoucherCountableConnection {
  pageInfo: PageInfo!
  edges: [VoucherCountableEdge!]!
  totalCount: Int
}

type VoucherCountableEdge {
  node: Voucher!
  cursor: String!
}

enum VoucherTypeEnum {
  shipping
  entire_order
  specific_product
}

type VoucherTranslation  {
  id: String!
  name: String
  language: LanguageDisplay!
}

type VoucherChannelListing  {
  id: String!
  channel: Channel!
  discountValue: Float!
  currency: String!
  minSpent: Money
}

type DiscountError {
  field: String
  message: String
  products: [String!]!
  code: DiscountErrorCode!
  channels: [String!]!
}

enum DiscountErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
  CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT
  DUPLICATED_INPUT_ITEM
}

input VoucherChannelListingAddInput {
  channelId: String!
  discountValue: PositiveDecimal
  minAmountSpent: PositiveDecimal
}

enum DiscountStatusEnum {
  ACTIVE
  EXPIRED
  SCHEDULED
}

enum VoucherDiscountType {
  fixed
  percentage
  shipping
}

extend type Mutation {
  draftOrderComplete(id: String!): DraftOrderComplete
  draftOrderCreate(input: DraftOrderCreateInput!): DraftOrderCreate
  draftOrderDelete(id: String!): DraftOrderDelete
  draftOrderBulkDelete(ids: [String!]!): DraftOrderBulkDelete
  # draftOrderLinesBulkDelete(ids: [String!]!): DraftOrderLinesBulkDelete
  draftOrderUpdate(id: String!, input: DraftOrderInput!): DraftOrderUpdate
}

type DraftOrderComplete {
  order: Order
  errors: [OrderError!]!
}

input DraftOrderCreateInput {
  billingAddress: AddressInput
  user: String
  userEmail: String
  discount: PositiveDecimal
  shippingAddress: AddressInput
  shippingMethod: String
  voucher: String
  customerNote: String
  channelId: String
  redirectUrl: String
  lines: [OrderLineCreateInput]!
}

type DraftOrderCreate {
  errors: [OrderError!]!
  order: Order
}

type DraftOrderDelete {
  errors: [OrderError!]!
  order: Order
}

type DraftOrderBulkDelete {
  count: Int!
  errors: [OrderError!]!
}

type DraftOrderLinesBulkDelete {
  count: Int!
  errors: [OrderError!]!
}

input DraftOrderInput {
  billingAddress: AddressInput
  user: String
  userEmail: String
  discount: PositiveDecimal
  shippingAddress: AddressInput
  shippingMethod: String
  voucher: String
  customerNote: String
  channelId: String
  redirectUrl: String
}

type DraftOrderUpdate {
  errors: [OrderError!]!
  order: Order
}

extend type Mutation {
  giftCardActivate(id: String!): GiftCardActivate
  giftCardCreate(input: GiftCardCreateInput!): GiftCardCreate
  giftCardDelete(id: String!): GiftCardDelete
  giftCardDeactivate(id: String!): GiftCardDeactivate
  giftCardUpdate(id: String!, input: GiftCardUpdateInput!): GiftCardUpdate
  giftCardResend(input: GiftCardResendInput!): GiftCardResend
  giftCardAddNote(id: String!, input: GiftCardAddNoteInput!): GiftCardAddNote
  giftCardBulkDelete(ids: [String!]!): GiftCardBulkDelete
  giftCardBulkActivate(ids: [String!]!): GiftCardBulkActivate
  giftCardBulkDeactivate(ids: [String!]!): GiftCardBulkDeactivate
}

extend type Query {
  giftCard(id: String!): GiftCard
  giftCardSettings: GiftCardSettings!
  giftCards(sortBy: GiftCardSortingInput, filter: GiftCardFilterInput, before: String, after: String, first: Int, last: Int): GiftCardCountableConnection
  giftCardCurrencies: [String!]!
}

type GiftCard  {
  code: String!
  isActive: Boolean!
  expiryDate: Date
  tag: String
  created: DateTime!
  lastUsedOn: DateTime
  initialBalance: Money
  currentBalance: Money
  id: String!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  displayCode: String!
  createdBy: User
  usedBy: User
  createdByEmail: String
  usedByEmail: String
  app: App
  product: Product
  events: [GiftCardEvent!]!
  boughtInChannel: String
}

type GiftCardDelete {
  errors: [GiftCardError!]!
  giftCard: GiftCard
}

type GiftCardActivate {
  giftCard: GiftCard
  errors: [GiftCardError!]!
}

input GiftCardCreateInput {
  tag: String
  expiryDate: Date
  startDate: Date
  endDate: Date
  balance: PriceInput!
  userEmail: String
  channel: String
  isActive: Boolean!
  code: String
  note: String
}

type GiftCardCreate {
  errors: [GiftCardError!]!
  giftCard: GiftCard
}

type GiftCardDeactivate {
  giftCard: GiftCard
  errors: [GiftCardError!]!
}

input GiftCardUpdateInput {
  tag: String
  expiryDate: Date
  startDate: Date
  endDate: Date
  balanceAmount: PositiveDecimal
}

type GiftCardUpdate {
  errors: [GiftCardError!]!
  giftCard: GiftCard
}

type GiftCardCountableConnection {
  pageInfo: PageInfo!
  edges: [GiftCardCountableEdge!]!
  totalCount: Int
}

type GiftCardCountableEdge {
  node: GiftCard!
  cursor: String!
}

type GiftCardError {
  field: String
  message: String
  code: GiftCardErrorCode!
}

enum GiftCardErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

type GiftCardAddNote {
  giftCard: GiftCard
  event: GiftCardEvent
  errors: [GiftCardError!]!
}

input GiftCardAddNoteInput {
  message: String!
}

type GiftCardBulkActivate {
  count: Int!
  errors: [GiftCardError!]!
}

type GiftCardBulkDeactivate {
  count: Int!
  errors: [GiftCardError!]!
}

type GiftCardBulkDelete {
  count: Int!
  errors: [GiftCardError!]!
}

type GiftCardEvent  {
  id: String!
  date: DateTime
  type: GiftCardEventsEnum
  user: User
  app: App
  message: String
  email: String
  orderId: String
  orderNumber: String
  tag: String
  oldTag: String
  balance: GiftCardEventBalance
  expiryDate: Date
  oldExpiryDate: Date
}

type GiftCardEventBalance {
  initialBalance: Money
  currentBalance: Money!
  oldInitialBalance: Money
  oldCurrentBalance: Money
}

enum GiftCardEventsEnum {
  issued
  bought
  updated
  activated
  deactivated
  balance_reset
  expiry_date_updated
  tag_updated
  sent_to_customer
  resent
  note_added
  used_in_order
}

input GiftCardFilterInput {
  isActive: Boolean
  tag: String
  tags: [String!]!
  products: [String!]!
  usedBy: [String!]!
  currency: String
  currentBalance: PriceRangeInput
  initialBalance: PriceRangeInput
}

type GiftCardResend {
  giftCard: GiftCard
  errors: [GiftCardError!]!
}

input GiftCardResendInput {
  id: String!
  email: String
  channel: String!
}

type GiftCardSettings {
  expiryType: GiftCardSettingsExpiryTypeEnum!
  expiryPeriod: TimePeriod
}

type GiftCardSettingsError {
  field: String
  message: String
  code: GiftCardSettingsErrorCode!
}

enum GiftCardSettingsErrorCode {
  INVALID
  REQUIRED
  GRAPHQL_ERROR
}

enum GiftCardSettingsExpiryTypeEnum {
  never_expire
  expiry_period
}

type GiftCardSettingsUpdate {
  giftCardSettings: GiftCardSettings
  errors: [GiftCardSettingsError!]!
}

input GiftCardSettingsUpdateInput {
  expiryType: GiftCardSettingsExpiryTypeEnum
  expiryPeriod: TimePeriodInputType
}

enum GiftCardSortField {
  TAG
  PRODUCT
  USED_BY
  CURRENT_BALANCE
}

input GiftCardSortingInput {
  direction: OrderDirection!
  field: GiftCardSortField!
}

extend type Mutation {
  invoiceRequest(number: String, orderId: String!): InvoiceRequest
  invoiceRequestDelete(id: String!): InvoiceRequestDelete
  invoiceCreate(input: InvoiceCreateInput!, orderId: String!): InvoiceCreate
  invoiceDelete(id: String!): InvoiceDelete
  invoiceUpdate(id: String!, input: UpdateInvoiceInput!): InvoiceUpdate
  invoiceSendNotification(id: String!): InvoiceSendNotification
}

type Invoice {
  id: String!
  metadata: [MetadataItem]!
  number: String
  externalUrl: String
  privateMetadata: [MetadataItem]!
  createdAt: DateTime!
  url: String

  # status: JobStatusEnum!
  # updatedAt: DateTime!
  # message: String
}

type InvoiceRequest {
  order: Order
  errors: [InvoiceError!]!
  invoice: Invoice
}

type InvoiceRequestDelete {
  errors: [InvoiceError!]!
  invoice: Invoice
}

input InvoiceCreateInput {
  number: String!
  url: String!
}

type InvoiceCreate {
  errors: [InvoiceError!]!
  invoice: Invoice
}

type InvoiceDelete {
  errors: [InvoiceError!]!
  invoice: Invoice
}

input UpdateInvoiceInput {
  number: String
  url: String
}

type InvoiceUpdate {
  errors: [InvoiceError!]!
  invoice: Invoice
}

type InvoiceSendNotification {
  errors: [InvoiceError!]!
  invoice: Invoice
}

type InvoiceError {
  field: String
  message: String
  code: InvoiceErrorCode!
}

enum InvoiceErrorCode {
  REQUIRED
  NOT_READY
  URL_NOT_SET
  EMAIL_NOT_SET
  NUMBER_NOT_SET
  NOT_FOUND
  INVALID_STATUS
}

extend type Mutation {
  menuCreate(input: MenuCreateInput!): MenuCreate
  menuDelete(id: String!): MenuDelete
  menuBulkDelete(ids: [String!]!): MenuBulkDelete
  menuUpdate(id: String!, input: MenuInput!): MenuUpdate
  menuItemCreate(input: MenuItemCreateInput!): MenuItemCreate
  menuItemDelete(id: String!): MenuItemDelete
  menuItemBulkDelete(ids: [String!]!): MenuItemBulkDelete
  menuItemUpdate(id: String!, input: MenuItemInput!): MenuItemUpdate
  menuItemTranslate(id: String!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): MenuItemTranslate
  menuItemMove(menu: String!, moves: [MenuItemMoveInput]!): MenuItemMove
}

extend type Query {
  menu(channel: String, id: String, name: String, slug: String): Menu
  menus(channel: String, sortBy: MenuSortingInput, filter: MenuFilterInput, before: String, after: String, first: Int, last: Int): MenuCountableConnection
  menuItem(id: String!, channel: String): MenuItem
  menuItems(channel: String, sortBy: MenuItemSortingInput, filter: MenuItemFilterInput, before: String, after: String, first: Int, last: Int): MenuItemCountableConnection
}

type Menu  {
  id: String!
  name: String!
  slug: String!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  items: [MenuItem]!
}

type MenuItem  {
  id: String!
  name: String!
  menu: Menu!
  parent: MenuItem
  category: Category
  collection: Collection
  page: Page
  level: Int!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  children: [MenuItem]!
  url: String
  translation(languageCode: LanguageCodeEnum!): MenuItemTranslation
}

input MenuCreateInput {
  name: String!
  slug: String
  items: [MenuItemInput]!
}

type MenuCreate {
  errors: [MenuError!]!
  menu: Menu
}

type MenuDelete {
  errors: [MenuError!]!
  menu: Menu
}

type MenuError {
  field: String
  message: String
  code: MenuErrorCode!
}

enum MenuErrorCode {
  CANNOT_ASSIGN_NODE
  GRAPHQL_ERROR
  INVALID
  INVALID_MENU_ITEM
  NO_MENU_ITEM_PROVIDED
  NOT_FOUND
  REQUIRED
  TOO_MANY_MENU_ITEMS
  UNIQUE
}

type MenuBulkDelete {
  count: Int!
  errors: [MenuError!]!
}

input MenuInput {
  name: String
  slug: String
}

type MenuUpdate {
  errors: [MenuError!]!
  menu: Menu
}

input MenuItemCreateInput {
  name: String!
  url: String
  category: String
  collection: String
  page: String
  menu: String!
  parent: String
}

type MenuItemCreate {
  errors: [MenuError!]!
  menuItem: MenuItem
}

type MenuItemDelete {
  errors: [MenuError!]!
  menuItem: MenuItem
}

type MenuItemBulkDelete {
  count: Int!
  errors: [MenuError!]!
}

input MenuItemInput {
  name: String
  url: String
  category: String
  collection: String
  page: String
}

type MenuItemUpdate {
  errors: [MenuError!]!
  menuItem: MenuItem
}

type MenuItemTranslate {
  errors: [TranslationError!]!
  menuItem: MenuItem
}

input MenuItemMoveInput {
  itemId: String!
  parentId: String
  sortOrder: Int
}

type MenuItemMove {
  menu: Menu
  errors: [MenuError!]!
}

input MenuSortingInput {
  direction: OrderDirection!
  field: MenuSortField!
}

input MenuFilterInput {
  search: String
  slug: [String!]!
  metadata: [MetadataInput]!
}

type MenuCountableConnection {
  pageInfo: PageInfo!
  edges: [MenuCountableEdge!]!
  totalCount: Int
}

type MenuCountableEdge {
  node: Menu!
  cursor: String!
}

type MenuItemTranslation  {
  id: String!
  name: String!
  language: LanguageDisplay!
}

input MenuItemSortingInput {
  direction: OrderDirection!
  field: MenuItemsSortField!
}

input MenuItemFilterInput {
  search: String
  metadata: [MetadataInput]!
}

type MenuItemCountableConnection {
  pageInfo: PageInfo!
  edges: [MenuItemCountableEdge!]!
  totalCount: Int
}

type MenuItemCountableEdge {
  node: MenuItem!
  cursor: String!
}

enum MenuItemsSortField {
  NAME
}

enum MenuSortField {
  NAME
  ITEMS_COUNT
}

extend type Mutation {
  deleteMetadata(id: String!, keys: [String!]!): DeleteMetadata
  deletePrivateMetadata(id: String!, keys: [String!]!): DeletePrivateMetadata
  updateMetadata(id: String!, input: [MetadataInput!]!): UpdateMetadata
  updatePrivateMetadata(id: String!, input: [MetadataInput!]!): UpdatePrivateMetadata
}

type DeleteMetadata {
  errors: [MetadataError!]!
  item: ObjectWithMetadata!
}

type DeletePrivateMetadata {
  errors: [MetadataError!]!
  item: ObjectWithMetadata!
}

input MetadataInput {
  key: String!
  value: String!
}

type UpdateMetadata {
  errors: [MetadataError!]!
  item: ObjectWithMetadata!
}

type UpdatePrivateMetadata {
  errors: [MetadataError!]!
  item: ObjectWithMetadata!
}

type MetadataError {
  field: String
  message: String
  code: MetadataErrorCode!
}

enum MetadataErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
}

interface ObjectWithMetadata {
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
}

type MetadataItem {
  key: String!
  value: String!
}

extend type Mutation {
  orderSettingsUpdate(input: OrderSettingsUpdateInput!): OrderSettingsUpdate
  giftCardSettingsUpdate(input: GiftCardSettingsUpdateInput!): GiftCardSettingsUpdate
  orderAddNote(order: String!, input: OrderAddNoteInput!): OrderAddNote
  orderCancel(id: String!): OrderCancel
  orderCapture(amount: PositiveDecimal!, id: String!): OrderCapture
  orderConfirm(id: String!): OrderConfirm
  orderFulfill(input: OrderFulfillInput!, order: String): OrderFulfill
  orderFulfillmentCancel(id: String!, input: FulfillmentCancelInput): FulfillmentCancel
  orderFulfillmentApprove(allowStockToBeExceeded: Boolean, id: String!, notifyCustomer: Boolean!): FulfillmentApprove
  orderFulfillmentUpdateTracking(id: String!, input: FulfillmentUpdateTrackingInput!): FulfillmentUpdateTracking
  orderFulfillmentRefundProducts(input: OrderRefundProductsInput!, order: String!): FulfillmentRefundProducts
  orderFulfillmentReturnProducts(input: OrderReturnProductsInput!, order: String!): FulfillmentReturnProducts
  orderMarkAsPaid(id: String!, transactionReference: String): OrderMarkAsPaid
  orderRefund(amount: PositiveDecimal!, id: String!): OrderRefund
  orderUpdate(id: String!, input: OrderUpdateInput!): OrderUpdate
  orderUpdateShipping(order: String!, input: OrderUpdateShippingInput!): OrderUpdateShipping
  orderVoid(id: String!): OrderVoid
  orderBulkCancel(ids: [String!]!): OrderBulkCancel
}

extend type Query {
  orderSettings: OrderSettings
  order(id: String!): Order
  orders(sortBy: OrderSortingInput, filter: OrderFilterInput, channel: String, before: String, after: String, first: Int, last: Int): OrderCountableConnection
  draftOrders(sortBy: OrderSortingInput, filter: OrderDraftFilterInput, before: String, after: String, first: Int, last: Int): OrderCountableConnection
  ordersTotal(period: ReportingPeriod, channel: String): TaxedMoney
  orderByToken(token: String!): Order
}

type Order  {
  id: String!
  created: DateTime!
  status: OrderStatus!
  user: User
  trackingClientId: String!
  billingAddress: Address
  shippingAddress: Address
  shippingMethodName: String
  collectionPointName: String
  channel: Channel!
  shippingPrice: TaxedMoney!
  shippingTaxRate: Float!
  token: String!
  voucher: Voucher
  giftCards: [GiftCard]!
  displayGrossPrices: Boolean!
  customerNote: String!
  weight: Weight
  redirectUrl: String
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  fulfillments: [Fulfillment]!
  lines: [OrderLine]!
  actions: [OrderAction!]!
  availableShippingMethods: [ShippingMethod]!
  availableCollectionPoints: [Warehouse!]!
  invoices: [Invoice]!
  number: String
  original: String
  origin: OrderOriginEnum!
  isPaid: Boolean!
  paymentStatus: PaymentChargeStatusEnum
  paymentStatusDisplay: String!
  payments: [Payment]!
  total: TaxedMoney!
  undiscountedTotal: TaxedMoney!
  subtotal: TaxedMoney!
  statusDisplay: String
  canFinalize: Boolean! 
  totalAuthorized: Money!
  totalCaptured: Money!
  events: [OrderEvent]!
  totalBalance: Money!
  userEmail: String
  isShippingRequired: Boolean!
  deliveryMethod: DeliveryMethod
  languageCodeEnum: LanguageCodeEnum!
  discounts: [OrderDiscount!]!
}

union DeliveryMethod = Warehouse | ShippingMethod

input OrderSettingsUpdateInput {
  automaticallyConfirmAllNewOrders: Boolean
  automaticallyFulfillNonShippableGiftCard: Boolean
}

type OrderSettingsUpdate {
  orderSettings: OrderSettings
  errors: [OrderSettingsError!]!
}

input OrderAddNoteInput {
  message: String!
}

type OrderAddNote {
  order: Order
  event: OrderEvent
  errors: [OrderError!]!
}

type OrderCancel {
  order: Order
  errors: [OrderError!]!
}

type OrderCapture {
  order: Order
  errors: [OrderError!]!
}

type OrderConfirm {
  order: Order
  errors: [OrderError!]!
}

input OrderFulfillInput {
  lines: [OrderFulfillLineInput!]!
  notifyCustomer: Boolean
  allowStockToBeExceeded: Boolean
}

type OrderFulfill {
  fulfillments: [Fulfillment]!
  order: Order
  errors: [OrderError!]!
}

input FulfillmentCancelInput {
  warehouseId: String
}

type FulfillmentCancel {
  fulfillment: Fulfillment
  order: Order
  errors: [OrderError!]!
}

input FulfillmentUpdateTrackingInput {
  trackingNumber: String
  notifyCustomer: Boolean
}

type FulfillmentUpdateTracking {
  fulfillment: Fulfillment
  order: Order
  errors: [OrderError!]!
}

input OrderRefundProductsInput {
  orderLines: [OrderRefundLineInput!]!
  fulfillmentLines: [OrderRefundFulfillmentLineInput!]!
  amountToRefund: PositiveDecimal
  includeShippingCosts: Boolean
}

type FulfillmentRefundProducts {
  fulfillment: Fulfillment
  order: Order
  errors: [OrderError!]!
}

input OrderReturnProductsInput {
  orderLines: [OrderReturnLineInput!]!
  fulfillmentLines: [OrderReturnFulfillmentLineInput!]!
  amountToRefund: PositiveDecimal
  includeShippingCosts: Boolean
  refund: Boolean
}

type FulfillmentReturnProducts {
  returnFulfillment: Fulfillment
  replaceFulfillment: Fulfillment
  order: Order
  replaceOrder: Order
  errors: [OrderError!]!
}

type OrderMarkAsPaid {
  order: Order
  errors: [OrderError!]!
}

type OrderRefund {
  order: Order
  errors: [OrderError!]!
}

input OrderUpdateShippingInput {
  shippingMethod: String
}

type OrderUpdateShipping {
  order: Order
  errors: [OrderError!]!
}

type OrderVoid {
  order: Order
  errors: [OrderError!]!
}

type OrderBulkCancel {
  count: Int!
  errors: [OrderError!]!
}

type OrderSettings {
  automaticallyConfirmAllNewOrders: Boolean!
  automaticallyFulfillNonShippableGiftCard: Boolean!
}

input OrderSortingInput {
  direction: OrderDirection!
  field: OrderSortField!
}

input OrderFilterInput {
  paymentStatus: [PaymentChargeStatusEnum]!
  status: [OrderStatusFilter]!
  customer: String
  created: DateRangeInput
  search: String
  metadata: [MetadataInput]!
  channels: [String!]!
}

type OrderCountableConnection {
  pageInfo: PageInfo!
  edges: [OrderCountableEdge!]!
  totalCount: Int
}

input OrderDraftFilterInput {
  customer: String
  created: DateRangeInput
  search: String
  metadata: [MetadataInput]!
  channels: [String!]!
}

enum OrderStatus {
  draft
  unconfirmed
  unfulfilled
  partially_fulfilled
  partially_returned
  returned
  fulfilled
  canceled
}

type Fulfillment  {
  id: String!
  fulfillmentOrder: Int!
  status: FulfillmentStatus!
  trackingNumber: String!
  created: DateTime!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  lines: [FulfillmentLine]!
  statusDisplay: String
  warehouse: Warehouse
}

enum OrderAction {
  CAPTURE
  MARK_AS_PAID
  REFUND
  VOID
}

enum OrderOriginEnum {
  CHECKOUT
  DRAFT
  REISSUE
}

type OrderSettingsError {
  field: String
  message: String
  code: OrderSettingsErrorCode!
}

enum OrderSettingsErrorCode {
  INVALID
}

type OrderEvent  {
  id: String!
  date: DateTime
  type: OrderEventsEnum
  user: User
  message: String
  email: String
  emailType: OrderEventsEmailsEnum
  amount: Float
  paymentId: String
  paymentGateway: String
  quantity: Int
  composedId: String
  orderNumber: String
  invoiceNumber: String
  oversoldItems: [String!]!
  lines: [OrderEventOrderLineObject]!
  fulfilledItems: [FulfillmentLine]!
  warehouse: Warehouse
  transactionReference: String
  shippingCostsIncluded: Boolean
  relatedOrder: Order
  discount: OrderEventDiscountObject
}

type OrderError {
  field: String
  message: String
  code: OrderErrorCode!
  warehouse: String
  orderLine: String
  variants: [String!]!
  addressType: AddressTypeEnum
}

enum OrderErrorCode {
  BILLING_ADDRESS_NOT_SET
  CANNOT_CANCEL_FULFILLMENT
  CANNOT_CANCEL_ORDER
  CANNOT_DELETE
  CANNOT_DISCOUNT
  CANNOT_REFUND
  CANNOT_FULFILL_UNPAID_ORDER
  CAPTURE_INACTIVE_PAYMENT
  GIFT_CARD_LINE
  NOT_EDITABLE
  FULFILL_ORDER_LINE
  GRAPHQL_ERROR
  INVALID
  PRODUCT_NOT_PUBLISHED
  PRODUCT_UNAVAILABLE_FOR_PURCHASE
  NOT_FOUND
  ORDER_NO_SHIPPING_ADDRESS
  PAYMENT_ERROR
  PAYMENT_MISSING
  REQUIRED
  SHIPPING_METHOD_NOT_APPLICABLE
  SHIPPING_METHOD_REQUIRED
  TAX_ERROR
  UNIQUE
  VOID_INACTIVE_PAYMENT
  ZERO_QUANTITY
  INVALID_QUANTITY
  INSUFFICIENT_STOCK
  DUPLICATED_INPUT_ITEM
  NOT_AVAILABLE_IN_CHANNEL
  CHANNEL_INACTIVE
}

input OrderFulfillLineInput {
  orderLineId: String
  stocks: [OrderFulfillStockInput!]!
}

input OrderFulfillStockInput {
  quantity: Int!
  warehouse: String!
}

input OrderRefundLineInput {
  orderLineId: String!
  quantity: Int!
}

input OrderRefundFulfillmentLineInput {
  fulfillmentLineId: String!
  quantity: Int!
}

input OrderReturnLineInput {
  orderLineId: String!
  quantity: Int!
  replace: Boolean
}

input OrderReturnFulfillmentLineInput {
  fulfillmentLineId: String!
  quantity: Int!
  replace: Boolean
}

enum OrderDirection {
  ASC
  DESC
}

enum OrderSortField {
  NUMBER
  CREATION_DATE
  CUSTOMER
  PAYMENT
  FULFILLMENT_STATUS
}

enum OrderStatusFilter {
  READY_TO_FULFILL
  READY_TO_CAPTURE
  UNFULFILLED
  UNCONFIRMED
  PARTIALLY_FULFILLED
  FULFILLED
  CANCELED
}

type OrderCountableEdge {
  node: Order!
  cursor: String!
}

enum OrderEventsEnum {
  DRAFT_CREATED
  DRAFT_CREATED_FROM_REPLACE
  ADDED_PRODUCTS
  REMOVED_PRODUCTS
  PLACED
  PLACED_FROM_DRAFT
  OVERSOLD_ITEMS
  CANCELED
  ORDER_MARKED_AS_PAID
  ORDER_FULLY_PAID
  ORDER_REPLACEMENT_CREATED
  ORDER_DISCOUNT_ADDED
  ORDER_DISCOUNT_AUTOMATICALLY_UPDATED
  ORDER_DISCOUNT_UPDATED
  ORDER_DISCOUNT_DELETED
  ORDER_LINE_DISCOUNT_UPDATED
  ORDER_LINE_DISCOUNT_REMOVED
  UPDATED_ADDRESS
  EMAIL_SENT
  CONFIRMED
  PAYMENT_AUTHORIZED
  PAYMENT_CAPTURED
  EXTERNAL_SERVICE_NOTIFICATION
  PAYMENT_REFUNDED
  PAYMENT_VOIDED
  PAYMENT_FAILED
  INVOICE_REQUESTED
  INVOICE_GENERATED
  INVOICE_UPDATED
  INVOICE_SENT
  FULFILLMENT_CANCELED
  FULFILLMENT_RESTOCKED_ITEMS
  FULFILLMENT_FULFILLED_ITEMS
  FULFILLMENT_REFUNDED
  FULFILLMENT_RETURNED
  FULFILLMENT_REPLACED
  FULFILLMENT_AWAITS_APPROVAL
  TRACKING_UPDATED
  NOTE_ADDED
  OTHER
}

enum OrderEventsEmailsEnum {
  PAYMENT_CONFIRMATION
  CONFIRMED
  SHIPPING_CONFIRMATION
  TRACKING_UPDATED
  ORDER_CONFIRMATION
  ORDER_CANCEL
  ORDER_REFUND
  FULFILLMENT_CONFIRMATION
  DIGITAL_LINKS
}

type OrderEventOrderLineObject {
  quantity: Int
  orderLine: OrderLine
  itemName: String
  discount: OrderEventDiscountObject
}

type OrderEventDiscountObject {
  valueType: DiscountValueTypeEnum!
  value: PositiveDecimal!
  reason: String
  amount: Money
  oldValueType: DiscountValueTypeEnum
  oldValue: PositiveDecimal
  oldAmount: Money
}

type FulfillmentLine  {
  id: String!
  quantity: Int!
  orderLine: OrderLine
}

enum FulfillmentStatus {
  fulfilled
  refunded
  returned
  replaced
  refunded_and_returned
  canceled
  waiting_for_approval
}

type OrderDiscount  {
  id: String!
  type: OrderDiscountType!
  valueType: DiscountValueTypeEnum!
  value: PositiveDecimal!
  name: String
  translatedName: String
  reason: String
  amount: Money!
}

enum OrderDiscountType {
  voucher
  manual
}

type OrderUpdate {
  errors: [OrderError!]!
  order: Order
}

input OrderUpdateInput {
  billingAddress: AddressInput
  userEmail: String
  shippingAddress: AddressInput
}

type FulfillmentApprove {
  fulfillment: Fulfillment
  order: Order
  # orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
  errors: [OrderError!]!
}

extend type Mutation {
  orderLinesCreate(id: String!, input: [OrderLineCreateInput]!): OrderLinesCreate
  orderLineDelete(id: String!): OrderLineDelete
  orderLineUpdate(id: String!, input: OrderLineInput!): OrderLineUpdate
  orderDiscountAdd(input: OrderDiscountCommonInput!, orderId: String!): OrderDiscountAdd
  orderDiscountUpdate(discountId: String!, input: OrderDiscountCommonInput!): OrderDiscountUpdate
  orderDiscountDelete(discountId: String!): OrderDiscountDelete
  orderLineDiscountUpdate(input: OrderDiscountCommonInput!, orderLineId: String!): OrderLineDiscountUpdate
  orderLineDiscountRemove(orderLineId: String!): OrderLineDiscountRemove
}

type OrderLine  {
  id: String!
  productName: String!
  variantName: String!
  productSku: String
  ProductVariantId: String
  isShippingRequired: Boolean!
  quantity: Int!
  quantityFulfilled: Int!
  unitDiscountReason: String
  taxRate: Float!
  digitalContentUrl: DigitalContentUrl
  thumbnail(size: Int): Image
  unitPrice: TaxedMoney!
  undiscountedUnitPrice: TaxedMoney!
  unitDiscount: Money!
  unitDiscountValue: PositiveDecimal!
  totalPrice: TaxedMoney!
  variant: ProductVariant
  translatedProductName: String!
  translatedVariantName: String!
  allocations: [Allocation!]!
  quantityToFulfill: Int!
  unitDiscountType: DiscountValueTypeEnum
}

input OrderLineCreateInput {
  quantity: Int!
  variantId: String!
}

type OrderLinesCreate {
  order: Order
  orderLines: [OrderLine!]!
  errors: [OrderError!]!
}

type OrderLineDelete {
  order: Order
  orderLine: OrderLine
  errors: [OrderError!]!
}

input OrderLineInput {
  quantity: Int!
}

type OrderLineUpdate {
  order: Order
  errors: [OrderError!]!
  orderLine: OrderLine
}

input OrderDiscountCommonInput {
  valueType: DiscountValueTypeEnum!
  value: PositiveDecimal!
  reason: String
}

type OrderDiscountAdd {
  order: Order
  errors: [OrderError!]!
}

type OrderDiscountUpdate {
  order: Order
  errors: [OrderError!]!
}

type OrderDiscountDelete {
  order: Order
  errors: [OrderError!]!
}

type OrderLineDiscountUpdate {
  orderLine: OrderLine
  order: Order
  errors: [OrderError!]!
}

type OrderLineDiscountRemove {
  orderLine: OrderLine
  order: Order
  errors: [OrderError!]!
}

type Allocation  {
  id: String!
  quantity: Int!
  warehouse: Warehouse!
}

extend type Mutation {
  pageCreate(input: PageCreateInput!): PageCreate
  pageDelete(id: String!): PageDelete
  pageBulkDelete(ids: [String!]!): PageBulkDelete
  pageBulkPublish(ids: [String!]!, isPublished: Boolean!): PageBulkPublish
  pageUpdate(id: String!, input: PageInput!): PageUpdate
  pageTranslate(id: String!, input: PageTranslationInput!, languageCode: LanguageCodeEnum!): PageTranslate
  pageAttributeAssign(attributeIds: [String!]!, pageTypeId: String!): PageAttributeAssign
  pageAttributeUnassign(attributeIds: [String!]!, pageTypeId: String!): PageAttributeUnassign
  pageReorderAttributeValues(attributeId: String!, moves: [ReorderInput]!, pageId: String!): PageReorderAttributeValues
}

extend type Query {
  page(id: String, slug: String): Page
  pages(sortBy: PageSortingInput, filter: PageFilterInput, before: String, after: String, first: Int, last: Int): PageCountableConnection
}

type Page  {
  id: String!
  seoTitle: String
  seoDescription: String
  title: String!
  content: JSONString!
  publicationDate: Date
  isPublished: Boolean!
  slug: String!
  pageType: PageType!
  created: DateTime!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  translation(languageCode: LanguageCodeEnum!): PageTranslation
  attributes: [SelectedAttribute!]!
}

input PageCreateInput {
  slug: String
  title: String
  content: JSONString!
  attributes: [AttributeValueInput!]!
  isPublished: Boolean
  publicationDate: String
  seo: SeoInput
  pageType: String!
}

type PageCreate {
  errors: [PageError!]!
  page: Page
}

type PageDelete {
  errors: [PageError!]!
  page: Page
}

type PageBulkDelete {
  count: Int!
  errors: [PageError!]!
}

type PageBulkPublish {
  count: Int!
  errors: [PageError!]!
}

input PageInput {
  slug: String
  title: String
  content: JSONString!
  attributes: [AttributeValueInput!]!
  isPublished: Boolean
  publicationDate: String
  seo: SeoInput
}

type PageUpdate {
  errors: [PageError!]!
  page: Page
}

input PageTranslationInput {
  seoTitle: String
  seoDescription: String
  title: String
  content: JSONString!
}

type PageTranslate {
  errors: [TranslationError!]!
  page: PageTranslatableContent
}

type PageAttributeAssign {
  pageType: PageType
  errors: [PageError!]!
}

type PageAttributeUnassign {
  pageType: PageType
  errors: [PageError!]!
}

type PageReorderAttributeValues {
  page: Page
  errors: [PageError!]!
}

input PageSortingInput {
  direction: OrderDirection!
  field: PageSortField!
}

input PageFilterInput {
  search: String
  metadata: [MetadataInput]!
  pageTypes: [String!]!
  ids: [String!]!
}

type PageCountableConnection {
  pageInfo: PageInfo!
  edges: [PageCountableEdge!]!
  totalCount: Int
}

type PageCountableEdge {
  node: Page!
  cursor: String!
}

type PageError {
  field: String
  message: String
  code: PageErrorCode!
  attributes: [String!]!
  values: [String!]!
}

enum PageErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
  DUPLICATED_INPUT_ITEM
  ATTRIBUTE_ALREADY_ASSIGNED
}

enum PageSortField {
  TITLE
  SLUG
  VISIBILITY
  CREATION_DATE
  PUBLICATION_DATE
}

type PageTranslation  {
  id: String!
  seoTitle: String
  seoDescription: String
  title: String
  content: JSONString!
  language: LanguageDisplay!
}

extend type Mutation {
  pageTypeCreate(input: PageTypeCreateInput!): PageTypeCreate
  pageTypeUpdate(id: String, input: PageTypeUpdateInput!): PageTypeUpdate
  pageTypeDelete(id: String!): PageTypeDelete
  pageTypeBulkDelete(ids: [String!]!): PageTypeBulkDelete
  pageTypeReorderAttributes(moves: [ReorderInput!]!, pageTypeId: String!): PageTypeReorderAttributes
}

extend type Query {
  pageType(id: String!): PageType
  pageTypes(sortBy: PageTypeSortingInput, filter: PageTypeFilterInput, before: String, after: String, first: Int, last: Int): PageTypeCountableConnection
}

type PageType  {
  id: String!
  name: String!
  slug: String!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  attributes: [Attribute]!
  availableAttributes(filter: AttributeFilterInput, before: String, after: String, first: Int, last: Int): AttributeCountableConnection
  hasPages: Boolean
}

input PageTypeCreateInput {
  name: String
  slug: String
  addAttributes: [String!]!
}

type PageTypeCreate {
  errors: [PageError!]!
  pageType: PageType
}

input PageTypeUpdateInput {
  name: String
  slug: String
  addAttributes: [String!]!
  removeAttributes: [String!]!
}

type PageTypeUpdate {
  errors: [PageError!]!
  pageType: PageType
}

type PageTypeDelete {
  errors: [PageError!]!
  pageType: PageType
}

type PageTypeBulkDelete {
  count: Int!
  errors: [PageError!]!
}

type PageTypeReorderAttributes {
  pageType: PageType
  errors: [PageError!]!
}

input PageTypeSortingInput {
  direction: OrderDirection!
  field: PageTypeSortField!
}

input PageTypeFilterInput {
  search: String
}

type PageTypeCountableConnection {
  pageInfo: PageInfo!
  edges: [PageTypeCountableEdge!]!
  totalCount: Int
}

enum PageTypeSortField {
  NAME
  SLUG
}

type PageTypeCountableEdge {
  node: PageType!
  cursor: String!
}

extend type Mutation {
  paymentCapture(amount: PositiveDecimal, paymentId: String!): PaymentCapture
  paymentRefund(amount: PositiveDecimal, paymentId: String!): PaymentRefund
  paymentVoid(paymentId: String!): PaymentVoid
  paymentInitialize(channel: String, gateway: String!, paymentData: JSONString!): PaymentInitialize
}

extend type Query {
  payment(id: String!): Payment
  payments(filter: PaymentFilterInput, before: String, after: String, first: Int, last: Int): PaymentCountableConnection
}

type Payment  {
  id: String!
  gateway: String!
  isActive: Boolean!
  created: DateTime!
  modified: DateTime!
  token: String!
  checkout: Checkout
  order: Order
  paymentMethodType: String!
  customerIpAddress: String
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  chargeStatus: PaymentChargeStatusEnum!
  actions: [OrderAction!]!
  total: Money
  capturedAmount: Money
  transactions: [Transaction]!
  availableCaptureAmount: Money
  availableRefundAmount: Money
  creditCard: CreditCard
}

type CreditCard {
  brand: String!
  firstDigits: String
  lastDigits: String!
  expMonth: Int
  expYear: Int
}

type PaymentCapture {
  payment: Payment
  errors: [PaymentError!]!
}

type PaymentRefund {
  payment: Payment
  errors: [PaymentError!]!
}

type PaymentVoid {
  payment: Payment
  errors: [PaymentError!]!
}

type PaymentInitialize {
  initializedPayment: PaymentInitialized
  errors: [PaymentError!]!
}

input PaymentFilterInput {
  checkouts: [String!]!
}

type PaymentCountableConnection {
  pageInfo: PageInfo!
  edges: [PaymentCountableEdge!]!
  totalCount: Int
}

enum PaymentChargeStatusEnum {
  not_charged
  pending
  partially_charged
  fully_charged
  partially_refunded
  partially_refunded
  refused
  cancelled
}

type PaymentError {
  field: String
  message: String
  code: PaymentErrorCode!
}

enum PaymentErrorCode {
  BILLING_ADDRESS_NOT_SET
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
  PARTIAL_PAYMENT_NOT_ALLOWED
  SHIPPING_ADDRESS_NOT_SET
  INVALID_SHIPPING_METHOD
  SHIPPING_METHOD_NOT_SET
  PAYMENT_ERROR
  NOT_SUPPORTED_GATEWAY
  CHANNEL_INACTIVE
}

type PaymentInitialized {
  gateway: String!
  name: String!
  data: JSONString!
}

type PaymentCountableEdge {
  node: Payment!
  cursor: String!
}

type Transaction  {
  id: String!
  created: DateTime!
  payment: Payment!
  token: String!
  kind: TransactionKind!
  isSuccess: Boolean!
  error: String
  gatewayResponse: JSONString!
  amount: Money
}

enum TransactionKind {
  external
  auth
  pending
  action_to_confirm
  refund
  refund_ongoing
  capture
  void
  confirm
  cancel
}

extend type Mutation {
  permissionGroupCreate(input: PermissionGroupCreateInput!): PermissionGroupCreate
  permissionGroupUpdate(id: String!, input: PermissionGroupUpdateInput!): PermissionGroupUpdate
  permissionGroupDelete(id: String!): PermissionGroupDelete
}

extend type Query {
  permissionGroups(filter: PermissionGroupFilterInput, sortBy: PermissionGroupSortingInput, before: String, after: String, first: Int, last: Int): GroupCountableConnection
  permissionGroup(id: String!): Group
}

type Permission {
  code: PermissionEnum!
  name: String!
}

enum PermissionEnum {
  MANAGE_USERS
  MANAGE_STAFF
  IMPERSONATE_USER
  MANAGE_APPS
  MANAGE_CHANNELS
  MANAGE_DISCOUNTS
  MANAGE_PLUGINS
  MANAGE_GIFT_CARD
  MANAGE_MENUS
  MANAGE_ORDERS
  MANAGE_PAGES
  MANAGE_PAGE_TYPES_AND_ATTRIBUTES
  HANDLE_PAYMENTS
  MANAGE_PRODUCTS
  MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES
  MANAGE_SHIPPING
  MANAGE_SETTINGS
  MANAGE_TRANSLATIONS
  MANAGE_CHECKOUTS
}

input PermissionGroupCreateInput {
  addPermissions: [PermissionEnum!]!
  addUsers: [String!]!
  name: String!
}

type PermissionGroupCreate {
  errors: [PermissionGroupError!]!
  group: Group
}

input PermissionGroupUpdateInput {
  addPermissions: [PermissionEnum!]!
  addUsers: [String!]!
  name: String
  removePermissions: [PermissionEnum!]!
  removeUsers: [String!]!
}

type PermissionGroupUpdate {
  errors: [PermissionGroupError!]!
  group: Group
}

type PermissionGroupDelete {
  errors: [PermissionGroupError!]!
  group: Group
}

input PermissionGroupFilterInput {
  search: String
}

input PermissionGroupSortingInput {
  direction: OrderDirection!
  field: PermissionGroupSortField!
}

type GroupCountableConnection {
  pageInfo: PageInfo!
  edges: [GroupCountableEdge!]!
  totalCount: Int
}

type Group  {
  id: String!
  name: String!
  permissions: [Permission]!
  users: [User]!
  userCanManage: Boolean!
}

type PermissionGroupError {
  field: String
  message: String
  code: PermissionGroupErrorCode!
  permissions: [PermissionEnum!]!
  users: [String!]!
}

enum PermissionGroupErrorCode {
  ASSIGN_NON_STAFF_MEMBER
  DUPLICATED_INPUT_ITEM
  CANNOT_REMOVE_FROM_LAST_GROUP
  LEFT_NOT_MANAGEABLE_PERMISSION
  OUT_OF_SCOPE_PERMISSION
  OUT_OF_SCOPE_USER
  REQUIRED
  UNIQUE
}

enum PermissionGroupSortField {
  NAME
}

type GroupCountableEdge {
  node: Group!
  cursor: String!
}

extend type Mutation {
  pluginUpdate(channelId: String, id: String!, input: PluginUpdateInput!): PluginUpdate
}

extend type Query {
  plugin(id: String!): Plugin
  plugins(filter: PluginFilterInput, sortBy: PluginSortingInput, before: String, after: String, first: Int, last: Int): PluginCountableConnection
}

type Plugin {
  id: String!
  name: String!
  description: String!
  globalConfiguration: PluginConfiguration
  channelConfigurations: [PluginConfiguration!]!
}

input PluginUpdateInput {
  active: Boolean
  configuration: [ConfigurationItemInput]!
}

type PluginUpdate {
  plugin: Plugin
  errors: [PluginError!]!
}

type PluginCountableEdge {
  node: Plugin!
  cursor: String!
}

type PluginError {
  field: String
  message: String
  code: PluginErrorCode!
}

enum PluginErrorCode {
  GRAPHQL_ERROR
  INVALID
  PLUGIN_MISCONFIGURED
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input PluginFilterInput {
  statusInChannels: PluginStatusInChannelsInput
  search: String
  type: PluginConfigurationType
}

enum PluginSortField {
  NAME
  IS_ACTIVE
}

input PluginSortingInput {
  direction: OrderDirection!
  field: PluginSortField!
}

input PluginStatusInChannelsInput {
  active: Boolean!
  channels: [String!]!
}

type PluginCountableConnection {
  pageInfo: PageInfo!
  edges: [PluginCountableEdge!]!
  totalCount: Int
}

type PluginConfiguration {
  active: Boolean!
  channel: Channel
  configuration: [ConfigurationItem]!
}

enum PluginConfigurationType {
  PER_CHANNEL
  GLOBAL
}

extend type Mutation {
  productAttributeAssign(operations: [ProductAttributeAssignInput]!, productTypeId: String!): ProductAttributeAssign
  productAttributeUnassign(attributeIds: [String!]!, productTypeId: String!): ProductAttributeUnassign
  productCreate(input: ProductCreateInput!): ProductCreate
  productDelete(id: String!): ProductDelete
  productBulkDelete(ids: [String!]!): ProductBulkDelete
  productUpdate(id: String!, input: ProductInput!): ProductUpdate
  productTranslate(id: String!, input: TranslationInput!, languageCode: LanguageCodeEnum!): ProductTranslate
  productChannelListingUpdate(id: String!, input: ProductChannelListingUpdateInput!): ProductChannelListingUpdate
  productReorderAttributeValues(attributeId: String!, moves: [ReorderInput]!, productId: String!): ProductReorderAttributeValues
}

extend type Query {
  product(id: String, slug: String, channel: String): Product
  products(filter: ProductFilterInput, sortBy: ProductOrder, channel: String, before: String, after: String, first: Int, last: Int): ProductCountableConnection
}

input ProductChannelListingUpdateInput {
  updateChannels: [ProductChannelListingAddInput!]!
  removeChannels: [String!]!
}

type ProductChannelListingUpdate {
  product: Product
  errors: [ProductChannelListingError!]!
}

type ProductReorderAttributeValues {
  product: Product
  errors: [ProductError!]!
}

input ProductChannelListingAddInput {
  channelId: String!
  isPublished: Boolean
  publicationDate: Date
  visibleInListings: Boolean
  isAvailableForPurchase: Boolean
  availableForPurchaseDate: Date
  addVariants: [String!]!
  removeVariants: [String!]!
}

type Product  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String!
  description: JSONString!
  productType: ProductType!
  slug: String!
  category: Category
  updatedAt: DateTime
  chargeTaxes: Boolean!
  weight: Weight
  defaultVariant: ProductVariant
  rating: Float
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  channel: String
  thumbnail(size: Int): Image
  pricing(address: AddressInput): ProductPricingInfo
  isAvailable(address: AddressInput): Boolean
  taxType: TaxType
  attributes: [SelectedAttribute!]!
  channelListings: [ProductChannelListing!]!
  mediaById(id: String!): ProductMedia
  variants: [ProductVariant]!
  media: [ProductMedia!]!
  collections: [Collection]!
  translation(languageCode: LanguageCodeEnum!): ProductTranslation
  availableForPurchase: Date
  isAvailableForPurchase: Boolean
}

type ProductPricingInfo {
  onSale: Boolean
  discount: TaxedMoney
  discountLocalCurrency: TaxedMoney
  priceRange: TaxedMoneyRange
  priceRangeUndiscounted: TaxedMoneyRange
  priceRangeLocalCurrency: TaxedMoneyRange
}

type ProductChannelListing  {
  id: String!
  publicationDate: Date
  isPublished: Boolean!
  channel: Channel!
  visibleInListings: Boolean!
  availableForPurchase: Date
  discountedPrice: Money
  purchaseCost: MoneyRange
  margin: Margin
  isAvailableForPurchase: Boolean
  pricing(address: AddressInput): ProductPricingInfo
}

type ProductTranslation  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String
  description: JSONString!
  language: LanguageDisplay!
}

type Margin {
  start: Int
  stop: Int
}

input ProductAttributeAssignInput {
  id: String!
  type: ProductAttributeType!
}

type ProductAttributeAssign {
  productType: ProductType
  errors: [ProductError!]!
}

type ProductAttributeUnassign {
  productType: ProductType
  errors: [ProductError!]!
}

input ProductCreateInput {
  attributes: [AttributeValueInput!]!
  category: String
  chargeTaxes: Boolean
  collections: [String!]!
  description: JSONString!
  name: String
  slug: String
  taxCode: String
  seo: SeoInput
  weight: WeightScalar
  rating: Float
  productType: String!
}

type ProductCreate {
  errors: [ProductError!]!
  product: Product
}

type ProductDelete {
  errors: [ProductError!]!
  product: Product
}

type ProductBulkDelete {
  count: Int!
  errors: [ProductError!]!
}

input ProductInput {
  attributes: [AttributeValueInput!]!
  category: String
  chargeTaxes: Boolean
  collections: [String!]!
  description: JSONString!
  name: String
  slug: String
  taxCode: String
  seo: SeoInput
  weight: WeightScalar
  rating: Float
}

type ProductUpdate {
  errors: [ProductError!]!
  product: Product
}

input TranslationInput {
  seoTitle: String
  seoDescription: String
  name: String
  description: JSONString!
}

type ProductTranslate {
  errors: [TranslationError!]!
  product: Product
}

input ProductFilterInput {
  isPublished: Boolean
  collections: [String!]!
  categories: [String!]!
  hasCategory: Boolean
  attributes: [AttributeInput]!
  stockAvailability: StockAvailability
  stocks: ProductStockFilterInput
  search: String
  metadata: [MetadataInput]!
  price: PriceRangeInput
  minimalPrice: PriceRangeInput
  productTypes: [String!]!
  giftCard: Boolean
  ids: [String!]!
  hasPreorderedVariants: Boolean
  channel: String
}

input ProductOrder {
  direction: OrderDirection!
  channel: String
  attributeId: String
  field: ProductOrderField
}

type ProductCountableConnection {
  pageInfo: PageInfo!
  edges: [ProductCountableEdge!]!
  totalCount: Int
}

enum ProductAttributeType {
  PRODUCT
  VARIANT
}

type ProductError {
  field: String
  message: String
  code: ProductErrorCode!
  attributes: [String!]!
  values: [String!]!
}

enum ProductErrorCode {
  ALREADY_EXISTS
  ATTRIBUTE_ALREADY_ASSIGNED
  ATTRIBUTE_CANNOT_BE_ASSIGNED
  ATTRIBUTE_VARIANTS_DISABLED
  DUPLICATED_INPUT_ITEM
  GRAPHQL_ERROR
  INVALID
  PRODUCT_WITHOUT_CATEGORY
  NOT_PRODUCTS_IMAGE
  NOT_PRODUCTS_VARIANT
  NOT_FOUND
  REQUIRED
  UNIQUE
  VARIANT_NO_DIGITAL_CONTENT
  CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT
  PRODUCT_NOT_ASSIGNED_TO_CHANNEL
  UNSUPPORTED_MEDIA_PROVIDER
}

input SeoInput {
  title: String
  description: String
}

input ProductStockFilterInput {
  warehouseIds: [String!]!
  quantity: IntRangeInput
}

input PriceInput {
  currency: String!
  amount: PositiveDecimal!
}

input PriceRangeInput {
  gte: Float
  lte: Float
}

enum ProductOrderField {
  NAME
  RANK
  PRICE
  MINIMAL_PRICE
  DATE
  TYPE
  PUBLISHED
  PUBLICATION_DATE
  COLLECTION
  RATING
}

type ProductCountableEdge {
  node: Product!
  cursor: String!
}

enum ProductMediaType {
  image
  video
}

enum StockAvailability {
  IN_STOCK
  OUT_OF_STOCK
}

extend type Mutation {
  productMediaCreate(input: ProductMediaCreateInput!): ProductMediaCreate
  productMediaDelete(id: String!): ProductMediaDelete
  productMediaBulkDelete(ids: [String!]!): ProductMediaBulkDelete
  productMediaReorder(mediaIds: [String!]!, productId: String!): ProductMediaReorder
  productMediaUpdate(id: String!, input: ProductMediaUpdateInput!): ProductMediaUpdate
}

input ProductMediaCreateInput {
  alt: String
  image: Upload
  product: String!
  mediaUrl: String
}

type ProductMedia  {
  id: String!
  sortOrder: Int
  alt: String!
  type: ProductMediaType!
  oembedData: JSONString!
  url(size: Int): String!
}

type ProductMediaCreate {
  product: Product
  media: ProductMedia
  errors: [ProductError!]!
}

type ProductMediaDelete {
  product: Product
  media: ProductMedia
  errors: [ProductError!]!
}

type ProductMediaBulkDelete {
  count: Int!
  errors: [ProductError!]!
}

type ProductMediaReorder {
  product: Product
  media: [ProductMedia!]!
  errors: [ProductError!]!
}

input ProductMediaUpdateInput {
  alt: String
}

type ProductMediaUpdate {
  product: Product
  media: ProductMedia
  errors: [ProductError!]!
}

extend type Mutation {
  productTypeCreate(input: ProductTypeInput!): ProductTypeCreate
  productTypeDelete(id: String!): ProductTypeDelete
  productTypeBulkDelete(ids: [String!]!): ProductTypeBulkDelete
  productTypeUpdate(id: String!, input: ProductTypeInput!): ProductTypeUpdate
  productTypeReorderAttributes(moves: [ReorderInput]!, productTypeId: String!, type: ProductAttributeType!): ProductTypeReorderAttributes
}

extend type Query {
  productType(id: String!): ProductType
  productTypes(filter: ProductTypeFilterInput, sortBy: ProductTypeSortingInput, before: String, after: String, first: Int, last: Int): ProductTypeCountableConnection
}

type ProductType  {
  id: String!
  name: String!
  slug: String!
  hasVariants: Boolean!
  isShippingRequired: Boolean!
  isDigital: Boolean!
  weight: Weight
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  kind: ProductTypeKindEnum!
  taxType: TaxType
  variantAttributes(variantSelection: VariantAttributeScope): [Attribute]!
  productAttributes: [Attribute]!
  availableAttributes(filter: AttributeFilterInput, before: String, after: String, first: Int, last: Int): AttributeCountableConnection
}

input ProductTypeInput {
  name: String
  slug: String
  kind: ProductTypeKindEnum
  hasVariants: Boolean
  productAttributes: [String!]!
  variantAttributes: [String!]!
  isShippingRequired: Boolean
  isDigital: Boolean
  weight: WeightScalar
  taxCode: String
}

enum ProductTypeKindEnum {
  normal
  gift_card
}

type ProductTypeCreate {
  errors: [ProductError!]!
  productType: ProductType
}

type ProductTypeDelete {
  errors: [ProductError!]!
  productType: ProductType
}

type ProductTypeBulkDelete {
  count: Int!
  errors: [ProductError!]!
}

type ProductTypeUpdate {
  errors: [ProductError!]!
  productType: ProductType
}

input ReorderInput {
  id: String!
  sortOrder: Int
}

type ProductTypeReorderAttributes {
  productType: ProductType
  errors: [ProductError!]!
}

enum ProductTypeEnum {
  DIGITAL
  SHIPPABLE
}

input ProductTypeFilterInput {
  search: String
  configurable: ProductTypeConfigurable
  productType: ProductTypeEnum
  metadata: [MetadataInput]!
  kind: ProductTypeKindEnum
  ids: [String!]!
}

enum ProductTypeSortField {
  NAME
  DIGITAL
  SHIPPING_REQUIRED
}

input ProductTypeSortingInput {
  direction: OrderDirection!
  field: ProductTypeSortField!
}

type ProductTypeCountableConnection {
  pageInfo: PageInfo!
  edges: [ProductTypeCountableEdge!]!
  totalCount: Int
}

type ProductTypeCountableEdge {
  node: ProductType!
  cursor: String!
}

enum ProductTypeConfigurable {
  CONFIGURABLE
  SIMPLE
}

extend type Mutation {
  productVariantReorder(moves: [ReorderInput]!, productId: String!): ProductVariantReorder
  productVariantCreate(input: ProductVariantCreateInput!): ProductVariantCreate
  productVariantDelete(id: String!): ProductVariantDelete
  productVariantBulkCreate(product: String!, variants: [ProductVariantBulkCreateInput]!): ProductVariantBulkCreate
  productVariantBulkDelete(ids: [String!]!): ProductVariantBulkDelete
  productVariantStocksCreate(stocks: [StockInput!]!, variantId: String!): ProductVariantStocksCreate
  productVariantStocksDelete(variantId: String!, warehouseIds: [String!]!): ProductVariantStocksDelete
  productVariantStocksUpdate(stocks: [StockInput!]!, variantId: String!): ProductVariantStocksUpdate
  productVariantUpdate(id: String!, input: ProductVariantInput!): ProductVariantUpdate
  productVariantSetDefault(productId: String!, variantId: String!): ProductVariantSetDefault
  productVariantTranslate(id: String!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): ProductVariantTranslate
  productVariantChannelListingUpdate(id: String!, input: [ProductVariantChannelListingAddInput!]!): ProductVariantChannelListingUpdate
  productVariantReorderAttributeValues(attributeId: String!, moves: [ReorderInput]!, variantId: String!): ProductVariantReorderAttributeValues
}

extend type Query {
  productVariant(id: String, sku: String, channel: String): ProductVariant
  productVariants(ids: [String!]!, channel: String, filter: ProductVariantFilterInput, before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection
}

type ProductVariant  {
  id: String!
  name: String!
  sku: String
  product: Product
  trackInventory: Boolean!
  weight: Weight
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  channel: String
  channelListings: [ProductVariantChannelListing]!
  pricing(address: AddressInput): VariantPricingInfo
  attributes(variantSelection: VariantAttributeScope): [SelectedAttribute!]!
  margin: Int
  quantityOrdered: Int
  revenue(period: ReportingPeriod!): TaxedMoney
  media: [ProductMedia]!
  translation(languageCode: LanguageCodeEnum!): ProductVariantTranslation
  digitalContent: DigitalContent
  stocks(address: AddressInput, countryCode: CountryCode): [Stock]!
  quantityAvailable(address: AddressInput, countryCode: CountryCode): Int!
  preorder: PreorderData
}

type PreorderData {
  globalThreshold: Int
  globalSoldUnits: Int!
  endDate: DateTime
}

type ProductVariantReorder {
  product: Product
  errors: [ProductError!]!
}

input ProductVariantCreateInput {
  attributes: [AttributeValueInput!]!
  sku: String
  trackInventory: Boolean
  weight: WeightScalar
  product: String!
  stocks: [StockInput!]!
}

type ProductVariantCreate {
  errors: [ProductError!]!
  productVariant: ProductVariant
}

type ProductVariantDelete {
  errors: [ProductError!]!
  productVariant: ProductVariant
}

input ProductVariantBulkCreateInput {
  attributes: [BulkAttributeValueInput!]!
  sku: String
  trackInventory: Boolean
  weight: WeightScalar
  stocks: [StockInput!]!
  channelListings: [ProductVariantChannelListingAddInput!]!
}

type ProductVariantBulkDelete {
  count: Int!
  errors: [ProductError!]!
}

type ProductVariantStocksCreate {
  productVariant: ProductVariant
  errors: [BulkStockError!]!
}

input StockInput {
  warehouse: String!
  quantity: Int!
}

type ProductVariantStocksDelete {
  productVariant: ProductVariant
  errors: [StockError!]!
}

type StockError {
  field: String
  message: String
  code: StockErrorCode!
}

enum StockErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

type ProductVariantStocksUpdate {
  productVariant: ProductVariant
  errors: [BulkStockError!]!
}

input ProductVariantInput {
  attributes: [AttributeValueInput!]!
  sku: String
  trackInventory: Boolean
  weight: WeightScalar
}

type ProductVariantUpdate {
  errors: [ProductError!]!
  productVariant: ProductVariant
}

type ProductVariantSetDefault {
  product: Product
  errors: [ProductError!]!
}

input NameTranslationInput {
  name: String
}

type ProductVariantTranslate {
  errors: [TranslationError!]!
  productVariant: ProductVariant
}

input ProductVariantChannelListingAddInput {
  channelId: String!
  price: PositiveDecimal!
  costPrice: PositiveDecimal
}

type ProductVariantChannelListingUpdate {
  variant: ProductVariant
  errors: [ProductChannelListingError!]!
}

type ProductVariantReorderAttributeValues {
  productVariant: ProductVariant
  errors: [ProductError!]!
}

input ProductVariantFilterInput {
  search: String
  sku: [String!]!
  metadata: [MetadataInput]!
}

type ProductVariantCountableConnection {
  pageInfo: PageInfo!
  edges: [ProductVariantCountableEdge!]!
  totalCount: Int
}

type ProductVariantChannelListing  {
  id: String!
  channel: Channel!
  price: Money
  costPrice: Money
  margin: Int
  preorderThreshold: PreorderThreshold
}

type PreorderThreshold {
  quantity: Int
  soldUnits: Int!
}

type VariantPricingInfo {
  onSale: Boolean
  discount: TaxedMoney
  discountLocalCurrency: TaxedMoney
  price: TaxedMoney
  priceUndiscounted: TaxedMoney
  priceLocalCurrency: TaxedMoney
}

enum VariantAttributeScope {
  ALL
  VARIANT_SELECTION
  NOT_VARIANT_SELECTION
}

type ProductVariantTranslation  {
  id: String!
  name: String!
  language: LanguageDisplay!
}

input BulkAttributeValueInput {
  id: String
  values: [String!]!
  boolean: Boolean
}

type BulkStockError {
  field: String
  message: String
  code: ProductErrorCode!
  attributes: [String!]!
  values: [String!]!
  index: Int
}

type ProductChannelListingError {
  field: String
  message: String
  code: ProductErrorCode!
  attributes: [String!]!
  values: [String!]!
  channels: [String!]!
  variants: [String!]!
}

type ProductVariantCountableEdge {
  node: ProductVariant!
  cursor: String!
}

type ProductVariantBulkCreate {
  count: Int!
  productVariants: [ProductVariant!]!
  errors: [BulkProductError!]!
}

type BulkProductError {
  field: String
  message: String
  code: ProductErrorCode!
  attributes: [String!]!
  values: [String!]!
  index: Int
  warehouses: [String!]!
  channels: [String!]!
}

extend type Mutation {
  saleCreate(input: SaleInput!): SaleCreate
  saleDelete(id: String!): SaleDelete
  saleBulkDelete(ids: [String!]!): SaleBulkDelete
  saleUpdate(id: String!, input: SaleInput!): SaleUpdate
  saleCataloguesAdd(id: String!, input: CatalogueInput!): SaleAddCatalogues
  saleCataloguesRemove(id: String!, input: CatalogueInput!): SaleRemoveCatalogues
  saleTranslate(id: String!, input: NameTranslationInput!, languageCode: LanguageCodeEnum!): SaleTranslate
  saleChannelListingUpdate(id: String!, input: SaleChannelListingInput!): SaleChannelListingUpdate
}

extend type Query {
  sale(id: String!, channel: String): Sale
  sales(filter: SaleFilterInput, sortBy: SaleSortingInput, query: String, channel: String, before: String, after: String, first: Int, last: Int): SaleCountableConnection
}

type Sale  {
  id: String!
  name: String!
  type: SaleType!
  startDate: DateTime!
  endDate: DateTime
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  categories(before: String, after: String, first: Int, last: Int): CategoryCountableConnection
  collections(before: String, after: String, first: Int, last: Int): CollectionCountableConnection
  products(before: String, after: String, first: Int, last: Int): ProductCountableConnection
  variants(before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection
  translation(languageCode: LanguageCodeEnum!): SaleTranslation
  channelListings: [SaleChannelListing!]!
  discountValue: Float
  currency: String
}

input SaleInput {
  name: String
  type: DiscountValueTypeEnum
  value: PositiveDecimal
  products: [String!]!
  variants: [String!]!
  categories: [String!]!
  collections: [String!]!
  startDate: DateTime
  endDate: DateTime
}

type SaleCreate {
  errors: [DiscountError!]!
  sale: Sale
}

type SaleDelete {
  errors: [DiscountError!]!
  sale: Sale
}

type SaleBulkDelete {
  count: Int!
  errors: [DiscountError!]!
}

type SaleUpdate {
  errors: [DiscountError!]!
  sale: Sale
}

input CatalogueInput {
  products: [String!]!
  categories: [String!]!
  collections: [String!]!
}

type SaleAddCatalogues {
  sale: Sale
  errors: [DiscountError!]!
}

type SaleRemoveCatalogues {
  sale: Sale
  errors: [DiscountError!]!
}

type SaleTranslate {
  errors: [TranslationError!]!
  sale: Sale
}

input SaleChannelListingInput {
  addChannels: [SaleChannelListingAddInput!]!
  removeChannels: [String!]!
}

type SaleChannelListingUpdate {
  sale: Sale
  errors: [DiscountError!]!
}

input SaleFilterInput {
  status: [DiscountStatusEnum]!
  saleType: DiscountValueTypeEnum
  started: DateTimeRangeInput
  search: String
  metadata: [MetadataFilter]!
}

enum SaleSortField {
  NAME
  START_DATE
  END_DATE
  VALUE
  TYPE
}

input SaleSortingInput {
  direction: OrderDirection!
  channel: String
  field: SaleSortField!
}

type SaleCountableConnection {
  pageInfo: PageInfo!
  edges: [SaleCountableEdge!]!
  totalCount: Int
}

type SaleCountableEdge {
  node: Sale!
  cursor: String!
}

enum SaleType {
  fixed
  percentage
}

type SaleTranslation  {
  id: String!
  name: String
  language: LanguageDisplay!
}

type SaleChannelListing  {
  id: String!
  channel: Channel!
  discountValue: Float!
  currency: String!
}

enum DiscountValueTypeEnum {
  fixed
  percentage
}

input SaleChannelListingAddInput {
  channelId: String!
  discountValue: PositiveDecimal!
}

schema {
  query: Query
  mutation: Mutation
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum AreaUnitsEnum {
  sq_cm # SQ_CM
  sq_m # SQ_M
  sq_km # SQ_KM
  sq_ft # SQ_FT
  sq_yd # SQ_YD
  sq_inch # SQ_INCH
}

type AssignNavigation {
  menu: Menu
  errors: [MenuError!]!
}

input AttributeValueInput {
  id: String
  values: [String!]!
  file: String
  contentType: String
  references: [String!]!
  richText: JSONString!
  boolean: Boolean
  date: Date
  dateTime: DateTime
}

enum CategorySortField {
  NAME
  PRODUCT_COUNT
  SUBCATEGORY_COUNT
}

type ConfigurationItem {
  name: String!
  value: String
  type: ConfigurationTypeFieldEnum
  helpText: String
  label: String
}

input ConfigurationItemInput {
  name: String!
  value: String
}

enum ConfigurationTypeFieldEnum {
  STRING
  MULTILINE
  BOOLEAN
  SECRET
  PASSWORD
  SECRETMULTILINE
  OUTPUT
}

enum CountryCode {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  CV
  KH
  CM
  CA
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  EU
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  String
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  KP
  MK
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  UM
  US
  UY
  UZ
  VU
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

scalar Date

input DateRangeInput {
  gte: Date
  lte: Date
}

scalar DateTime

input DateTimeRangeInput {
  gte: DateTime
  lte: DateTime
}

enum DistanceUnitsEnum {
  cm
  m
  km
  ft
  yd
  inch
}

type Domain {
  host: String!
  sslEnabled: Boolean!
  url: String!
}

type File {
  url: String!
  contentType: String
}

type FileUpload {
  uploadedFile: File
  errors: [UploadError!]!
}

input IntRangeInput {
  gte: Int
  lte: Int
}

scalar JSONString

interface Job {
  status: JobStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  message: String
}

enum JobStatusEnum {
  PENDING
  SUCCESS
  FAILED
  DELETED
}

enum LanguageCodeEnum {
  AF
  AF_NA
  AF_ZA
  AGQ
  AGQ_CM
  AK
  AK_GH
  AM
  AM_ET
  AR
  AR_AE
  AR_BH
  AR_DJ
  AR_DZ
  AR_EG
  AR_EH
  AR_ER
  AR_IL
  AR_IQ
  AR_JO
  AR_KM
  AR_KW
  AR_LB
  AR_LY
  AR_MA
  AR_MR
  AR_OM
  AR_PS
  AR_QA
  AR_SA
  AR_SD
  AR_SO
  AR_SS
  AR_SY
  AR_TD
  AR_TN
  AR_YE
  AS
  AS_IN
  ASA
  ASA_TZ
  AST
  AST_ES
  AZ
  AZ_CYRL
  AZ_CYRL_AZ
  AZ_LATN
  AZ_LATN_AZ
  BAS
  BAS_CM
  BE
  BE_BY
  BEM
  BEM_ZM
  BEZ
  BEZ_TZ
  BG
  BG_BG
  BM
  BM_ML
  BN
  BN_BD
  BN_IN
  BO
  BO_CN
  BO_IN
  BR
  BR_FR
  BRX
  BRX_IN
  BS
  BS_CYRL
  BS_CYRL_BA
  BS_LATN
  BS_LATN_BA
  CA
  CA_AD
  CA_ES
  CA_ES_VALENCIA
  CA_FR
  CA_IT
  CCP
  CCP_BD
  CCP_IN
  CE
  CE_RU
  CEB
  CEB_PH
  CGG
  CGG_UG
  CHR
  CHR_US
  CKB
  CKB_IQ
  CKB_IR
  CS
  CS_CZ
  CU
  CU_RU
  CY
  CY_GB
  DA
  DA_DK
  DA_GL
  DAV
  DAV_KE
  DE
  DE_AT
  DE_BE
  DE_CH
  DE_DE
  DE_IT
  DE_LI
  DE_LU
  DJE
  DJE_NE
  DSB
  DSB_DE
  DUA
  DUA_CM
  DYO
  DYO_SN
  DZ
  DZ_BT
  EBU
  EBU_KE
  EE
  EE_GH
  EE_TG
  EL
  EL_CY
  EL_GR
  EN
  EN_AE
  EN_AG
  EN_AI
  EN_AS
  EN_AT
  EN_AU
  EN_BB
  EN_BE
  EN_BI
  EN_BM
  EN_BS
  EN_BW
  EN_BZ
  EN_CA
  EN_CC
  EN_CH
  EN_CK
  EN_CM
  EN_CX
  EN_CY
  EN_DE
  EN_DG
  EN_DK
  EN_DM
  EN_ER
  EN_FI
  EN_FJ
  EN_FK
  EN_FM
  EN_GB
  EN_GD
  EN_GG
  EN_GH
  EN_GI
  EN_GM
  EN_GU
  EN_GY
  EN_HK
  EN_IE
  EN_IL
  EN_IM
  EN_IN
  EN_IO
  EN_JE
  EN_JM
  EN_KE
  EN_KI
  EN_KN
  EN_KY
  EN_LC
  EN_LR
  EN_LS
  EN_MG
  EN_MH
  EN_MO
  EN_MP
  EN_MS
  EN_MT
  EN_MU
  EN_MW
  EN_MY
  EN_NA
  EN_NF
  EN_NG
  EN_NL
  EN_NR
  EN_NU
  EN_NZ
  EN_PG
  EN_PH
  EN_PK
  EN_PN
  EN_PR
  EN_PW
  EN_RW
  EN_SB
  EN_SC
  EN_SD
  EN_SE
  EN_SG
  EN_SH
  EN_SI
  EN_SL
  EN_SS
  EN_SX
  EN_SZ
  EN_TC
  EN_TK
  EN_TO
  EN_TT
  EN_TV
  EN_TZ
  EN_UG
  EN_UM
  EN_US
  EN_VC
  EN_VG
  EN_VI
  EN_VU
  EN_WS
  EN_ZA
  EN_ZM
  EN_ZW
  EO
  ES
  ES_AR
  ES_BO
  ES_BR
  ES_BZ
  ES_CL
  ES_CO
  ES_CR
  ES_CU
  ES_DO
  ES_EA
  ES_EC
  ES_ES
  ES_GQ
  ES_GT
  ES_HN
  ES_IC
  ES_MX
  ES_NI
  ES_PA
  ES_PE
  ES_PH
  ES_PR
  ES_PY
  ES_SV
  ES_US
  ES_UY
  ES_VE
  ET
  ET_EE
  EU
  EU_ES
  EWO
  EWO_CM
  FA
  FA_AF
  FA_IR
  FF
  FF_ADLM
  FF_ADLM_BF
  FF_ADLM_CM
  FF_ADLM_GH
  FF_ADLM_GM
  FF_ADLM_GN
  FF_ADLM_GW
  FF_ADLM_LR
  FF_ADLM_MR
  FF_ADLM_NE
  FF_ADLM_NG
  FF_ADLM_SL
  FF_ADLM_SN
  FF_LATN
  FF_LATN_BF
  FF_LATN_CM
  FF_LATN_GH
  FF_LATN_GM
  FF_LATN_GN
  FF_LATN_GW
  FF_LATN_LR
  FF_LATN_MR
  FF_LATN_NE
  FF_LATN_NG
  FF_LATN_SL
  FF_LATN_SN
  FI
  FI_FI
  FIL
  FIL_PH
  FO
  FO_DK
  FO_FO
  FR
  FR_BE
  FR_BF
  FR_BI
  FR_BJ
  FR_BL
  FR_CA
  FR_CD
  FR_CF
  FR_CG
  FR_CH
  FR_CI
  FR_CM
  FR_DJ
  FR_DZ
  FR_FR
  FR_GA
  FR_GF
  FR_GN
  FR_GP
  FR_GQ
  FR_HT
  FR_KM
  FR_LU
  FR_MA
  FR_MC
  FR_MF
  FR_MG
  FR_ML
  FR_MQ
  FR_MR
  FR_MU
  FR_NC
  FR_NE
  FR_PF
  FR_PM
  FR_RE
  FR_RW
  FR_SC
  FR_SN
  FR_SY
  FR_TD
  FR_TG
  FR_TN
  FR_VU
  FR_WF
  FR_YT
  FUR
  FUR_IT
  FY
  FY_NL
  GA
  GA_GB
  GA_IE
  GD
  GD_GB
  GL
  GL_ES
  GSW
  GSW_CH
  GSW_FR
  GSW_LI
  GU
  GU_IN
  GUZ
  GUZ_KE
  GV
  GV_IM
  HA
  HA_GH
  HA_NE
  HA_NG
  HAW
  HAW_US
  HE
  HE_IL
  HI
  HI_IN
  HR
  HR_BA
  HR_HR
  HSB
  HSB_DE
  HU
  HU_HU
  HY
  HY_AM
  IA
  String
  ID_ID
  IG
  IG_NG
  II
  II_CN
  IS
  IS_IS
  IT
  IT_CH
  IT_IT
  IT_SM
  IT_VA
  JA
  JA_JP
  JGO
  JGO_CM
  JMC
  JMC_TZ
  JV
  JV_ID
  KA
  KA_GE
  KAB
  KAB_DZ
  KAM
  KAM_KE
  KDE
  KDE_TZ
  KEA
  KEA_CV
  KHQ
  KHQ_ML
  KI
  KI_KE
  KK
  KK_KZ
  KKJ
  KKJ_CM
  KL
  KL_GL
  KLN
  KLN_KE
  KM
  KM_KH
  KN
  KN_IN
  KO
  KO_KP
  KO_KR
  KOK
  KOK_IN
  KS
  KS_ARAB
  KS_ARAB_IN
  KSB
  KSB_TZ
  KSF
  KSF_CM
  KSH
  KSH_DE
  KU
  KU_TR
  KW
  KW_GB
  KY
  KY_KG
  LAG
  LAG_TZ
  LB
  LB_LU
  LG
  LG_UG
  LKT
  LKT_US
  LN
  LN_AO
  LN_CD
  LN_CF
  LN_CG
  LO
  LO_LA
  LRC
  LRC_IQ
  LRC_IR
  LT
  LT_LT
  LU
  LU_CD
  LUO
  LUO_KE
  LUY
  LUY_KE
  LV
  LV_LV
  MAI
  MAI_IN
  MAS
  MAS_KE
  MAS_TZ
  MER
  MER_KE
  MFE
  MFE_MU
  MG
  MG_MG
  MGH
  MGH_MZ
  MGO
  MGO_CM
  MI
  MI_NZ
  MK
  MK_MK
  ML
  ML_IN
  MN
  MN_MN
  MNI
  MNI_BENG
  MNI_BENG_IN
  MR
  MR_IN
  MS
  MS_BN
  MS_ID
  MS_MY
  MS_SG
  MT
  MT_MT
  MUA
  MUA_CM
  MY
  MY_MM
  MZN
  MZN_IR
  NAQ
  NAQ_NA
  NB
  NB_NO
  NB_SJ
  ND
  ND_ZW
  NDS
  NDS_DE
  NDS_NL
  NE
  NE_IN
  NE_NP
  NL
  NL_AW
  NL_BE
  NL_BQ
  NL_CW
  NL_NL
  NL_SR
  NL_SX
  NMG
  NMG_CM
  NN
  NN_NO
  NNH
  NNH_CM
  NUS
  NUS_SS
  NYN
  NYN_UG
  OM
  OM_ET
  OM_KE
  OR
  OR_IN
  OS
  OS_GE
  OS_RU
  PA
  PA_ARAB
  PA_ARAB_PK
  PA_GURU
  PA_GURU_IN
  PCM
  PCM_NG
  PL
  PL_PL
  PRG
  PS
  PS_AF
  PS_PK
  PT
  PT_AO
  PT_BR
  PT_CH
  PT_CV
  PT_GQ
  PT_GW
  PT_LU
  PT_MO
  PT_MZ
  PT_PT
  PT_ST
  PT_TL
  QU
  QU_BO
  QU_EC
  QU_PE
  RM
  RM_CH
  RN
  RN_BI
  RO
  RO_MD
  RO_RO
  ROF
  ROF_TZ
  RU
  RU_BY
  RU_KG
  RU_KZ
  RU_MD
  RU_RU
  RU_UA
  RW
  RW_RW
  RWK
  RWK_TZ
  SAH
  SAH_RU
  SAQ
  SAQ_KE
  SAT
  SAT_OLCK
  SAT_OLCK_IN
  SBP
  SBP_TZ
  SD
  SD_ARAB
  SD_ARAB_PK
  SD_DEVA
  SD_DEVA_IN
  SE
  SE_FI
  SE_NO
  SE_SE
  SEH
  SEH_MZ
  SES
  SES_ML
  SG
  SG_CF
  SHI
  SHI_LATN
  SHI_LATN_MA
  SHI_TFNG
  SHI_TFNG_MA
  SI
  SI_LK
  SK
  SK_SK
  SL
  SL_SI
  SMN
  SMN_FI
  SN
  SN_ZW
  SO
  SO_DJ
  SO_ET
  SO_KE
  SO_SO
  SQ
  SQ_AL
  SQ_MK
  SQ_XK
  SR
  SR_CYRL
  SR_CYRL_BA
  SR_CYRL_ME
  SR_CYRL_RS
  SR_CYRL_XK
  SR_LATN
  SR_LATN_BA
  SR_LATN_ME
  SR_LATN_RS
  SR_LATN_XK
  SU
  SU_LATN
  SU_LATN_ID
  SV
  SV_AX
  SV_FI
  SV_SE
  SW
  SW_CD
  SW_KE
  SW_TZ
  SW_UG
  TA
  TA_IN
  TA_LK
  TA_MY
  TA_SG
  TE
  TE_IN
  TEO
  TEO_KE
  TEO_UG
  TG
  TG_TJ
  TH
  TH_TH
  TI
  TI_ER
  TI_ET
  TK
  TK_TM
  TO
  TO_TO
  TR
  TR_CY
  TR_TR
  TT
  TT_RU
  TWQ
  TWQ_NE
  TZM
  TZM_MA
  UG
  UG_CN
  UK
  UK_UA
  UR
  UR_IN
  UR_PK
  UZ
  UZ_ARAB
  UZ_ARAB_AF
  UZ_CYRL
  UZ_CYRL_UZ
  UZ_LATN
  UZ_LATN_UZ
  VAI
  VAI_LATN
  VAI_LATN_LR
  VAI_VAII
  VAI_VAII_LR
  VI
  VI_VN
  VO
  VUN
  VUN_TZ
  WAE
  WAE_CH
  WO
  WO_SN
  XH
  XH_ZA
  XOG
  XOG_UG
  YAV
  YAV_CM
  YI
  YO
  YO_BJ
  YO_NG
  YUE
  YUE_HANS
  YUE_HANS_CN
  YUE_HANT
  YUE_HANT_HK
  ZGH
  ZGH_MA
  ZH
  ZH_HANS
  ZH_HANS_CN
  ZH_HANS_HK
  ZH_HANS_MO
  ZH_HANS_SG
  ZH_HANT
  ZH_HANT_HK
  ZH_HANT_MO
  ZH_HANT_TW
  ZU
  ZU_ZA
}

type LanguageDisplay {
  code: LanguageCodeEnum!
  language: String!
}

enum MeasurementUnitsEnum {
  cm
  m
  km
  ft
  yd
  inch
  sq_cm
  sq_m
  sq_km
  sq_ft
  sq_yd
  sq_inch
  cubic_millimeter
  cubic_centimeter
  cubic_decimeter
  cubic_meter
  liter
  cubic_foot
  cubic_inch
  cubic_yard
  qt
  pint
  fl_oz
  acre_in
  acre_ft
  g
  lb
  oz
  kg
  tonne
}

type Money {
  currency: String!
  amount: Float!
}

type MoneyRange {
  start: Money
  stop: Money
}

type Mutation {
  variantMediaAssign(mediaId: String!, variantId: String!): VariantMediaAssign
  variantMediaUnassign(mediaId: String!, variantId: String!): VariantMediaUnassign
  assignNavigation(menu: String, navigationType: NavigationType!): AssignNavigation
  fileUpload(file: Upload!): FileUpload
  externalNotificationTrigger(channel: String!, input: ExternalNotificationTriggerInput!, pluginId: String): ExternalNotificationTrigger
}

enum NavigationType {
  MAIN
  SECONDARY
}

interface Node {
  id: String!
}

type OrderEventCountableConnection {
  pageInfo: PageInfo!
  edges: [OrderEventCountableEdge!]!
  totalCount: Int
}

type OrderEventCountableEdge {
  node: OrderEvent!
  cursor: String!
}

scalar PositiveDecimal

# type ProductImage {
#   id: String!
#   alt: String
#   sortOrder: Int
#   url(size: Int): String!
# }

type Query {
  reportProductSales(period: ReportingPeriod!, channel: String!, before: String, after: String, first: Int, last: Int): ProductVariantCountableConnection
  homepageEvents(before: String, after: String, first: Int, last: Int): OrderEventCountableConnection
  taxTypes: [TaxType]!
}

enum ReportingPeriod {
  TODAY
  THIS_MONTH
}

type TaxType {
  description: String
  taxCode: String
}

type TaxedMoney {
  currency: String!
  gross: Money!
  net: Money!
  tax: Money!
}

type TaxedMoneyRange {
  start: TaxedMoney
  stop: TaxedMoney
}

scalar Upload

type UploadError {
  field: String
  message: String
  code: UploadErrorCode!
}

enum UploadErrorCode {
  GRAPHQL_ERROR
}

type VariantMediaAssign {
  productVariant: ProductVariant
  media: ProductMedia
  errors: [ProductError!]!
}

type VariantMediaUnassign {
  productVariant: ProductVariant
  media: ProductMedia
  errors: [ProductError!]!
}

enum VolumeUnitsEnum {
  cubic_millimeter
  cubic_centimeter
  cubic_decimeter
  cubic_meter
  liter
  cubic_foot
  cubic_inch
  cubic_yard
  qt
  pint
  fl_oz
  acre_in
  acre_ft
}

type Weight {
  unit: WeightUnitsEnum!
  value: Float!
}

scalar WeightScalar

enum WeightUnitsEnum {
  g
  lb
  oz
  kg
  tonne
}

type ExternalNotificationError {
  field: String
  message: String
  code: ExternalNotificationErrorCodes!
}

enum ExternalNotificationErrorCodes {
  REQUIRED
  INVALID_MODEL_TYPE
  NOT_FOUND
  CHANNEL_INACTIVE
}

type ExternalNotificationTrigger {
  errors: [ExternalNotificationError!]!
}

input ExternalNotificationTriggerInput {
  ids: [String!]!
  extraPayload: JSONString!
  externalEventType: String!
}

type TimePeriod {
  amount: Int!
  type: TimePeriodTypeEnum!
}

input TimePeriodInputType {
  amount: Int!
  type: TimePeriodTypeEnum!
}

enum TimePeriodTypeEnum {
  day
  week
  month
  year
}

input MetadataFilter {
  key: String!
  value: String
}

extend type Mutation {
  shippingMethodChannelListingUpdate(id: String!, input: ShippingMethodChannelListingInput!): ShippingMethodChannelListingUpdate
  shippingPriceCreate(input: ShippingPriceInput!): ShippingPriceCreate
  shippingPriceDelete(id: String!): ShippingPriceDelete
  shippingPriceBulkDelete(ids: [String!]!): ShippingPriceBulkDelete
  shippingPriceUpdate(id: String!, input: ShippingPriceInput!): ShippingPriceUpdate
  shippingPriceTranslate(id: String!, input: ShippingPriceTranslationInput!, languageCode: LanguageCodeEnum!): ShippingPriceTranslate
  shippingPriceExcludeProducts(id: String!, input: ShippingPriceExcludeProductsInput!): ShippingPriceExcludeProducts
  shippingPriceRemoveProductFromExclude(id: String!, products: [String!]!): ShippingPriceRemoveProductFromExclude
  shippingZoneCreate(input: ShippingZoneCreateInput!): ShippingZoneCreate
  shippingZoneDelete(id: String!): ShippingZoneDelete
  shippingZoneBulkDelete(ids: [String!]!): ShippingZoneBulkDelete
  shippingZoneUpdate(id: String!, input: ShippingZoneUpdateInput!): ShippingZoneUpdate
}

extend type Query {
  shippingZone(id: String!, channel: String): ShippingZone
  shippingZones(filter: ShippingZoneFilterInput, channel: String, before: String, after: String, first: Int, last: Int): ShippingZoneCountableConnection
}

input ShippingMethodChannelListingInput {
  addChannels: [ShippingMethodChannelListingAddInput!]!
  removeChannels: [String!]!
}

type ShippingMethodChannelListingUpdate {
  shippingMethod: ShippingMethod
  errors: [ShippingError!]!
}

input ShippingPriceInput {
  name: String
  description: JSONString!
  minimumOrderWeight: WeightScalar
  maximumOrderWeight: WeightScalar
  maximumDeliveryDays: Int
  minimumDeliveryDays: Int
  type: ShippingMethodTypeEnum
  shippingZone: String
  addPostalCodeRules: [ShippingPostalCodeRulesCreateInputRange!]!
  deletePostalCodeRules: [String!]!
  inclusionType: PostalCodeRuleInclusionTypeEnum
}

type ShippingPriceCreate {
  shippingZone: ShippingZone
  shippingMethod: ShippingMethod
  errors: [ShippingError!]!
}

type ShippingPriceDelete {
  shippingMethod: ShippingMethod
  shippingZone: ShippingZone
  errors: [ShippingError!]!
}

type ShippingPriceBulkDelete {
  count: Int!
  errors: [ShippingError!]!
}

type ShippingPriceUpdate {
  shippingZone: ShippingZone
  shippingMethod: ShippingMethod
  errors: [ShippingError!]!
}

input ShippingPriceTranslationInput {
  name: String
  description: JSONString!
}

type ShippingPriceTranslate {
  errors: [TranslationError!]!
  shippingMethod: ShippingMethod
}

input ShippingPriceExcludeProductsInput {
  products: [String!]!
}

type ShippingPriceExcludeProducts {
  shippingMethod: ShippingMethod
  errors: [ShippingError!]!
}

type ShippingPriceRemoveProductFromExclude {
  shippingMethod: ShippingMethod
  errors: [ShippingError!]!
}

input ShippingZoneCreateInput {
  name: String
  description: String
  countries: [String!]!
  default: Boolean
  addWarehouses: [String!]!
  addChannels: [String!]!
}

type ShippingZoneCreate {
  errors: [ShippingError!]!
  shippingZone: ShippingZone
}

type ShippingZoneDelete {
  errors: [ShippingError!]!
  shippingZone: ShippingZone
}

type ShippingZoneBulkDelete {
  count: Int!
  errors: [ShippingError!]!
}

input ShippingZoneUpdateInput {
  name: String
  description: String
  countries: [String!]!
  default: Boolean
  addWarehouses: [String!]!
  addChannels: [String!]!
  removeWarehouses: [String!]!
  removeChannels: [String!]!
}

type ShippingZoneUpdate {
  errors: [ShippingError!]!
  shippingZone: ShippingZone
}

type ShippingZone  {
  id: String!
  name: String!
  default: Boolean!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  priceRange: MoneyRange
  countries: [CountryDisplay]!
  shippingMethods: [ShippingMethod]!
  warehouses: [Warehouse!]!
  channels: [Channel!]!
  description: String
}

input ShippingZoneFilterInput {
  search: String
  channels: [String!]!
}

type ShippingZoneCountableConnection {
  pageInfo: PageInfo!
  edges: [ShippingZoneCountableEdge!]!
  totalCount: Int
}

input ShippingMethodChannelListingAddInput {
  channelId: String!
  price: PositiveDecimal
  minimumOrderPrice: PositiveDecimal
  maximumOrderPrice: PositiveDecimal
}

type ShippingMethod  {
  id: String!
  name: String!
  description: JSONString!
  minimumOrderWeight: Weight
  maximumOrderWeight: Weight
  maximumDeliveryDays: Int
  minimumDeliveryDays: Int
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  type: ShippingMethodTypeEnum
  translation(languageCode: LanguageCodeEnum!): ShippingMethodTranslation
  channelListings: [ShippingMethodChannelListing!]!
  price: Money
  maximumOrderPrice: Money
  minimumOrderPrice: Money
  postalCodeRules: [ShippingMethodPostalCodeRule]!
  excludedProducts(before: String, after: String, first: Int, last: Int): ProductCountableConnection
}

type ShippingError {
  field: String
  message: String
  code: ShippingErrorCode!
  warehouses: [String!]!
  channels: [String!]!
}

enum ShippingErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  MAX_LESS_THAN_MIN
  NOT_FOUND
  REQUIRED
  UNIQUE
  DUPLICATED_INPUT_ITEM
}

enum ShippingMethodTypeEnum {
  price
  weight
}

input ShippingPostalCodeRulesCreateInputRange {
  start: String!
  end: String
}

enum PostalCodeRuleInclusionTypeEnum {
  INCLUDE
  EXCLUDE
}

type ShippingZoneCountableEdge {
  node: ShippingZone!
  cursor: String!
}

type ShippingMethodTranslation  {
  id: String!
  name: String
  description: JSONString!
  language: LanguageDisplay!
}

type ShippingMethodChannelListing  {
  id: String!
  channel: Channel!
  minimumOrderPrice: Money
  maximumOrderPrice: Money
  price: Money
}

type ShippingMethodPostalCodeRule  {
  start: String
  end: String
  inclusionType: PostalCodeRuleInclusionTypeEnum
  id: String!
}

extend type Query {
  shop: Shop!
}

extend type Mutation {
  shopDomainUpdate(input: SiteDomainInput): ShopDomainUpdate
  shopSettingsUpdate(input: ShopSettingsInput!): ShopSettingsUpdate
  shopFetchTaxRates: ShopFetchTaxRates
  shopSettingsTranslate(input: ShopSettingsTranslationInput!, languageCode: LanguageCodeEnum!): ShopSettingsTranslate
  shopAddressUpdate(input: AddressInput): ShopAddressUpdate
}

type Shop {
  availablePaymentGateways(currency: String, channel: String): [PaymentGateway!]!
  availableExternalAuthentications: [ExternalAuthentication!]!
  availableShippingMethods(channel: String!, address: AddressInput): [ShippingMethod]!
  channelCurrencies: [String!]!
  countries(languageCode: LanguageCodeEnum): [CountryDisplay!]!
  defaultCountry: CountryDisplay
  defaultMailSenderName: String
  defaultMailSenderAddress: String
  description: String
  domain: Domain!
  languages: [LanguageDisplay]!
  name: String!
  permissions: [Permission]!
  phonePrefixes: [String!]!
  headerText: String
  includeTaxesInPrices: Boolean!
  fulfillmentAutoApprove: Boolean!
  fulfillmentAllowUnpaid: Boolean!
  displayGrossPrices: Boolean!
  chargeTaxesOnShipping: Boolean!
  trackInventoryByDefault: Boolean
  defaultWeightUnit: WeightUnitsEnum
  translation(languageCode: LanguageCodeEnum!): ShopTranslation
  automaticFulfillmentDigitalProducts: Boolean
  defaultDigitalMaxDownloads: Int
  defaultDigitalUrlValidDays: Int
  companyAddress: Address
  customerSetPasswordUrl: String
  staffNotificationRecipients: [StaffNotificationRecipient]!
  limits: LimitInfo!
  version: String!
}

type ExternalAuthentication {
  id: String!
  name: String
}

input SiteDomainInput {
  domain: String
  name: String
}

type ShopDomainUpdate {
  shop: Shop
  errors: [ShopError!]!
}

input ShopSettingsInput {
  headerText: String
  description: String
  includeTaxesInPrices: Boolean
  displayGrossPrices: Boolean
  chargeTaxesOnShipping: Boolean
  trackInventoryByDefault: Boolean
  defaultWeightUnit: WeightUnitsEnum
  automaticFulfillmentDigitalProducts: Boolean
  fulfillmentAutoApprove: Boolean
  fulfillmentAllowUnpaid: Boolean
  defaultDigitalMaxDownloads: Int
  defaultDigitalUrlValidDays: Int
  defaultMailSenderName: String
  defaultMailSenderAddress: String
  customerSetPasswordUrl: String
}

type ShopSettingsUpdate {
  shop: Shop
  errors: [ShopError!]!
}

type ShopFetchTaxRates {
  shop: Shop
  errors: [ShopError!]!
}

input ShopSettingsTranslationInput {
  headerText: String
  description: String
}

type ShopAddressUpdate {
  shop: Shop
  errors: [ShopError!]!
}

type ShopError {
  field: String
  message: String
  code: ShopErrorCode!
}

type ShopTranslation  {
  id: String!
  headerText: String!
  description: String!
  language: LanguageDisplay!
}

enum ShopErrorCode {
  ALREADY_EXISTS
  CANNOT_FETCH_TAX_RATES
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

type ShopSettingsTranslate {
  shop: Shop
  errors: [TranslationError!]!
}

type LimitInfo {
  currentUsage: Limits!
  allowedUsage: Limits!
}

type Limits {
  channels: Int
  orders: Int
  productVariants: Int
  staffUsers: Int
  warehouses: Int
}

extend type Mutation {
  staffNotificationRecipientCreate(input: StaffNotificationRecipientInput!): StaffNotificationRecipientCreate
  staffNotificationRecipientUpdate(id: String!, input: StaffNotificationRecipientInput!): StaffNotificationRecipientUpdate
  staffNotificationRecipientDelete(id: String!): StaffNotificationRecipientDelete
  staffCreate(input: StaffCreateInput!): StaffCreate
  staffUpdate(id: String!, input: StaffUpdateInput!): StaffUpdate
  staffDelete(id: String!): StaffDelete
  staffBulkDelete(ids: [String!]!): StaffBulkDelete
}

extend type Query {
  staffUsers(filter: StaffUserInput, sortBy: UserSortingInput, before: String, after: String, first: Int, last: Int): UserCountableConnection
}

input StaffNotificationRecipientInput {
  user: String
  email: String
  active: Boolean
}

type StaffNotificationRecipientCreate {
  errors: [ShopError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

type StaffNotificationRecipient  {
  user: User
  active: Boolean
  id: String!
  email: String
}

type StaffNotificationRecipientUpdate {
  errors: [ShopError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

type StaffNotificationRecipientDelete {
  errors: [ShopError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

input StaffCreateInput {
  firstName: String
  lastName: String
  email: String
  isActive: Boolean
  note: String
  addGroups: [String!]!
  redirectUrl: String
}

type StaffCreate {
  errors: [StaffError!]!
  user: User
}

type StaffError {
  field: String
  message: String
  code: AccountErrorCode!
  addressType: AddressTypeEnum
  permissions: [PermissionEnum!]!
  groups: [String!]!
  users: [String!]!
}

input StaffUpdateInput {
  firstName: String
  lastName: String
  email: String
  isActive: Boolean
  note: String
  addGroups: [String!]!
  removeGroups: [String!]!
}

type StaffUpdate {
  errors: [StaffError!]!
  user: User
}

type StaffDelete {
  errors: [StaffError!]!
  user: User
}

type StaffBulkDelete {
  count: Int!
  errors: [StaffError!]!
}

input StaffUserInput {
  status: StaffMemberStatus
  search: String
}

enum StaffMemberStatus {
  active
  deactivated
}

extend type Mutation {
  translations(kind: TranslatableKinds!, before: String, after: String, first: Int, last: Int): TranslatableItemConnection
  translation(id: String!, kind: TranslatableKinds!): TranslatableItem
}

enum TranslatableKinds {
  ATTRIBUTE
  ATTRIBUTE_VALUE
  CATEGORY
  COLLECTION
  MENU_ITEM
  PAGE
  PRODUCT
  SALE
  SHIPPING_METHOD
  VARIANT
  VOUCHER
}

type TranslatableItemConnection {
  pageInfo: PageInfo!
  edges: [TranslatableItemEdge!]!
  totalCount: Int
}

type TranslatableItemEdge {
  node: TranslatableItem!
  cursor: String!
}

union TranslatableItem = 
ProductTranslatableContent | 
CollectionTranslatableContent | 
CategoryTranslatableContent | 
AttributeTranslatableContent | 
AttributeValueTranslatableContent | 
ProductVariantTranslatableContent | 
PageTranslatableContent | 
ShippingMethodTranslatableContent | 
SaleTranslatableContent | 
VoucherTranslatableContent | 
MenuItemTranslatableContent

type ProductTranslatableContent  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String!
  description: JSONString!
  translation(languageCode: LanguageCodeEnum!): ProductTranslation
  # product: Product
}

type CollectionTranslatableContent  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String!
  description: JSONString!
  translation(languageCode: LanguageCodeEnum!): CollectionTranslation
  # collection: Collection
}

type CategoryTranslatableContent  {
  id: String!
  seoTitle: String
  seoDescription: String
  name: String!
  description: JSONString!
  translation(languageCode: LanguageCodeEnum!): CategoryTranslation
  # category: Category
}

type AttributeTranslatableContent  {
  id: String!
  name: String!
  translation(languageCode: LanguageCodeEnum!): AttributeTranslation
  # attribute: Attribute
}

type AttributeValueTranslatableContent  {
  id: String!
  name: String!
  richText: JSONString!
  translation(languageCode: LanguageCodeEnum!): AttributeValueTranslation
  # attributeValue: AttributeValue
}

type ProductVariantTranslatableContent  {
  id: String!
  name: String!
  translation(languageCode: LanguageCodeEnum!): ProductVariantTranslation
  # productVariant: ProductVariant
  attributeValues: [AttributeValueTranslatableContent!]!
}

type PageTranslatableContent  {
  id: String!
  seoTitle: String
  seoDescription: String
  title: String!
  content: JSONString!
  translation(languageCode: LanguageCodeEnum!): PageTranslation
  # page: Page
}

type ShippingMethodTranslatableContent  {
  id: String!
  name: String!
  description: JSONString!
  translation(languageCode: LanguageCodeEnum!): ShippingMethodTranslation
  # shippingMethod: ShippingMethod
}

type SaleTranslatableContent  {
  id: String!
  name: String!
  translation(languageCode: LanguageCodeEnum!): SaleTranslation
  # sale: Sale
}

type VoucherTranslatableContent  {
  id: String!
  name: String
  translation(languageCode: LanguageCodeEnum!): VoucherTranslation
  # voucher: Voucher
}

type MenuItemTranslatableContent  {
  id: String!
  name: String!
  translation(languageCode: LanguageCodeEnum!): MenuItemTranslation
  # menuItem: MenuItem
}

type TranslationError {
  field: String
  message: String
  code: TranslationErrorCode!
}

enum TranslationErrorCode {
  GRAPHQL_ERROR
  NOT_FOUND
  REQUIRED
}

extend type Mutation {
  login(input: LoginInput!): LoginResponse!
  userAvatarUpdate(image: Upload!): UserAvatarUpdate
  userAvatarDelete: UserAvatarDelete
  userBulkSetActive(ids: [String!]!, isActive: Boolean!): UserBulkSetActive
}

extend type Query {
  me: User
  user(id: String, email: String): User
}

type User {
  id: String!
  lastLogin: DateTime
  email: String!
  firstName: String!
  lastName: String!
  userName: String!
  isActive: Boolean!
  note: String
  dateJoined: DateTime!
  defaultShippingAddress: Address
  defaultBillingAddress: Address
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  addresses: [Address]!
  checkoutTokens(channel: String): [String!]!
  giftCards(before: String, after: String, first: Int, last: Int): GiftCardCountableConnection # giftCards(before: String, after: String, first: Int, last: Int): GiftCardCountableConnection
  orders(before: String, after: String, first: Int, last: Int): OrderCountableConnection # orders(before: String, after: String, first: Int, last: Int): OrderCountableConnection
  userPermissions: [UserPermission]!
  permissionGroups: [Group]!
  editableGroups: [Group]!
  avatar(size: Int): Image
  events: [CustomerEvent]!
  storedPaymentSources(channel: String): [PaymentSource]!
  languageCode: LanguageCodeEnum!
  # wishlist: Wishlist
}

type UserPermission {
  code: PermissionEnum!
  name: String!
  sourcePermissionGroups(userId: String!): [Group!]!
}

type Image {
  url: String!
  alt: String
}

type LoginResponse {
  error: LoginError
  user: User 
}

input LoginInput {
  id: String!
  loginId: String!
  password: String!
  mfaToken: String!
  deviceId: String!
  ldapOnly: Boolean!
}

type LoginError {
  field: String
  message: String
  code: LoginErrorCode!
}

enum LoginErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

type UserAvatarUpdate {
  user: User
  errors: [AccountError!]!
}

type UserAvatarDelete {
  user: User
  errors: [AccountError!]!
}

type UserBulkSetActive {
  count: Int!
  errors: [AccountError!]!
}

type CustomerEvent  {
  id: String!
  date: DateTime
  type: CustomerEventsEnum
  user: User @authenticated(hi: true)
  app: App
  message: String
  count: Int
  order: Order
  orderLine: OrderLine
}

enum CustomerEventsEnum {
  ACCOUNT_CREATED
  PASSWORD_RESET_LINK_SENT
  PASSWORD_RESET
  EMAIL_CHANGED_REQUEST
  PASSWORD_CHANGED
  EMAIL_CHANGED
  PLACED_ORDER
  NOTE_ADDED_TO_ORDER
  DIGITAL_LINK_DOWNLOADED
  CUSTOMER_DELETED
  NAME_ASSIGNED
  EMAIL_ASSIGNED
  NOTE_ADDED
}

type PaymentSource {
  gateway: String!
  paymentMethodId: String
  creditCardInfo: CreditCard
  metadata: [MetadataItem]!
}

extend type Query {
  warehouse(id: String!): Warehouse
  warehouses(filter: WarehouseFilterInput, sortBy: WarehouseSortingInput, before: String, after: String, first: Int, last: Int): WarehouseCountableConnection
  stock(id: String!): Stock
  stocks(filter: StockFilterInput, before: String, after: String, first: Int, last: Int): StockCountableConnection
}

extend type Mutation {
  createWarehouse(input: WarehouseCreateInput!): WarehouseCreate
  updateWarehouse(id: String!, input: WarehouseUpdateInput!): WarehouseUpdate
  deleteWarehouse(id: String!): WarehouseDelete
  assignWarehouseShippingZone(id: String!, shippingZoneIds: [String!]!): WarehouseShippingZoneAssign
  unassignWarehouseShippingZone(id: String!, shippingZoneIds: [String!]!): WarehouseShippingZoneUnassign
}

input WarehouseCreateInput {
  slug: String
  companyName: String
  email: String
  name: String!
  address: AddressInput!
  shippingZones: [String!]!
}

type Stock  {
  warehouse: Warehouse!
  productVariant: ProductVariant!
  quantity: Int!
  id: String!
  quantityAllocated: Int!
}

input StockFilterInput {
  quantity: Float
  search: String
}

type WarehouseCreate {
  errors: [WarehouseError!]!
  warehouse: Warehouse
}

type WarehouseError {
  field: String
  message: String
  code: WarehouseErrorCode!
}

enum WarehouseErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

type WarehouseUpdate {
  errors: [WarehouseError!]!
  warehouse: Warehouse
}

type Warehouse  {
  id: String!
  name: String!
  slug: String!
  shippingZones(before: String, after: String, first: Int, last: Int): ShippingZoneCountableConnection!
  address: Address!
  email: String!
  isPrivate: Boolean!
  privateMetadata: [MetadataItem]!
  metadata: [MetadataItem]!
  clickAndCollectOption: WarehouseClickAndCollectOptionEnum!
}

enum WarehouseClickAndCollectOptionEnum {
  disabled
  local
  all
}

enum WarehouseSortField {
  NAME
}

type WarehouseCountableConnection {
  pageInfo: PageInfo!
  edges: [WarehouseCountableEdge!]!
  totalCount: Int
}

type WarehouseCountableEdge {
  node: Warehouse!
  cursor: String!
}

input WarehouseFilterInput {
  clickAndCollectOption: WarehouseClickAndCollectOptionEnum
  search: String
  ids: [String!]!
  isPrivate: Boolean
}

input WarehouseSortingInput {
  direction: OrderDirection!
  field: WarehouseSortField!
}

input WarehouseUpdateInput {
  slug: String
  email: String
  name: String
  address: AddressInput
  clickAndCollectOption: WarehouseClickAndCollectOptionEnum
  isPrivate: Boolean
}

type WarehouseDelete {
  errors: [WarehouseError!]!
  warehouse: Warehouse
}

type WarehouseShippingZoneAssign {
  errors: [WarehouseError!]!
  warehouse: Warehouse
}

type WarehouseShippingZoneUnassign {
  errors: [WarehouseError!]!
  warehouse: Warehouse
}

type StockCountableConnection {
  pageInfo: PageInfo!
  edges: [StockCountableEdge!]!
  totalCount: Int
}

type StockCountableEdge {
  node: Stock!
  cursor: String!
}

extend type Query {
  webhook(id: String!): Webhook
  webhookEvents: [WebhookEvent]!
  webhookSamplePayload(eventType: WebhookSampleEventTypeEnum!): JSONString!
}

extend type Mutation {
  webhookCreate(input: WebhookCreateInput!): WebhookCreate
  webhookDelete(id: String!): WebhookDelete
  webhookUpdate(id: String!, input: WebhookUpdateInput!): WebhookUpdate
}

input WebhookCreateInput {
  name: String
  targetUrl: String
  events: [WebhookEventTypeEnum]!
  app: String
  isActive: Boolean
  secretKey: String
}

enum WebhookEventTypeEnum {
  ANY_EVENTS
  ORDER_CREATED
  ORDER_CONFIRMED
  ORDER_FULLY_PAID
  ORDER_UPDATED
  ORDER_CANCELLED
  ORDER_FULFILLED
  DRAFT_ORDER_CREATED
  DRAFT_ORDER_UPDATED
  DRAFT_ORDER_DELETED
  SALE_CREATED
  SALE_UPDATED
  SALE_DELETED
  INVOICE_REQUESTED
  INVOICE_DELETED
  INVOICE_SENT
  CUSTOMER_CREATED
  CUSTOMER_UPDATED
  PRODUCT_CREATED
  PRODUCT_UPDATED
  PRODUCT_DELETED
  PRODUCT_VARIANT_CREATED
  PRODUCT_VARIANT_UPDATED
  PRODUCT_VARIANT_DELETED
  PRODUCT_VARIANT_OUT_OF_STOCK
  PRODUCT_VARIANT_BACK_IN_STOCK
  CHECKOUT_CREATED
  CHECKOUT_UPDATED
  FULFILLMENT_CREATED
  FULFILLMENT_CANCELED
  NOTIFY_USER
  PAGE_CREATED
  PAGE_UPDATED
  PAGE_DELETED
  PAYMENT_AUTHORIZE
  PAYMENT_CAPTURE
  PAYMENT_CONFIRM
  PAYMENT_LIST_GATEWAYS
  PAYMENT_PROCESS
  PAYMENT_REFUND
  PAYMENT_VOID
  TRANSLATION_CREATED
  TRANSLATION_UPDATED
}

type WebhookCreate {
  errors: [WebhookError!]!
  webhook: Webhook
}

type WebhookDelete {
  errors: [WebhookError!]!
  webhook: Webhook
}

type WebhookUpdate {
  errors: [WebhookError!]!
  webhook: Webhook
}

type WebhookError {
  field: String
  message: String
  code: WebhookErrorCode!
}

enum WebhookErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

enum WebhookSampleEventTypeEnum {
  ORDER_CREATED
  ORDER_CONFIRMED
  ORDER_FULLY_PAID
  ORDER_UPDATED
  ORDER_CANCELLED
  ORDER_FULFILLED
  DRAFT_ORDER_CREATED
  DRAFT_ORDER_UPDATED
  DRAFT_ORDER_DELETED
  SALE_CREATED
  SALE_UPDATED
  SALE_DELETED
  INVOICE_REQUESTED
  INVOICE_DELETED
  INVOICE_SENT
  CUSTOMER_CREATED
  CUSTOMER_UPDATED
  PRODUCT_CREATED
  PRODUCT_UPDATED
  PRODUCT_DELETED
  PRODUCT_VARIANT_CREATED
  PRODUCT_VARIANT_UPDATED
  PRODUCT_VARIANT_DELETED
  PRODUCT_VARIANT_OUT_OF_STOCK
  PRODUCT_VARIANT_BACK_IN_STOCK
  CHECKOUT_CREATED
  CHECKOUT_UPDATED
  FULFILLMENT_CREATED
  FULFILLMENT_CANCELED
  NOTIFY_USER
  PAGE_CREATED
  PAGE_UPDATED
  PAGE_DELETED
  PAYMENT_AUTHORIZE
  PAYMENT_CAPTURE
  PAYMENT_CONFIRM
  PAYMENT_LIST_GATEWAYS
  PAYMENT_PROCESS
  PAYMENT_REFUND
  PAYMENT_VOID
  TRANSLATION_CREATED
  TRANSLATION_UPDATED
}

input WebhookUpdateInput {
  name: String
  targetUrl: String
  events: [WebhookEventTypeEnum]!
  app: String
  isActive: Boolean
  secretKey: String
}

type Webhook  {
  name: String!
  targetUrl: String!
  isActive: Boolean!
  secretKey: String
  id: String!
  events: [WebhookEvent!]!
  app: App!
}

type WebhookEvent {
  eventType: WebhookEventTypeEnum!
  name: String!
}

type Wishlist  {
  id: String!
  token: String!
  createAt: DateTime!
  items: [WishlistItem]!
}

type WishlistItem  {
  id: String!
  product: Product!
  createAt: DateTime!
  variants: [ProductVariant]!
}

