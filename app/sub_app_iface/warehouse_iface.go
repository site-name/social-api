// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"github.com/mattermost/gorp"
	"github.com/sitename/sitename/exception"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/model/checkout"
	"github.com/sitename/sitename/model/order"
	"github.com/sitename/sitename/model/product_and_discount"
	"github.com/sitename/sitename/model/shipping"
	"github.com/sitename/sitename/model/warehouse"
)

// WarehouseService contains methods for working with warehouses
type WarehouseService interface {
	// Allocate stocks for given `order_lines` in given country.
	//
	// Function lock for update all stocks and allocations for variants in
	// given country and order by pk. Next, generate the dictionary
	// ({"stock_pk": "quantity_allocated"}) with actual allocated quantity for stocks.
	// Iterate by stocks and allocate as many items as needed or available in stock
	// for order line, until allocated all required quantity for the order line.
	// If there is less quantity in stocks then rise InsufficientStock exception.
	AllocateStocks(orderLineInfos order.OrderLineDatas, countryCode string, channelSlug string, manager interface{}, additionalFilterLookup model.StringInterface) (*exception.InsufficientStock, *model.AppError)
	// AllocatePreOrders allocates pre-order variant for given `order_lines` in given channel
	AllocatePreOrders(orderLinesInfo order.OrderLineDatas, channelSlun string) *model.AppError
	// AllocationsByOption returns all warehouse allocations filtered based on given option
	AllocationsByOption(transaction *gorp.Transaction, option *warehouse.AllocationFilterOption) ([]*warehouse.Allocation, *model.AppError)
	// BulkDeleteAllocations performs bulk delete given allocations.
	// If non-nil transaction is provided, perform bulk delete operation within it.
	BulkDeleteAllocations(transaction *gorp.Transaction, allocationIDs []string) *model.AppError
	// BulkUpsertAllocations upserts or inserts given allocations into database then returns them
	BulkUpsertAllocations(transaction *gorp.Transaction, allocations []*warehouse.Allocation) ([]*warehouse.Allocation, *model.AppError)
	// BulkUpsertStocks updates or insderts given stock based on its Id property
	BulkUpsertStocks(transaction *gorp.Transaction, stocks []*warehouse.Stock) ([]*warehouse.Stock, *model.AppError)
	// CheckPreorderThresholdBulk Validate if there is enough preordered variants according to thresholds.
	// :raises InsufficientStock: when there is not enough available items for a variant.
	CheckPreorderThresholdBulk(variants []*product_and_discount.ProductVariant, quantities []int, channelSlug string) (*exception.InsufficientStock, *model.AppError)
	// CheckStockAndPreorderQuantity Validate if there is stock/preorder available for given variant.
	// :raises InsufficientStock: when there is not enough items in stock for a variant
	// or there is not enough available preorder items for a variant.
	CheckStockAndPreorderQuantity(variant *product_and_discount.ProductVariant, countryCode string, channelSlug string, quantity int) (*exception.InsufficientStock, *model.AppError)
	// CheckStockAndPreorderQuantityBulk Validate if products are available for stocks/preorder.
	// :raises InsufficientStock: when there is not enough items in stock for a variant
	// or there is not enough available preorder items for a variant.
	//
	// `additionalFilterBoolup`, `existingLines` can be nil, replace default to false
	CheckStockAndPreorderQuantityBulk(variants []*product_and_discount.ProductVariant, countryCode string, quantities []int, channelSlug string, additionalFilterBoolup model.StringInterface, existingLines []*checkout.CheckoutLineInfo, replace bool) (*exception.InsufficientStock, *model.AppError)
	// DeAllocateStockForOrder Remove all allocations for given order
	DeAllocateStockForOrder(ord *order.Order, manager interface{}) *model.AppError
	// DeactivatePreorderForVariant Complete preorder for product variant.
	// All preorder settings should be cleared and all preorder allocations
	// should be replaced by regular allocations.
	DeactivatePreorderForVariant(productVariant *product_and_discount.ProductVariant) (*exception.PreorderAllocationError, *model.AppError)
	// DeallocateStock Deallocate stocks for given `order_lines`.
	//
	// Function lock for update stocks and allocations related to given `order_lines`.
	// Iterate over allocations sorted by `stock.pk` and deallocate as many items
	// as needed of available in stock for order line, until deallocated all required
	// quantity for the order line. If there is less quantity in stocks then
	// raise an exception.
	DeallocateStock(orderLineDatas []*order.OrderLineData, manager interface{}) (*warehouse.AllocationError, *model.AppError)
	// Decrease stocks quantities for given `order_lines` in given warehouses.
	//
	// Function deallocate as many quantities as requested if order_line has less quantity
	// from requested function deallocate whole quantity. Next function try to find the
	// stock in a given warehouse, if stock not exists or have not enough stock,
	// the function raise InsufficientStock exception. When the stock has enough quantity
	// function decrease it by given value.
	// If update_stocks is False, allocations will decrease but stocks quantities
	// will stay unmodified (case of unconfirmed order editing).
	// If allow_stock_to_be_exceeded flag is True then quantity could be < 0.
	//
	// updateStocks default to true
	DecreaseStock(orderLineInfos []*order.OrderLineData, manager interface{}, updateStocks bool, allowStockTobeExceeded bool) (*exception.InsufficientStock, *model.AppError)
	// DecreaseAllocations Decreate allocations for provided order lines.
	DecreaseAllocations(lineInfos []*order.OrderLineData, manager interface{}) (*exception.InsufficientStock, *model.AppError)
	// DeletePreorderAllocations tells store to delete given preorder allocations
	DeletePreorderAllocations(transaction *gorp.Transaction, preorderAllocationIDs ...string) *model.AppError
	// FilterStocksForChannel returns a slice of stocks that filtered using given options
	FilterStocksForChannel(option *warehouse.StockFilterForChannelOption) ([]*warehouse.Stock, *model.AppError)
	// FilterStocksForCountryAndChannel finds stocks by given options
	FilterStocksForCountryAndChannel(transaction *gorp.Transaction, options *warehouse.StockFilterForCountryAndChannel) ([]*warehouse.Stock, *model.AppError)
	// FindWarehousesForCountry returns a list of warehouses that are available in given country
	FindWarehousesForCountry(countryCode string) ([]*warehouse.WareHouse, *model.AppError)
	// GetOrderLinesWithPreOrder returns order lines with variants with preorder flag set to true
	GetOrderLinesWithPreOrder(orderLinesInfo order.OrderLineDatas) order.OrderLineDatas
	// GetOrderLinesWithTrackInventory Return order lines with variants with track inventory set to True
	GetOrderLinesWithTrackInventory(orderLineInfos []*order.OrderLineData) []*order.OrderLineData
	// GetProductStocksForCountryAndChannel
	GetProductStocksForCountryAndChannel(transaction *gorp.Transaction, options *warehouse.StockFilterForCountryAndChannel) ([]*warehouse.Stock, *model.AppError)
	// GetStockById takes options for filtering 1 stock
	GetStockById(stockID string) (*warehouse.Stock, *model.AppError)
	// GetVariantStocksForCountry Return the stock information about the a stock for a given country.
	//
	// Note it will raise a 'Stock.DoesNotExist' exception if no such stock is found.
	GetVariantStocksForCountry(transaction *gorp.Transaction, countryCode string, channelSlug string, variantID string) ([]*warehouse.Stock, *model.AppError)
	// IncreaseAllocations ncrease allocation for order lines with appropriate quantity
	IncreaseAllocations(lineInfos []*order.OrderLineData, channelSlug string, manager interface{}) (*exception.InsufficientStock, *model.AppError)
	// IncreaseStock Increse stock quantity for given `order_line` in a given warehouse.
	//
	// Function lock for update stock and allocations related to given `order_line`
	// in a given warehouse. If the stock exists, increase the stock quantity
	// by given value. If not exist create a stock with the given quantity. This function
	// can create the allocation for increased quantity in stock by passing True
	// to `allocate` argument. If the order line has the allocation in this stock
	// function increase `quantity_allocated`. If allocation does not exist function
	// create a new allocation for this order line in this stock.
	//
	// NOTE: allocate is default to false
	IncreaseStock(orderLine *order.OrderLine, wareHouse *warehouse.WareHouse, quantity int, allocate bool) *model.AppError
	// PreOrderAllocationsByOptions returns a list of preorder allocations filtered using given options
	PreOrderAllocationsByOptions(options *warehouse.PreorderAllocationFilterOption) (warehouse.PreorderAllocations, *model.AppError)
	// StockDecreaseQuantity Return given quantity of product to a stock.
	StockDecreaseQuantity(stockID string, quantity int) *model.AppError
	// StockIncreaseQuantity Return given quantity of product to a stock.
	StockIncreaseQuantity(stockID string, quantity int) *model.AppError
	// StocksByOption returns a list of stocks filtered using given options
	StocksByOption(transaction *gorp.Transaction, option *warehouse.StockFilterOption) (warehouse.Stocks, *model.AppError)
	// Validate if there is stock available for given variant in given country.
	//
	// If so - returns None. If there is less stock then required raise InsufficientStock
	// exception.
	CheckStockQuantity(variant *product_and_discount.ProductVariant, countryCode string, channelSlug string, quantity int) (*exception.InsufficientStock, *model.AppError)
	// Validate if there is stock available for given variants in given country.
	//
	// :raises InsufficientStock: when there is not enough items in stock for a variant
	CheckStockQuantityBulk(variants product_and_discount.ProductVariants, countryCode string, quantities []int, channelSlug string, additionalFilterLookup model.StringInterface, existingLines []*checkout.CheckoutLineInfo, replace bool) (*exception.InsufficientStock, *model.AppError)
	// ValidateWarehouseCount
	//	Every ShippingZone can be assigned to only one warehouse.
	//
	// If not there would be issue with automatically selecting stock for operation.
	ValidateWarehouseCount(shippingZones shipping.ShippingZones, instance *warehouse.WareHouse) (bool, *model.AppError)
	// WarehouseByOption returns a list of warehouses based on given option
	WarehousesByOption(option *warehouse.WarehouseFilterOption) ([]*warehouse.WareHouse, *model.AppError)
	// WarehouseByOption returns a warehouse filtered using given option
	WarehouseByOption(option *warehouse.WarehouseFilterOption) (*warehouse.WareHouse, *model.AppError)
	// WarehouseByStockID returns a warehouse that owns the given stock
	WarehouseByStockID(stockID string) (*warehouse.WareHouse, *model.AppError)
	// WarehouseCountries returns countries of given warehouse
	WarehouseCountries(warehouseID string) ([]string, *model.AppError)
}
