// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"github.com/site-name/decimal"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/app/order/types"
	"github.com/sitename/sitename/app/plugin/interfaces"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/store/store_iface"
)

// OrderService contains methods for working with orders
type OrderService interface {
	// AddGiftcardsToOrder
	AddGiftcardsToOrder(transaction store_iface.SqlxTxExecutor, checkoutInfo model.CheckoutInfo, orDer *model.Order, totalPriceLeft *goprices.Money, user *model.User, _ interface{}) *model.AppError
	// AddVariantToOrder Add total_quantity of variant to order.
	//
	// Returns an order line the variant was added to.
	AddVariantToOrder(orDer model.Order, variant model.ProductVariant, quantity int, user *model.User, _ interface{}, manager interfaces.PluginManagerInterface, discounts []*model.DiscountInfo, allocateStock bool) (*model.OrderLine, *model.InsufficientStock, *model.AppError)
	// AllDigitalOrderLinesOfOrder finds all order lines belong to given order, and are digital products
	AllDigitalOrderLinesOfOrder(orderID string) ([]*model.OrderLine, *model.AppError)
	// AnAddressOfOrder returns shipping address of given order if presents
	AnAddressOfOrder(orderID string, whichAddressID model.WhichOrderAddressID) (*model.Address, *model.AppError)
	// ApplyDiscountToValue Calculate the price based on the provided values
	ApplyDiscountToValue(value *decimal.Decimal, valueType string, currency string, priceToDiscount interface{}) (interface{}, error)
	// AutomaticallyFulfillDigitalLines
	// Fulfill all digital lines which have enabled automatic fulfillment setting. Send confirmation email afterward.
	AutomaticallyFulfillDigitalLines(ord model.Order, manager interfaces.PluginManagerInterface) (*model.InsufficientStock, *model.AppError)
	// BulkDeleteFulfillments tells store to delete fulfillments that satisfy given option
	BulkDeleteFulfillments(transaction store_iface.SqlxTxExecutor, fulfillments model.Fulfillments) *model.AppError
	// BulkUpsertFulfillmentLines performs bulk upsert given fulfillment lines and returns them
	BulkUpsertFulfillmentLines(transaction store_iface.SqlxTxExecutor, fulfillmentLines []*model.FulfillmentLine) ([]*model.FulfillmentLine, *model.AppError)
	// BulkUpsertOrderLines perform bulk upsert given order lines
	BulkUpsertOrderLines(transaction store_iface.SqlxTxExecutor, orderLines []*model.OrderLine) ([]*model.OrderLine, *model.AppError)
	// BulkUpsertOrders performs bulk upsert given orders
	BulkUpsertOrders(orders []*model.Order) ([]*model.Order, *model.AppError)
	// Calculate discount value depending on voucher and discount types.
	//
	// Raise NotApplicable if voucher of given type cannot be applied.
	GetVoucherDiscountForOrder(ord *model.Order) (result interface{}, notApplicableErr *model.NotApplicable, appErr *model.AppError)
	// CanMarkOrderAsPaid checks if given order can be marked as paid.
	CanMarkOrderAsPaid(ord *model.Order, payments []*model.Payment) (bool, *model.AppError)
	// CancelFulfillment Return products to corresponding stocks.
	CancelFulfillment(fulfillment model.Fulfillment, user *model.User, _ interface{}, warehouse *model.WareHouse, manager interfaces.PluginManagerInterface) (*model.Fulfillment, *model.AppError)
	// CancelOrder Release allocation of unfulfilled order items.
	CancelOrder(orDer *model.Order, user *model.User, _ interface{}, manager interfaces.PluginManagerInterface) *model.AppError
	// CancelWaitingFulfillment cancels fulfillments which is in waiting for approval state.
	CancelWaitingFulfillment(fulfillment model.Fulfillment, user *model.User, _ interface{}, manager interfaces.PluginManagerInterface) *model.AppError
	// ChangeOrderLineQuantity Change the quantity of ordered items in a order line.
	//
	// NOTE: userID can be empty
	ChangeOrderLineQuantity(transaction store_iface.SqlxTxExecutor, userID string, _ interface{}, lineInfo *model.OrderLineData, oldQuantity int, newQuantity int, channelSlug string, manager interfaces.PluginManagerInterface, sendEvent bool) (*model.InsufficientStock, *model.AppError)
	// CleanMarkOrderAsPaid Check if an order can be marked as paid.
	CleanMarkOrderAsPaid(ord *model.Order) (*model.PaymentError, *model.AppError)
	// CommonCreateOrderEvent is common method for creating desired order event instance
	CommonCreateOrderEvent(transaction store_iface.SqlxTxExecutor, option *model.OrderEventOption) (*model.OrderEvent, *model.AppError)
	// CreateGiftcardsWhenApprovingFulfillment
	CreateGiftcardsWhenApprovingFulfillment(orDer *model.Order, linesData []*model.OrderLineData, user *model.User, _ interface{}, manager interfaces.PluginManagerInterface, settings *model.Shop) *model.AppError
	// CreateOrderDiscountForOrder Add new order discount and update the prices
	CreateOrderDiscountForOrder(transaction store_iface.SqlxTxExecutor, ord *model.Order, reason string, valueType string, value *decimal.Decimal) (*model.OrderDiscount, *model.AppError)
	// CreateReplaceOrder Create draft order with lines to replace
	CreateReplaceOrder(user *model.User, _ interface{}, originalOrder model.Order, orderLinesToReplace []*model.OrderLineData, fulfillmentLinesToReplace []*model.FulfillmentLineData) (*model.Order, *model.AppError)
	// CustomerEmail try finding order's owner's email. If order has no user or error occured during the finding process, returns order's UserEmail property instead
	CustomerEmail(ord *model.Order) (string, *model.AppError)
	// DeleteFulfillmentLinesByOption tells store to delete fulfillment lines filtered by given option
	DeleteFulfillmentLinesByOption(transaction store_iface.SqlxTxExecutor, option *model.FulfillmentLineFilterOption) *model.AppError
	// DeleteOrderLine Delete an order line from an order.
	DeleteOrderLine(lineInfo *model.OrderLineData, manager interfaces.PluginManagerInterface) (*model.InsufficientStock, *model.AppError)
	// DeleteOrderLines perform bulk delete given order lines
	DeleteOrderLines(orderLineIDs []string) *model.AppError
	// FilterOrdersByOptions is common method for filtering orders by given option
	FilterOrdersByOptions(option *model.OrderFilterOption) ([]*model.Order, *model.AppError)
	// Fulfill order.
	//
	//	Function create fulfillments with lines.
	//	Next updates Order based on created fulfillments.
	//
	//	Args:
	//	    requester (User): Requester who trigger this action.
	//	    order (Order): Order to fulfill
	//	    fulfillment_lines_for_warehouses (Dict): Dict with information from which
	//	        system create fulfillments. Example:
	//	            {
	//	                (Warehouse.pk): [
	//	                    {
	//	                        "order_line": (OrderLine),
	//	                        "quantity": (int),
	//	                    },
	//	                    ...
	//	                ]
	//	            }
	//	    manager (PluginsManager): Base manager for handling plugins logic.
	//	    notify_customer (bool): If `True` system send email about
	//	        fulfillments to customer.
	//
	//	Return:
	//	    List[Fulfillment]: Fulfillmet with lines created for this order
	//	        based on information form `fulfillment_lines_for_warehouses`
	//
	//
	//	Raise:
	//	    InsufficientStock: If system hasn't containt enough item in stock for any line.
	CreateFulfillments(user *model.User, _ interface{}, orDer *model.Order, fulfillmentLinesForWarehouses map[string][]*model.QuantityOrderLine, manager interfaces.PluginManagerInterface, notifyCustomer bool, approved bool, allowStockTobeExceeded bool) ([]*model.Fulfillment, *model.InsufficientStock, *model.AppError)
	// FulfillOrderLines Fulfill order line with given quantity
	FulfillOrderLines(orderLineInfos []*model.OrderLineData, manager interfaces.PluginManagerInterface, allowStockTobeExceeded bool) (*model.InsufficientStock, *model.AppError)
	// FulfillmentByOption returns 1 fulfillment filtered using given options
	FulfillmentByOption(transaction store_iface.SqlxTxExecutor, option *model.FulfillmentFilterOption) (*model.Fulfillment, *model.AppError)
	// FulfillmentLinesByOption returns all fulfillment lines by option
	FulfillmentLinesByOption(option *model.FulfillmentLineFilterOption) (model.FulfillmentLines, *model.AppError)
	// FulfillmentTrackingUpdated
	FulfillmentTrackingUpdated(fulfillment *model.Fulfillment, user *model.User, _ interface{}, trackingNumber string, manager interfaces.PluginManagerInterface) *model.AppError
	// FulfillmentsByOption returns a list of fulfillments be given options
	FulfillmentsByOption(transaction store_iface.SqlxTxExecutor, option *model.FulfillmentFilterOption) (model.Fulfillments, *model.AppError)
	// Get prices of variants belonging to the discounted specific products.
	//
	// Specific products are products, collections and categories.
	// Product must be assigned directly to the discounted category, assigning
	// product to child category won't work
	GetPricesOfDiscountedSpecificProduct(orderLines []*model.OrderLine, voucher *model.Voucher) ([]*goprices.Money, *model.AppError)
	// GetDiscountedLines returns a list of discounted order lines, filterd from given orderLines
	GetDiscountedLines(orderLines []*model.OrderLine, voucher *model.Voucher) ([]*model.OrderLine, *model.AppError)
	// GetOrCreateFulfillment take a filtering option, trys finding a fulfillment with given option.
	// If a fulfillment found, returns it. Otherwise, creates a new one then returns it.
	GetOrCreateFulfillment(transaction store_iface.SqlxTxExecutor, option *model.FulfillmentFilterOption) (*model.Fulfillment, *model.AppError)
	// GetOrderCountry Return country to which order will be shipped
	GetOrderCountry(ord *model.Order) (model.CountryCode, *model.AppError)
	// GetOrderDiscounts Return all discounts applied to the order by staff user
	GetOrderDiscounts(ord *model.Order) ([]*model.OrderDiscount, *model.AppError)
	// GetProductsVoucherDiscountForOrder Calculate products discount value for a voucher, depending on its type.
	GetProductsVoucherDiscountForOrder(ord *model.Order) (*goprices.Money, *model.AppError)
	// GetTotalOrderDiscount Return total order discount assigned to the order
	GetTotalOrderDiscount(ord *model.Order) (*goprices.Money, *model.AppError)
	// GetValidShippingMethodsForOrder returns a list of valid shipping methods for given order
	GetValidShippingMethodsForOrder(ord *model.Order) ([]*model.ShippingMethod, *model.AppError)
	// HandleFullyPaidOrder
	//
	// user can be nil
	HandleFullyPaidOrder(manager interfaces.PluginManagerInterface, orDer model.Order, user *model.User, _ interface{}) (*model.InsufficientStock, *model.AppError)
	// Mark order as paid.
	//
	// Allows to create a payment for an order without actually performing any
	// payment by the gateway.
	//
	// externalReference can be empty
	MarkOrderAsPaid(orDer model.Order, requestUser *model.User, _ interface{}, manager interfaces.PluginManagerInterface, externalReference string) (*model.PaymentError, *model.AppError)
	// OrderAuthorized
	OrderAuthorized(ord model.Order, user *model.User, _ interface{}, amount *decimal.Decimal, payMent model.Payment, manager interfaces.PluginManagerInterface) *model.AppError
	// OrderAwaitsFulfillmentApproval
	OrderAwaitsFulfillmentApproval(fulfillments []*model.Fulfillment, user *model.User, _ interface{}, fulfillmentLines model.FulfillmentLines, manager interfaces.PluginManagerInterface, notifyCustomer bool) *model.AppError
	// OrderById retuns an order with given id
	OrderById(id string) (*model.Order, *model.AppError)
	// OrderCanCalcel checks if given order can be canceled
	OrderCanCancel(ord *model.Order) (bool, *model.AppError)
	// OrderCanCapture
	OrderCanCapture(ord *model.Order, payment *model.Payment) (bool, *model.AppError)
	// OrderCanRefund checks if order can refund
	OrderCanRefund(ord *model.Order, payment *model.Payment) (bool, *model.AppError)
	// OrderCanVoid
	OrderCanVoid(ord *model.Order, payment *model.Payment) (bool, *model.AppError)
	// OrderCaptured
	OrderCaptured(ord model.Order, user *model.User, _ interface{}, amount *decimal.Decimal, payMent model.Payment, manager interfaces.PluginManagerInterface) (*model.InsufficientStock, *model.AppError)
	// OrderConfirmed Trigger event, plugin hooks and optionally confirmation email.
	OrderConfirmed(ord model.Order, user *model.User, _ interface{}, manager interfaces.PluginManagerInterface, sendConfirmationEmail bool) *model.AppError
	// OrderCreated. `fromDraft` is default to false
	OrderCreated(ord model.Order, user *model.User, _ interface{}, manager interfaces.PluginManagerInterface, fromDraft bool) (*model.InsufficientStock, *model.AppError)
	// OrderFulfilled
	OrderFulfilled(fulfillments []*model.Fulfillment, user *model.User, _ interface{}, fulfillmentLines []*model.FulfillmentLine, manager interfaces.PluginManagerInterface, notifyCustomer bool) *model.AppError
	// OrderIsCaptured checks if given order is captured
	OrderIsCaptured(orderID string) (bool, *model.AppError)
	// OrderIsPreAuthorized checks if order is pre-authorized
	OrderIsPreAuthorized(orderID string) (bool, *model.AppError)
	// OrderLineById returns an order line byt given orderLineID
	OrderLineById(orderLineID string) (*model.OrderLine, *model.AppError)
	// OrderLineIsDigital Check if a variant is digital and contains digital content.
	OrderLineIsDigital(orderLine *model.OrderLine) (bool, *model.AppError)
	// OrderLineNeedsAutomaticFulfillment Check if given line is digital and should be automatically fulfilled.
	//
	// NOTE: before calling this, caller can attach related data into `orderLine` so this function does not have to call the database
	OrderLineNeedsAutomaticFulfillment(orderLine *model.OrderLine) (bool, *model.AppError)
	// OrderLinesByOption returns a list of order lines by given option
	OrderLinesByOption(option *model.OrderLineFilterOption) (model.OrderLines, *model.AppError)
	// OrderNeedsAutomaticFulfillment checks if given order has digital products which shoul be automatically fulfilled.
	OrderNeedsAutomaticFulfillment(ord model.Order) (bool, *model.AppError)
	// OrderRefunded
	OrderRefunded(ord model.Order, user *model.User, _ interface{}, amount decimal.Decimal, payMent model.Payment, manager interfaces.PluginManagerInterface) *model.AppError
	// OrderReturned
	OrderReturned(transaction store_iface.SqlxTxExecutor, ord model.Order, user *model.User, _ interface{}, returnedLines []*model.QuantityOrderLine) *model.AppError
	// OrderShippingIsRequired returns a boolean value indicating that given order requires shipping or not
	OrderShippingIsRequired(orderID string) (bool, *model.AppError)
	// OrderShippingUpdated
	OrderShippingUpdated(ord model.Order, manager interfaces.PluginManagerInterface) *model.AppError
	// OrderSubTotal returns sum of TotalPrice of all order lines that belong to given order
	OrderSubTotal(ord *model.Order) (*goprices.TaxedMoney, *model.AppError)
	// OrderTotalAuthorized returns order's total authorized amount
	OrderTotalAuthorized(ord *model.Order) (*goprices.Money, *model.AppError)
	// OrderTotalQuantity return total quantity of given order
	OrderTotalQuantity(orderID string) (int, *model.AppError)
	// OrderVoided
	OrderVoided(ord model.Order, user *model.User, _ interface{}, payMent *model.Payment, manager interfaces.PluginManagerInterface) *model.AppError
	// Proceed with all steps required for refunding products.
	//
	// Calculate refunds for products based on the order's lines and fulfillment
	// lines.  The logic takes the list of order lines, fulfillment lines, and their
	// quantities which is used to create the refund fulfillment. The stock for
	// unfulfilled lines will be deallocated.
	//
	// NOTE: `refundShippingCosts` default to false
	CreateRefundFulfillment(requester *model.User, _ interface{}, ord model.Order, payMent model.Payment, orderLinesToRefund []*model.OrderLineData, fulfillmentLinesToRefund []*model.FulfillmentLineData, manager interfaces.PluginManagerInterface, amount *decimal.Decimal, refundShippingCosts bool) (interface{}, *model.PaymentError, *model.AppError)
	// Process the request for replacing or returning the products.
	//
	// Process the refund when the refund is set to True. The amount of refund will be
	// calculated for all lines with statuses different from refunded.  The lines which
	// are set to replace will not be included in the refund amount.
	//
	// If the amount is provided, the refund will be used for this amount.
	//
	// If refund_shipping_costs is True, the calculated refund amount will include
	// shipping costs.
	//
	// All lines with replace set to True will be used to create a new draft order, with
	// the same order details as the original order.  These lines will be moved to
	// fulfillment with status replaced. The events with relation to new order will be
	// created.
	//
	// All lines with replace set to False will be moved to fulfillment with status
	// returned/refunded_and_returned - depends on refund flag and current line status.
	// If the fulfillment line has refunded status it will be moved to
	// returned_and_refunded
	//
	// NOTE: `payMent`, `amount` , `user` are optional.
	//
	// `refund` and `refundShippingCosts` default to false.
	CreateFulfillmentsForReturnedProducts(user *model.User, _ interface{}, ord model.Order, payMent *model.Payment, orderLineDatas []*model.OrderLineData, fulfillmentLineDatas []*model.FulfillmentLineData, manager interfaces.PluginManagerInterface, refund bool, amount *decimal.Decimal, refundShippingCosts bool) (*model.Fulfillment, *model.Fulfillment, *model.Order, *model.PaymentError, *model.AppError)
	// ProcessReplace Create replace fulfillment and new draft order.
	//
	// Move all requested lines to fulfillment with status replaced. Based on original
	// order create the draft order with all user details, and requested lines.
	ProcessReplace(requester *model.User, ord model.Order, orderLineDatas []*model.OrderLineData, fulfillmentLineDatas []*model.FulfillmentLineData, manager interfaces.PluginManagerInterface) (*model.Fulfillment, *model.Order, *model.AppError)
	// ReCalculateOrderWeight
	ReCalculateOrderWeight(transaction store_iface.SqlxTxExecutor, ord *model.Order) *model.AppError
	// Recalculate all order discounts assigned to order.
	//
	// It returns the list of tuples which contains order discounts where the amount has been changed.
	RecalculateOrderDiscounts(transaction store_iface.SqlxTxExecutor, ord *model.Order) ([][2]*model.OrderDiscount, *model.AppError)
	// Recalculate and assign total price of order.
	//
	// Total price is a sum of items in order and order shipping price minus
	// discount amount.
	//
	// Voucher discount amount is recalculated by default. To avoid this, pass
	// update_voucher_discount argument set to False.
	//
	// NOTE: `kwargs` can be nil
	RecalculateOrder(transaction store_iface.SqlxTxExecutor, ord *model.Order, kwargs map[string]interface{}) *model.AppError
	// RemoveDiscountFromOrderLine Drop discount applied to order line. Restore undiscounted price
	RemoveDiscountFromOrderLine(orderLine model.OrderLine, ord model.Order, manager interfaces.PluginManagerInterface, taxIncluded bool) *model.AppError
	// RemoveOrderDiscountFromOrder Remove the order discount from order and update the prices.
	RemoveOrderDiscountFromOrder(transaction store_iface.SqlxTxExecutor, ord *model.Order, orderDiscount *model.OrderDiscount) *model.AppError
	// RestockFulfillmentLines Return fulfilled products to corresponding stocks.
	//
	// Return products to stocks and update order lines quantity fulfilled values.
	RestockFulfillmentLines(transaction store_iface.SqlxTxExecutor, fulfillment *model.Fulfillment, warehouse *model.WareHouse) (appErr *model.AppError)
	// RestockOrderLines Return ordered products to corresponding stocks
	RestockOrderLines(ord *model.Order, manager interfaces.PluginManagerInterface) *model.AppError
	// SendFulfillmentConfirmationToCustomer
	//
	// NOTE: user can be nil
	SendFulfillmentConfirmationToCustomer(orDer *model.Order, fulfillment *model.Fulfillment, user *model.User, _, manager interfaces.PluginManagerInterface) *model.AppError
	// SendOrderConfirmation sends notification with order confirmation
	SendOrderConfirmation(orDer *model.Order, redirectURL string, manager interfaces.PluginManagerInterface) *model.AppError
	// SendOrderConfirmed Send email which tells customer that order has been confirmed
	SendOrderConfirmed(orDer model.Order, user *model.User, _ interface{}, manager interfaces.PluginManagerInterface)
	// SendPaymentConfirmation sends notification with the payment confirmation
	SendPaymentConfirmation(orDer model.Order, manager interfaces.PluginManagerInterface) *model.AppError
	// SetGiftcardUser Set user when the gift card is used for the first time.
	SetGiftcardUser(giftCard *model.GiftCard, usedByUser *model.User, usedByEmail string)
	// UpdateDiscountForOrderLine Update discount fields for order line. Apply discount to the price
	//
	// `reason`, `valueType` can be empty. `value` can be nil
	UpdateDiscountForOrderLine(orderLine model.OrderLine, ord model.Order, reason string, valueType string, value *decimal.Decimal, manager interfaces.PluginManagerInterface, taxIncluded bool) *model.AppError
	// UpdateOrderDiscountForOrder Update the order_discount for an order and recalculate the order's prices
	//
	// `reason`, `valueType` and `value` can be nil
	UpdateOrderDiscountForOrder(transaction store_iface.SqlxTxExecutor, ord *model.Order, orderDiscountToUpdate *model.OrderDiscount, reason string, valueType string, value *decimal.Decimal) *model.AppError
	// UpdateOrderPrices Update prices in order with given discounts and proper taxes.
	UpdateOrderPrices(ord model.Order, manager interfaces.PluginManagerInterface, taxIncluded bool) *model.AppError
	// UpdateOrderStatus Update order status depending on fulfillments
	UpdateOrderStatus(transaction store_iface.SqlxTxExecutor, ord model.Order) *model.AppError
	// UpdateOrderTotalPaid update given order's total paid amount
	UpdateOrderTotalPaid(transaction store_iface.SqlxTxExecutor, orDer *model.Order) *model.AppError
	// UpdateVoucherDiscount Recalculate order discount amount based on order voucher
	UpdateVoucherDiscount(fun types.RecalculateOrderPricesFunc) types.RecalculateOrderPricesFunc
	// UpsertFulfillment performs some actions then save given fulfillment
	UpsertFulfillment(transaction store_iface.SqlxTxExecutor, fulfillment *model.Fulfillment) (*model.Fulfillment, *model.AppError)
	// UpsertOrder depends on given order's Id property to decide update/save it
	UpsertOrder(transaction store_iface.SqlxTxExecutor, ord *model.Order) (*model.Order, *model.AppError)
	// UpsertOrderLine depends on given orderLine's Id property to decide update order save it
	UpsertOrderLine(transaction store_iface.SqlxTxExecutor, orderLine *model.OrderLine) (*model.OrderLine, *model.AppError)
	ApproveFulfillment(fulfillment *model.Fulfillment, user *model.User, _ interface{}, manager interfaces.PluginManagerInterface, settings *model.Shop, notifyCustomer bool, allowStockTobeExceeded bool) (*model.Fulfillment, *model.InsufficientStock, *model.AppError)
	CreateOrderEvent(transaction store_iface.SqlxTxExecutor, orderLine *model.OrderLine, userID string, quantityDiff int) *model.AppError
	CreateReturnFulfillment(requester *model.User, ord model.Order, orderLineDatas []*model.OrderLineData, fulfillmentLineDatas []*model.FulfillmentLineData, totalRefundAmount *decimal.Decimal, shippingRefundAmount *decimal.Decimal, manager interfaces.PluginManagerInterface) (*model.Fulfillment, *model.AppError)
	DraftOrderCreatedFromReplaceEvent(transaction store_iface.SqlxTxExecutor, draftOrder model.Order, originalOrder model.Order, user *model.User, _ interface{}, lines []*model.QuantityOrderLine) (*model.OrderEvent, *model.AppError)
	FilterOrderEventsByOptions(options *model.OrderEventFilterOptions) ([]*model.OrderEvent, *model.AppError)
	FulfillmentAwaitsApprovalEvent(transaction store_iface.SqlxTxExecutor, orDer *model.Order, user *model.User, _ interface{}, fulfillmentLines model.FulfillmentLines) (*model.OrderEvent, *model.AppError)
	FulfillmentCanceledEvent(transaction store_iface.SqlxTxExecutor, orDer *model.Order, user *model.User, _ interface{}, fulfillment *model.Fulfillment) (*model.OrderEvent, *model.AppError)
	FulfillmentFulfilledItemsEvent(transaction store_iface.SqlxTxExecutor, orDer *model.Order, user *model.User, _ interface{}, fulfillmentLines model.FulfillmentLines) (*model.OrderEvent, *model.AppError)
	FulfillmentReplacedEvent(transaction store_iface.SqlxTxExecutor, orDer model.Order, user *model.User, _ interface{}, replacedLines []*model.QuantityOrderLine) (*model.OrderEvent, *model.AppError)
	FulfillmentTrackingUpdatedEvent(orDer *model.Order, user *model.User, _ interface{}, trackingNumber string, fulfillment *model.Fulfillment) (*model.OrderEvent, *model.AppError)
	GetValidCollectionPointsForOrder(lines model.OrderLines, addressCountryCode model.CountryCode) (model.Warehouses, *model.AppError)
	GetVoucherDiscountAssignedToOrder(ord *model.Order) (*model.OrderDiscount, *model.AppError)
	MatchOrdersWithNewUser(user *model.User) *model.AppError
	OrderConfirmedEvent(orDer model.Order, user *model.User, _ interface{}) (*model.OrderEvent, *model.AppError)
	OrderCreatedEvent(orDer model.Order, user *model.User, _ interface{}, fromDraft bool) (*model.OrderEvent, *model.AppError)
	OrderDiscountAutomaticallyUpdatedEvent(transaction store_iface.SqlxTxExecutor, ord *model.Order, orderDiscount *model.OrderDiscount, oldOrderDiscount *model.OrderDiscount) (*model.OrderEvent, *model.AppError)
	OrderDiscountEvent(transaction store_iface.SqlxTxExecutor, eventType model.OrderEventType, ord *model.Order, user *model.User, orderDiscount *model.OrderDiscount, oldOrderDiscount *model.OrderDiscount) (*model.OrderEvent, *model.AppError)
	OrderDiscountsAutomaticallyUpdatedEvent(transaction store_iface.SqlxTxExecutor, ord *model.Order, changedOrderDiscounts [][2]*model.OrderDiscount) *model.AppError
	OrderLineDiscountEvent(eventType model.OrderEventType, ord *model.Order, user *model.User, line *model.OrderLine, lineBeforeUpdate *model.OrderLine) (*model.OrderEvent, *model.AppError)
	OrderManuallyMarkedAsPaidEvent(transaction store_iface.SqlxTxExecutor, orDer model.Order, user *model.User, _ interface{}, transactionReference string) (*model.OrderEvent, *model.AppError)
	OrderReplacementCreated(transaction store_iface.SqlxTxExecutor, originalOrder model.Order, replaceOrder *model.Order, user *model.User, _ interface{}) (*model.OrderEvent, *model.AppError)
	SendOrderCancelledConfirmation(orDer *model.Order, user *model.User, _, manager interfaces.PluginManagerInterface) *model.AppError
	SendOrderRefundedConfirmation(orDer model.Order, user *model.User, _ interface{}, amount decimal.Decimal, currency string, manager interfaces.PluginManagerInterface) *model.AppError
	SumOrderTotals(orders []*model.Order, currencyCode string) (*goprices.TaxedMoney, *model.AppError)
	UpdateGiftcardBalance(giftCard *model.GiftCard, totalPriceLeft *goprices.Money) model.BalanceObject
	UpdateTaxesForOrderLine(line model.OrderLine, ord model.Order, manager interfaces.PluginManagerInterface, taxIncluded bool) *model.AppError
	UpdateTaxesForOrderLines(lines model.OrderLines, ord model.Order, manager interfaces.PluginManagerInterface, taxIncludeed bool) *model.AppError
	/* Check if the given order contains the proper data.
    - Has proper customer data,
    - Shipping address and method are set up,
    - Product variants for order lines still exists in database.
    - Product variants are available in requested quantity.
    - Product variants are published.

    Returns a list of errors if any were found.*/
	ValidateDraftOrder(order *model.Order) *model.AppError
}
