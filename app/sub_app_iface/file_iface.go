// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"io"
	"time"

	"github.com/sitename/sitename/app/imaging"
	"github.com/sitename/sitename/app/request"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/model/file"
	"github.com/sitename/sitename/modules/filestore"
)

// FileService contains methods for working with files
type FileService interface {
	// Caller must close the first return value
	FileReader(path string) (filestore.ReadCloseSeeker, *model.AppError)
	// FileBackend returns filebackend of the system
	FileBackend() (filestore.FileBackend, *model.AppError)
	// FileExists checks if given path exists
	FileExists(path string) (bool, *model.AppError)
	// FileModTime get last modification time of given path
	FileModTime(path string) (time.Time, *model.AppError)
	// FileSize checks size of given path
	FileSize(path string) (int64, *model.AppError)
	// GetFileInfo get fileInfo object from database with given fileID, populates its "MiniPreview" and returns it.
	GetFileInfos(page, perPage int, opt *file.GetFileInfosOptions) ([]*file.FileInfo, *model.AppError)
	// ImageDecoder retutns image encoder
	ImageDecoder() *imaging.Decoder
	// ImageEncoder returns image encoder
	ImageEncoder() *imaging.Encoder
	// MoveFile moves file from given oldPath to newPath
	MoveFile(oldPath, newPath string) *model.AppError
	// ReadFile read file content from given path
	ReadFile(path string) ([]byte, *model.AppError)
	// TestFileStoreConnection test if connection to file backend server is good
	TestFileStoreConnection() *model.AppError
	// TestFileStoreConnectionWithConfig test file backend connection with config
	TestFileStoreConnectionWithConfig(settings *model.FileSettings) *model.AppError
	// This function zip's up all the files in fileDatas array and then saves it to the directory specified with the specified zip file name
	// Ensure the zip file name ends with a .zip
	CreateZipFileAndAddFiles(fileBackend filestore.FileBackend, fileDatas []model.FileData, zipFileName, directory string) error
	// UploadFileX uploads a single file as specified in t. It applies the upload
	// constraints, executes plugins and image processing logic as needed. It
	// returns a filled-out FileInfo and an optional error. A plugin may reject the
	// upload, returning a rejection error. In this case FileInfo would have
	// contained the last "good" FileInfo before the execution of that plugin.
	UploadFileX(c *request.Context, channelID, name string, input io.Reader, userID *string, timestamp *time.Time, contentLength *int64, clientID *string, raw *bool) (*file.FileInfo, *model.AppError)
	AppendFile(fr io.Reader, path string) (int64, *model.AppError)
	CheckMandatoryS3Fields(settings *model.FileSettings) *model.AppError
	CopyFileInfos(userID string, fileIDs []string) ([]string, *model.AppError)
	DoUploadFile(c *request.Context, now time.Time, rawTeamId string, rawChannelId string, rawUserId string, rawFilename string, data []byte) (*file.FileInfo, *model.AppError)
	DoUploadFileExpectModification(c *request.Context, now time.Time, rawTeamId string, rawChannelId string, rawUserId string, rawFilename string, data []byte) (*file.FileInfo, []byte, *model.AppError)
	DownloadFromURL(downloadURL string) ([]byte, error)
	ExtractContentFromFileInfo(fileInfo *file.FileInfo) error
	GeneratePublicLink(siteURL string, info *file.FileInfo) string
	GetFile(fileID string) ([]byte, *model.AppError)
	GetFileInfo(fileID string) (*file.FileInfo, *model.AppError)
	GetUploadSession(uploadId string) (*file.UploadSession, *model.AppError)
	GetUploadSessionsForUser(userID string) ([]*file.UploadSession, *model.AppError)
	HandleImages(previewPathList []string, thumbnailPathList []string, fileData [][]byte)
	ListDirectory(path string) ([]string, *model.AppError)
	RemoveDirectory(path string) *model.AppError
	RemoveFile(path string) *model.AppError
	UploadData(c *request.Context, us *file.UploadSession, rd io.Reader) (*file.FileInfo, *model.AppError)
	WriteFile(fr io.Reader, path string) (int64, *model.AppError)
}
