// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"bytes"
	"context"
	"io"
	"mime/multipart"
	"net/http"

	"github.com/sitename/sitename/app/plugin/interfaces"
	"github.com/sitename/sitename/app/request"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/model/account"
	"github.com/sitename/sitename/model/order"
	"github.com/sitename/sitename/store"
)

// AccountService contains methods for working with accounts
type AccountService interface {
	// AddSessionToCache add given session `s` to server's sessionCache, key is session's Token, expiry time as in config
	AddSessionToCache(s *model.Session)
	// AddUserAddress add 1 user-address relation to database then returns it
	AddUserAddress(relation *account.UserAddress) (*account.UserAddress, *model.AppError)
	// AddressDeleteForUser just remove the relationship between user and address. Address still exist
	AddressDeleteForUser(userID, addressID string) *model.AppError
	// AddressesByOption returns a list of addresses by given option
	AddressesByOption(option *account.AddressFilterOption) ([]*account.Address, *model.AppError)
	// AttachSessionCookies sets:
	//
	// 1) session cookie with value of given s's session's token to given w
	//
	// 2) user cookie with value of user id
	//
	// 3) csrf cookie with value of csrf in session
	AttachSessionCookies(c *request.Context, w http.ResponseWriter, r *http.Request)
	// AuthenticateUserForLogin
	AuthenticateUserForLogin(c *request.Context, id, loginId, password, mfaToken, cwsToken string, ldapOnly bool) (user *account.User, err *model.AppError)
	// ChangeUserDefaultAddress set default address for given user
	ChangeUserDefaultAddress(user account.User, address account.Address, addressType string, manager interfaces.PluginManagerInterface) *model.AppError
	// CheckForClientSideCert checks request's header's `X-SSL-Client-Cert` and `X-SSL-Client-Cert-Subject-DN` keys
	CheckForClientSideCert(r *http.Request) (string, string, string)
	// CheckPasswordAndAllCriteria
	CheckPasswordAndAllCriteria(user *account.User, password string, mfaToken string) *model.AppError
	// CheckRolesExist get role model instances with given roleNames,
	// checks if at least one db role has name contained in given roleNames.
	CheckRolesExist(roleNames []string) *model.AppError
	// CheckUserMfa checks
	//
	// 1) if given user's `MfaActive` is false || multi factor authentication is not enabled => return nil
	//
	// 2) multi factor authentication is not enabled => return non-nil error
	//
	// 3) validates user's `MfaSecret` and given token, if error occur or not valid => return concret error
	CheckUserMfa(user *account.User, token string) *model.AppError
	// CheckUserPassword compares user's password to given password. If they dont match, return an error
	CheckUserPassword(user *account.User, password string) *model.AppError
	// CheckUserPostflightAuthenticationCriteria checks if:
	//
	// Given user's `EmailVerified` attribute is false && email verification is required,
	// Then it return an error.
	CheckUserPostflightAuthenticationCriteria(user *account.User) *model.AppError
	// CheckUserPreflightAuthenticationCriteria checks:
	//
	// 1) user is not disabled
	//
	// 2) numbers of failed logins is not exceed the limit
	CheckUserPreflightAuthenticationCriteria(user *account.User, mfaToken string) *model.AppError
	// ClearAllUsersSessionCacheLocal purges current `*ServiceAccount` sessionCache
	ClearAllUsersSessionCacheLocal()
	// ClearSessionCacheForUser clears all sessions that have `UserID` attribute of given `userID` in server's `sessionCache`
	ClearSessionCacheForUser(userID string)
	// ClearSessionCacheForUserSkipClusterSend iterates through server's sessionCache, if it finds any session belong to given userID, removes that session.
	ClearSessionCacheForUserSkipClusterSend(userID string)
	// CopyAddress inserts a new address with fields identical to given address except Id field.
	CopyAddress(address *account.Address) (*account.Address, *model.AppError)
	// CreateRole takes a role struct and save it to database
	CreateRole(role *model.Role) (*model.Role, *model.AppError)
	// CreateSession try saving given session to the database. If success then add that session to cache.
	CreateSession(session *model.Session) (*model.Session, *model.AppError)
	// CustomerEventsByUser returns customer events belong to given user
	CustomerEventsByUser(userID string) ([]*account.CustomerEvent, *model.AppError)
	// CustomerPlacedOrderEvent creates an customer event, if given user is not valid, it returns immediately.
	CustomerPlacedOrderEvent(user *account.User, orDer order.Order) (*account.CustomerEvent, *model.AppError)
	// DeleteUserAddressRelation deletes 1 user-address relation from database
	DeleteUserAddressRelation(userID, addressID string) *model.AppError
	// DoubleCheckPassword performs:
	//
	// 1) check if number of failed login is not exceed the limit. If yes returns an error
	//
	// 2) check if user's password and given password don't match, update number of attempts failed in database, return an error
	//
	// otherwise: set number of failed attempts to 0
	DoubleCheckPassword(user *account.User, password string) *model.AppError
	// ExtendSessionExpiryIfNeeded extends Session.ExpiresAt based on session lengths in config.
	// A new ExpiresAt is only written if enough time has elapsed since last update.
	// Returns true only if the session was extended.
	ExtendSessionExpiryIfNeeded(session *model.Session) bool
	// FilterUserAddressRelations finds and returns a list of user-address relations with given options
	FilterUserAddressRelations(options *account.UserAddressFilterOptions) ([]*account.UserAddress, *model.AppError)
	// GetRole get 1 model.Role from database, returns nil and concret error if a problem occur
	GetRole(id string) (*model.Role, *model.AppError)
	// GetRoleByName gets a model.Role from database with given name, returns nil and concret error if a problem occur
	GetRoleByName(ctx context.Context, name string) (*model.Role, *model.AppError)
	// GetRolesByNames returns a slice of model.Role by given names
	GetRolesByNames(names []string) ([]*model.Role, *model.AppError)
	// GetSessionLengthInMillis returns the session length, in milliseconds,
	// based on the type of session (Mobile, SSO, Web/LDAP).
	GetSessionLengthInMillis(session *model.Session) int64
	// GetSessions get session from database with UserID attribute of given `userID`
	GetSessions(userID string) ([]*model.Session, *model.AppError)
	// GetUserForLogin
	GetUserForLogin(id, loginId string) (*account.User, *model.AppError)
	// HasPermissionTo checks if an user with Id of `askingUserId` has permission of given permission
	HasPermissionTo(askingUserId string, permission *model.Permission) bool
	// HasPermissionToUser checks if an user with Id of `askingUserId` has permission to modify another user with Id of given `userID`
	HasPermissionToUser(askingUserId string, userID string) bool
	// InvalidateCacheForUser invalidates cache for given user
	InvalidateCacheForUser(userID string)
	// RevokeAllSessions get sessions from database that has UserID of given userID, then removes them
	RevokeAllSessions(userID string) *model.AppError
	// RevokeSession removes session from database
	RevokeSession(session *model.Session) *model.AppError
	// RevokeSessionById gets session with given sessionID then revokes it
	RevokeSessionById(sessionID string) *model.AppError
	// RolesGrantPermission gets all model.Role with given roleNames.
	// Then checks if one of these model.Role satisfies:
	//
	// 1) Not deleted
	//
	// 2) one item in the role's Permissions is equal to given permissionId
	RolesGrantPermission(roleNames []string, permissionId string) bool
	// SendAccountDeleteConfirmationNotification Trigger sending a account delete notification for the given user
	SendAccountDeleteConfirmationNotification(redirectUrl string, user account.User, manager interfaces.PluginManagerInterface, channelID string) *model.AppError
	// SessionHasPermissionTo checks if this user has given permission to procceed
	SessionHasPermissionTo(session *model.Session, permission *model.Permission) bool
	// SessionHasPermissionToAll checks if given session has all given permissions
	SessionHasPermissionToAll(session *model.Session, permissions ...*model.Permission) bool
	// SessionHasPermissionToAny checks if current user has atleast one of given permissions
	SessionHasPermissionToAny(session *model.Session, permissions ...*model.Permission) bool
	// SessionHasPermissionToUser checks if current user has permission to perform modifications to another user with Id of given userID
	SessionHasPermissionToUser(session *model.Session, userID string) bool
	// SetSessionExpireInDays sets the session's expiry the specified number of days
	// relative to either the session creation date or the current time, depending
	// on the `ExtendSessionOnActivity` config setting.
	SetSessionExpireInDays(session *model.Session, days int)
	// SetUserDefaultBillingAddress sets default billing address for given user
	SetUserDefaultBillingAddress(user *account.User, defaultBillingAddressID string) *model.AppError
	// SetUserDefaultShippingAddress sets default shipping address for given user
	SetUserDefaultShippingAddress(user *account.User, defaultShippingAddressID string) *model.AppError
	// StoreUserAddress Add address to user address book and set as default one.
	StoreUserAddress(user *account.User, address account.Address, addressType string, manager interfaces.PluginManagerInterface) *model.AppError
	// Trigger sending a email change notification for the given user
	SendUserChangeEmailNotification(recipientEmail string, user account.User, manager interfaces.PluginManagerInterface, channelID string) *model.AppError
	// Trigger sending a notification change email for the given user
	SendRequestUserChangeEmailNotification(redirectUrl string, user account.User, newEmail string, token string, manager interfaces.PluginManagerInterface, channelID string) *model.AppError
	// Trigger sending a password reset notification for the given customer/staff.
	SendPasswordResetNotification(redirectURL string, user account.User, manager interfaces.PluginManagerInterface, channelID string) *model.AppError
	// Trigger sending a set password notification for the given customer/staff.
	SendSetPasswordNotification(redirectUrl string, user account.User, manager interfaces.PluginManagerInterface, channelID string) *model.AppError
	// Trigger sending an account confirmation notification for the given user
	SendAccountConfirmation(redirectUrl string, user account.User, manager interfaces.PluginManagerInterface, channelID string) *model.AppError
	// UpsertAddress depends on given address's Id to decide update or insert it
	UpsertAddress(transaction store.SqlxTxExecutor, address *account.Address) (*account.Address, *model.AppError)
	// UserByOrderId returns an user who owns given order
	UserByOrderId(orderID string) (*account.User, *model.AppError)
	ActivateMfa(userID, token string) *model.AppError
	AddStatusCache(status *account.Status)
	AddStatusCacheSkipClusterSend(status *account.Status)
	AddressById(id string) (*account.Address, *model.AppError)
	AddressesByUserId(userID string) ([]*account.Address, *model.AppError)
	AdjustImage(file io.Reader) (*bytes.Buffer, *model.AppError)
	AttachDeviceId(sessionID string, deviceID string, expiresAt int64) *model.AppError
	BroadcastStatus(status *account.Status)
	CheckProviderAttributes(user *account.User, patch *account.UserPatch) string
	CheckUserAllAuthenticationCriteria(user *account.User, mfaToken string) *model.AppError
	ClearUserSessionCacheLocal(userID string)
	CommonCustomerCreateEvent(userID *string, orderID *string, eventType string, params model.StringInterface) (*account.CustomerEvent, *model.AppError)
	CreatePasswordRecoveryToken(userID, eMail string) (*model.Token, *model.AppError)
	CreateUser(c *request.Context, user *account.User) (*account.User, *model.AppError)
	CreateUserAccessToken(token *account.UserAccessToken) (*account.UserAccessToken, *model.AppError)
	CreateUserAsAdmin(c *request.Context, user *account.User, redirect string) (*account.User, *model.AppError)
	CreateUserFromSignup(c *request.Context, user *account.User, redirect string) (*account.User, *model.AppError)
	CreateUserWithToken(c *request.Context, user *account.User, token *model.Token) (*account.User, *model.AppError)
	DeactivateMfa(userID string) *model.AppError
	DeleteAddresses(addressIDs ...string) *model.AppError
	DeletePreferences(userID string, preferences model.Preferences) *model.AppError
	DeleteToken(token *model.Token) *model.AppError
	DisableUserAccessToken(token *account.UserAccessToken) *model.AppError
	DoLogin(c *request.Context, w http.ResponseWriter, r *http.Request, user *account.User, deviceID string, isMobile, isOAuthUser, isSaml bool) *model.AppError
	EnableUserAccessToken(token *account.UserAccessToken) *model.AppError
	GenerateMfaSecret(userID string) (*model.MfaSecret, *model.AppError)
	GetCloudSession(token string) (*model.Session, *model.AppError)
	GetDefaultProfileImage(user *account.User) ([]byte, *model.AppError)
	GetDefaultUserPayload(user *account.User) model.StringInterface
	GetFilteredUsersStats(options *account.UserCountOptions) (*account.UsersStats, *model.AppError)
	GetPasswordRecoveryToken(token string) (*model.Token, *model.AppError)
	GetPreferenceByCategoryAndNameForUser(userID string, category string, preferenceName string) (*model.Preference, *model.AppError)
	GetPreferenceByCategoryForUser(userID string, category string) (model.Preferences, *model.AppError)
	GetPreferencesForUser(userID string) (model.Preferences, *model.AppError)
	GetProfileImage(user *account.User) ([]byte, bool, *model.AppError)
	GetSanitizeOptions(asAdmin bool) map[string]bool
	GetSession(token string) (*model.Session, *model.AppError)
	GetSessionById(sessionID string) (*model.Session, *model.AppError)
	GetStatus(userID string) (*account.Status, *model.AppError)
	GetStatusFromCache(userID string) *account.Status
	GetTotalUsersStats() (*account.UsersStats, *model.AppError)
	GetUserAccessToken(tokenID string, sanitize bool) (*account.UserAccessToken, *model.AppError)
	GetUserAccessTokens(page, perPage int) ([]*account.UserAccessToken, *model.AppError)
	GetUserAccessTokensForUser(userID string, page, perPage int) ([]*account.UserAccessToken, *model.AppError)
	GetUserByAuth(authData *string, authService string) (*account.User, *model.AppError)
	GetUserByUsername(username string) (*account.User, *model.AppError)
	GetUserStatusesByIds(userIDs []string) ([]*account.Status, *model.AppError)
	GetUserTermsOfService(userID string) (*account.UserTermsOfService, *model.AppError)
	GetUsers(options *account.UserGetOptions) ([]*account.User, *model.AppError)
	GetUsersByIds(userIDs []string, options *store.UserGetByIdsOpts) ([]*account.User, *model.AppError)
	GetUsersByUsernames(usernames []string, asAdmin bool) ([]*account.User, *model.AppError)
	GetVerifyEmailToken(token string) (*model.Token, *model.AppError)
	IsFirstUserAccount() bool
	IsUserSignUpAllowed() *model.AppError
	IsUsernameTaken(name string) bool
	MakePermissionError(s *model.Session, permissions ...*model.Permission) *model.AppError
	PatchRole(role *model.Role, patch *model.RolePatch) (*model.Role, *model.AppError)
	PermanentDeleteAllUsers(c *request.Context) *model.AppError
	PermanentDeleteUser(c *request.Context, user *account.User) *model.AppError
	ResetPasswordFromToken(userSuppliedTokenString, newPassword string) *model.AppError
	ReturnSessionToPool(session *model.Session)
	RevokeSessionsForDeviceId(userID string, deviceID string, currentSessionId string) *model.AppError
	RevokeUserAccessToken(token *account.UserAccessToken) *model.AppError
	SanitizeProfile(user *account.User, asAdmin bool)
	SaveAndBroadcastStatus(status *account.Status)
	SaveUserTermsOfService(userID, termsOfServiceId string, accepted bool) *model.AppError
	SearchUserAccessTokens(term string) ([]*account.UserAccessToken, *model.AppError)
	SearchUsers(props *account.UserSearch, options *account.UserSearchOptions) ([]*account.User, *model.AppError)
	SendEmailVerification(user *account.User, newEmail, redirect string) *model.AppError
	SendPasswordReset(email string, siteURL string) (bool, *model.AppError)
	SessionCacheLength() int
	SetDefaultProfileImage(user *account.User) *model.AppError
	SetProfileImage(userID string, imageData *multipart.FileHeader) *model.AppError
	SetProfileImageFromFile(userID string, file io.Reader) *model.AppError
	SetProfileImageFromMultiPartFile(userID string, f multipart.File) *model.AppError
	SetStatusOffline(userID string, manual bool)
	SetStatusOnline(userID string, manual bool)
	StatusByID(statusID string) (*account.Status, *model.AppError)
	StatusesByIDs(statusIDs []string) ([]*account.Status, *model.AppError)
	UpdateActive(c *request.Context, user *account.User, active bool) (*account.User, *model.AppError)
	UpdateHashedPassword(user *account.User, newHashedPassword string) *model.AppError
	UpdateHashedPasswordByUserId(userID, newHashedPassword string) *model.AppError
	UpdateLastActivityAtIfNeeded(session model.Session)
	UpdateMfa(activate bool, userID, token string) *model.AppError
	UpdatePassword(user *account.User, newPassword string) *model.AppError
	UpdatePasswordAsUser(userID, currentPassword, newPassword string) *model.AppError
	UpdatePasswordByUserIdSendEmail(userID, newPassword, method string) *model.AppError
	UpdatePasswordSendEmail(user *account.User, newPassword, method string) *model.AppError
	UpdatePreferences(userID string, preferences model.Preferences) *model.AppError
	UpdateRole(role *model.Role) (*model.Role, *model.AppError)
	UpdateUser(user *account.User, sendNotifications bool) (*account.User, *model.AppError)
	UpdateUserActive(c *request.Context, userID string, active bool) *model.AppError
	UpdateUserAsUser(user *account.User, asAdmin bool) (*account.User, *model.AppError)
	UpdateUserAuth(userID string, userAuth *account.UserAuth) (*account.UserAuth, *model.AppError)
	UpdateUserRoles(userID string, newRoles string, sendWebSocketEvent bool) (*account.User, *model.AppError)
	UpdateUserRolesWithUser(user *account.User, newRoles string, sendWebSocketEvent bool) (*account.User, *model.AppError)
	UserByEmail(email string) (*account.User, *model.AppError)
	UserById(ctx context.Context, userID string) (*account.User, *model.AppError)
	UserSetDefaultAddress(userID, addressID, addressType string) (*account.User, *model.AppError)
	VerifyEmailFromToken(userSuppliedTokenString string) *model.AppError
	VerifyUserEmail(userID, email string) *model.AppError
}
