// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"time"

	"github.com/mattermost/squirrel"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/app/discount/types"
	"github.com/sitename/sitename/app/plugin/interfaces"
	"github.com/sitename/sitename/model_helper"
	"github.com/volatiletech/sqlboiler/v4/boil"
)

// DiscountService contains methods for working with discounts
type DiscountService interface {
	// ActiveSales finds active sales by given date. If date is nil then set date to UTC now
	//
	//	(end_date == NULL || end_date >= date) && start_date <= date
	ActiveSales(date *time.Time) (model.SaleSlice, *model_helper.AppError)
	// CalculateDiscountedPrice Return minimum product's price of all prices with discounts applied
	//
	// `discounts` is optional
	CalculateDiscountedPrice(product model.Product, price goprices.Money, collections []*model.Collection, discounts []*model_helper.DiscountInfo, channeL model.Channel, variantID string) (*goprices.Money, *model_helper.AppError)
	// Decorator returns a function to calculate discount.
	// `preValue` must has type of goprices.Money || decimal.Decimal
	Decorator(preValue any) types.DiscountCalculator
	// ExpiredSales returns sales that are expired by date. If date is nil, default to UTC now
	//
	//	end_date <= date && start_date <= date
	ExpiredSales(date *time.Time) ([]*model.Sale, *model_helper.AppError)
	// ExpiredVouchers returns vouchers that are expired before given date (beginning of the day). If date is nil, use today instead
	ExpiredVouchers(date *time.Time) (model.VoucherSlice, *model_helper.AppError)
	// FetchActiveDiscounts returns discounts that are activated
	FetchActiveDiscounts() ([]*model_helper.DiscountInfo, *model_helper.AppError)
	// FetchCatalogueInfo may return a map with keys are ["categories", "collections", "products", "variants"].
	//
	// values are slices of uuid strings
	FetchCatalogueInfo(instance model.Sale) (map[string][]string, *model_helper.AppError)
	// FetchCategories returns a map with keys are sale ids, values are slices of category ids
	FetchCategories(saleIDs []string) (map[string][]string, *model_helper.AppError)
	// FetchCollections returns a map with keys are sale ids, values are slices of UNIQUE collection ids
	FetchCollections(saleIDs []string) (map[string][]string, *model_helper.AppError)
	// FetchProducts returns a map with keys are sale ids, values are slices of UNIQUE product ids
	FetchProducts(saleIDs []string) (map[string][]string, *model_helper.AppError)
	// FetchSaleChannelListings returns a map with keys are sale ids, values are maps with keys are channel slugs
	FetchSaleChannelListings(saleIDs []string) (map[string]map[string]*model.SaleChannelListing, *model_helper.AppError)
	// FetchVariants returns a map with keys are sale ids and values are slice of UNIQUE product variant ids
	FetchVariants(saleIDs []string) (map[string][]string, *model_helper.AppError)
	// FilterActiveVouchers returns a list of vouchers that are active.
	//
	// `channelSlug` is optional (can be empty). pass this argument if you want to find active vouchers in specific channel
	FilterActiveVouchers(date time.Time, channelSlug string) (model.VoucherSlice, *model_helper.AppError)
	// FilterSalesByOption should be used to filter active or expired sales
	// refer: saleor/discount/models.SaleQueryset for details
	FilterSalesByOption(option model_helper.SaleFilterOption) (model.SaleSlice, *model_helper.AppError)
	// GetDiscountAmountFor checks given voucher's `DiscountValueType` and returns according discount calculator function
	//
	//	price.(type) == Money || MoneyRange || TaxedMoney || TaxedMoneyRange
	//
	// NOTE: the returning interface's type should be identical to given price's type
	GetDiscountAmountFor(voucher model.Voucher, price any, channelID string) (any, *model_helper.AppError)
	// GetProductDiscountOnSale Return discount value if product is on sale or raise NotApplicable
	GetProductDiscountOnSale(product model.Product, productCollectionIDs []string, discountInfo model_helper.DiscountInfo, channeL model.Channel, variantID string) (types.DiscountCalculator, *model_helper.AppError)
	// GetProductDiscounts Return discount values for all discounts applicable to a product.
	GetProductDiscounts(product model.Product, collections model.CollectionSlice, discountInfos []*model_helper.DiscountInfo, channeL model.Channel, variantID string) ([]types.DiscountCalculator, *model_helper.AppError)
	// GetProductsVoucherDiscount Calculate discount value for a voucher of product or category type
	GetProductsVoucherDiscount(voucher model.Voucher, prices []*goprices.Money, channelID string) (*goprices.Money, *model_helper.AppError)
	// GetVoucherTranslationByOption returns a voucher translation by given options
	GetVoucherTranslationByOption(option *model.VoucherTranslationFilterOption) (*model.VoucherTranslation, *model_helper.AppError)
	// IsValidPromoCode checks if given code is valid giftcard code or voucher code
	IsValidPromoCode(code string) bool
	// SaleCollectionsByOptions returns a slice of sale-collection relations filtered using given options
	SaleCollectionsByOptions(options squirrel.Sqlizer) ([]*model.SaleCollection, *model_helper.AppError)
	// SaleProductVariantsByOptions returns a list of sale-product variant relations filtered using given options
	SaleProductVariantsByOptions(options squirrel.Sqlizer) ([]*model.SaleProductVariant, *model_helper.AppError)
	// SaleProductsByOptions returns a slice of sale-product relations filtered using given options
	SaleProductsByOptions(options squirrel.Sqlizer) ([]*model.SaleProduct, *model_helper.AppError)
	// ValidateMinSpent validates if the order cost at least a specific amount of money
	ValidateMinSpent(voucher model.Voucher, value goprices.TaxedMoney, channelID string) (notApplicableErr *model_helper.NotApplicable, appErr *model_helper.AppError)
	// ValidateOncePerCustomer checks to make sure each customer has ONLY 1 time usage with 1 voucher
	ValidateOncePerCustomer(voucher model.Voucher, customerEmail string) (notApplicableErr *model_helper.NotApplicable, appErr *model_helper.AppError)
	// ValidateVoucherForCheckout validates given voucher
	ValidateVoucherForCheckout(manager interfaces.PluginManagerInterface, voucher model.Voucher, checkoutInfo model_helper.CheckoutInfo, lines model_helper.CheckoutLineInfos, discounts []*model_helper.DiscountInfo) (*model_helper.NotApplicable, *model_helper.AppError)
	// VoucherChannelListingsByOption finds voucher channel listings based on given options
	VoucherChannelListingsByOption(option model_helper.VoucherChannelListingFilterOption) (model.VoucherChannelListingSlice, *model_helper.AppError)
	// VoucherTranslationsByOption returns a list of voucher translations filtered using given option
	VoucherTranslationsByOption(option *model.VoucherTranslationFilterOption) ([]*model.VoucherTranslation, *model_helper.AppError)
	AddVoucherUsageByCustomer(voucher model.Voucher, customerEmail string) (*model_helper.NotApplicable, *model_helper.AppError)
	AlterVoucherUsage(voucher model.Voucher, usageDelta int) (*model.Voucher, *model_helper.AppError)
	BulkDeleteOrderDiscounts(orderDiscountIDs []string) *model_helper.AppError
	CreateNewVoucherCustomer(voucherID string, customerEmail string) (*model.VoucherCustomer, *model_helper.AppError)
	FetchDiscounts(date time.Time) ([]*model_helper.DiscountInfo, *model_helper.AppError)
	FilterVats(options *model.VatFilterOptions) ([]*model.Vat, *model_helper.AppError)
	GetSaleDiscount(sale model.Sale, saleChannelListing model.SaleChannelListing) (types.DiscountCalculator, *model_helper.AppError)
	GetVoucherDiscount(voucher model.Voucher, channelID string) (types.DiscountCalculator, *model_helper.AppError)
	OrderDiscountsByOption(option model_helper.OrderDiscountFilterOption) (model.OrderDiscountSlice, *model_helper.AppError)
	PromoCodeIsVoucher(code string) (bool, *model_helper.AppError)
	RemoveVoucherUsageByCustomer(voucher model.Voucher, customerEmail string) *model_helper.AppError
	SaleCategoriesByOption(option squirrel.Sqlizer) ([]*model.SaleCategory, *model_helper.AppError)
	SaleChannelListingsByOptions(options *model.SaleChannelListingFilterOption) ([]*model.SaleChannelListing, *model_helper.AppError)
	ToggleSaleRelations(transaction boil.ContextTransactor, saleID string, productIDs, variantIDs, categoryIDs, collectionIDs []string, isDelete bool) *model_helper.AppError
	ToggleVoucherRelations(transaction boil.ContextTransactor, vouchers model.Vouchers, productIDs, variantIDs, categoryIDs, collectionIDs []string, isDelete bool) *model_helper.AppError
	UpsertOrderDiscount(transaction boil.ContextTransactor, orderDiscount model.OrderDiscount) (*model.OrderDiscount, *model_helper.AppError)
	UpsertSale(transaction boil.ContextTransactor, sale model.Sale) (*model.Sale, *model_helper.AppError)
	UpsertVoucher(voucher model.Voucher) (*model.Voucher, *model_helper.AppError)
	ValidateOnlyForStaff(voucher model.Voucher, customerID string) (*model_helper.NotApplicable, *model_helper.AppError)
	ValidateVoucher(voucher model.Voucher, totalPrice goprices.TaxedMoney, quantity int, customerEmail string, channelID string, customerID string) (notApplicableErr *model_helper.NotApplicable, appErr *model_helper.AppError)
	ValidateVoucherInOrder(order *model.Order) (notApplicableErr *model_helper.NotApplicable, appErr *model_helper.AppError)
	VoucherById(voucherID string) (*model.Voucher, *model_helper.AppError)
	VoucherByOption(options model_helper.VoucherFilterOption) (*model.Voucher, *model_helper.AppError)
	VoucherCustomerByOptions(options model_helper.VoucherCustomerFilterOption) (*model.VoucherCustomer, *model_helper.AppError)
	VoucherCustomersByOption(options model_helper.VoucherCustomerFilterOption) (model.VoucherCustomerSlice, *model_helper.AppError)
	VouchersByOption(option model_helper.VoucherFilterOption) (model.VoucherSlice, *model_helper.AppError)
}
