// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"time"

	"github.com/mattermost/gorp"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/model/attribute"
	"github.com/sitename/sitename/model/channel"
	"github.com/sitename/sitename/model/order"
	"github.com/sitename/sitename/model/product_and_discount"
	"github.com/sitename/sitename/model/shop"
	"github.com/sitename/sitename/modules/measurement"
)

// ProductService contains methods for working with products
type ProductService interface {
	// BulkUpsertProductChannelListings bulk update/inserts given product channel listings and returns them
	BulkUpsertProductChannelListings(listings []*product_and_discount.ProductChannelListing) ([]*product_and_discount.ProductChannelListing, *model.AppError)
	// CalculateRevenueForVariant Calculate total revenue generated by a product variant
	//
	// NOTE: `startDate` must be UTC time
	CalculateRevenueForVariant(variant *product_and_discount.ProductVariant, startDate *time.Time, orderLines []*order.OrderLine, ordersDict map[string]*order.Order, currencyCode string) (*goprices.TaxedMoney, *model.AppError)
	// CategoriesByOption returns all categories that satisfy given option
	CategoriesByOption(option *product_and_discount.CategoryFilterOption) ([]*product_and_discount.Category, *model.AppError)
	// CategoryByOption returns 1 category that satisfies given option
	CategoryByOption(option *product_and_discount.CategoryFilterOption) (*product_and_discount.Category, *model.AppError)
	// CollectCategoriesTreeProducts Collect products from all levels in category tree.
	CollectCategoriesTreeProducts(category *product_and_discount.Category) ([]*product_and_discount.Product, *model.AppError)
	// CollectionsByOption returns all collections that satisfy given option.
	//
	// NOTE: `ShopID` is required.
	CollectionsByOption(option *product_and_discount.CollectionFilterOption) ([]*product_and_discount.Collection, *model.AppError)
	// CollectionsByProductID finds and returns all collections related to given product
	CollectionsByProductID(productID string) ([]*product_and_discount.Collection, *model.AppError)
	// CollectionsByVoucherID finds all collections that have relationships with given voucher
	CollectionsByVoucherID(voucherID string) ([]*product_and_discount.Collection, *model.AppError)
	// DeleteCategories Delete categories and perform all necessary actions.
	//
	// Set products of deleted categories as unpublished, delete categories
	// and update products minimal variant prices.
	DeleteCategories(categoryIDs []string, manager interface{}) *model.AppError
	// DigitalContentUrlIsValid Check if digital url is still valid for customer.
	//
	// It takes default settings or digital product's settings
	// to check if url is still valid.
	DigitalContentUrlIsValid(contentURL *product_and_discount.DigitalContentUrl) (bool, *model.AppError)
	// DigitalContentbyOption returns 1 digital content filtered using given option
	DigitalContentbyOption(option *product_and_discount.DigitalContenetFilterOption) (*product_and_discount.DigitalContent, *model.AppError)
	// DisplayProduct return display text for given product variant
	//
	// `translated` default to false
	DisplayProduct(productVariant *product_and_discount.ProductVariant, translated bool) (stringm *model.AppError)
	// GenerateAndSetVariantName Generate ProductVariant's name based on its attributes
	GenerateAndSetVariantName(variant *product_and_discount.ProductVariant, sku string) *model.AppError
	// GetProductsIDsWithoutVariants Return list of product's ids without variants
	GetProductsIDsWithoutVariants(productList []*product_and_discount.Product) ([]string, *model.AppError)
	// GetVariantPrice
	GetVariantPrice(variant *product_and_discount.ProductVariant, variantChannelListing *product_and_discount.ProductVariantChannelListing, product *product_and_discount.Product, collections []*product_and_discount.Collection, discounts []*product_and_discount.DiscountInfo, chanNel *channel.Channel) (*goprices.Money, *model.AppError)
	// GetVariantSelectionAttributes Return attributes that can be used in variant selection.
	//
	// Attribute must be product attribute and attribute input type must be
	// in ALLOWED_IN_VARIANT_SELECTION list.
	GetVariantSelectionAttributes(attributes []*attribute.Attribute) []*attribute.Attribute
	// ProductById returns 1 product by given id
	ProductById(productID string) (*product_and_discount.Product, *model.AppError)
	// ProductByOption returns 1 product that satisfy given option
	ProductByOption(option *product_and_discount.ProductFilterOption) (*product_and_discount.Product, *model.AppError)
	// ProductChannelListingsByOption returns a list of product channel listings filtered using given option
	ProductChannelListingsByOption(option *product_and_discount.ProductChannelListingFilterOption) ([]*product_and_discount.ProductChannelListing, *model.AppError)
	// ProductGetFirstImage returns first media of given product
	ProductGetFirstImage(productID string) (*product_and_discount.ProductMedia, *model.AppError)
	// ProductMediasByOption returns a list of product medias that satisfy given option
	ProductMediasByOption(option *product_and_discount.ProductMediaFilterOption) ([]*product_and_discount.ProductMedia, *model.AppError)
	// ProductTranslationsByOption returns a list of product translations
	ProductTranslationsByOption(option *product_and_discount.ProductTranslationFilterOption) ([]*product_and_discount.ProductTranslation, *model.AppError)
	// ProductTypeByOption returns a product type with given option
	ProductTypeByOption(options *product_and_discount.ProductTypeFilterOption) (*product_and_discount.ProductType, *model.AppError)
	// ProductTypesByProductIDs returns all product types that belong to given products
	ProductTypesByProductIDs(productIDs []string) ([]*product_and_discount.ProductType, *model.AppError)
	// ProductVariantById finds product variant by given id
	ProductVariantById(id string) (*product_and_discount.ProductVariant, *model.AppError)
	// ProductVariantByOrderLineID returns a product variant by given order line id
	ProductVariantByOrderLineID(orderLineID string) (*product_and_discount.ProductVariant, *model.AppError)
	// ProductVariantChannelListingsByOption returns a slice of product variant channel listings by given option
	ProductVariantChannelListingsByOption(transaction *gorp.Transaction, option *product_and_discount.ProductVariantChannelListingFilterOption) (product_and_discount.ProductVariantChannelListings, *model.AppError)
	// ProductVariantGetPrice returns price
	ProductVariantGetPrice(productVariant *product_and_discount.ProductVariant, product *product_and_discount.Product, collections []*product_and_discount.Collection, channel *channel.Channel, channelListing *product_and_discount.ProductVariantChannelListing, discounts []*product_and_discount.DiscountInfo) (*goprices.Money, *model.AppError)
	// ProductVariantGetWeight returns weight of given product variant
	ProductVariantGetWeight(productVariantID string) (*measurement.Weight, *model.AppError)
	// ProductVariantIsDigital finds product type that related to given product variant and check if that product type is digital and does not require shipping
	ProductVariantIsDigital(productVariantID string) (bool, *model.AppError)
	// ProductVariantTranslationsByOption returns a list of product variant translations
	ProductVariantTranslationsByOption(option *product_and_discount.ProductVariantTranslationFilterOption) ([]*product_and_discount.ProductVariantTranslation, *model.AppError)
	// ProductVariantsAvailableInChannel returns product variants based on given channel slug
	ProductVariantsAvailableInChannel(channelSlug string) ([]*product_and_discount.ProductVariant, *model.AppError)
	// ProductVariantsByOption returns a list of product variants satisfy given option
	ProductVariantsByOption(option *product_and_discount.ProductVariantFilterOption) ([]*product_and_discount.ProductVariant, *model.AppError)
	// ProductsByOption returns a list of products that satisfy given option
	ProductsByOption(option *product_and_discount.ProductFilterOption) ([]*product_and_discount.Product, *model.AppError)
	// ProductsByVoucherID finds all products that have relationships with given voucher
	ProductsByVoucherID(voucherID string) ([]*product_and_discount.Product, *model.AppError)
	// ProductsRequireShipping checks if at least 1 product require shipping, then return true, false otherwise
	ProductsRequireShipping(productIDs []string) (bool, *model.AppError)
	// PublishedCollections returns all published collections
	PublishedCollections(channelSlug string, shopID string) ([]*product_and_discount.Collection, *model.AppError)
	// UpdateProductDiscountedPrice
	//
	// NOTE: `discounts` can be nil
	UpdateProductDiscountedPrice(product *product_and_discount.Product, discounts []*product_and_discount.DiscountInfo) *model.AppError
	// UpdateProductsDiscountedPrices
	UpdateProductsDiscountedPrices(products []*product_and_discount.Product, discounts []*product_and_discount.DiscountInfo) *model.AppError
	// UpdateProductsDiscountedPricesOfDiscount
	//
	// NOTE: discount must be either *Sale or *Voucher
	UpdateProductsDiscountedPricesOfDiscount(discount interface{}) *model.AppError
	// UpsertDigitalContentURL create a digital content url then returns it
	UpsertDigitalContentURL(contentURL *product_and_discount.DigitalContentUrl) (*product_and_discount.DigitalContentUrl, *model.AppError)
	// UpsertProductVariant tells store to upsert given product variant and returns it
	UpsertProductVariant(transaction *gorp.Transaction, variant *product_and_discount.ProductVariant) (*product_and_discount.ProductVariant, *model.AppError)
	// VisibleCollectionsToUser returns all collections that belong to given shop and can be viewed by given user
	VisibleCollectionsToUser(userID string, shopID string, channelSlug string) ([]*product_and_discount.Collection, *model.AppError)
	// BulkUpsertProductVariantChannelListings tells store to bulk upserts given product variant channel listings
	BulkUpsertProductVariantChannelListings(transaction *gorp.Transaction, listings []*product_and_discount.ProductVariantChannelListing) ([]*product_and_discount.ProductVariantChannelListing, *model.AppError)
	GetDefaultDigitalContentSettings(aShop *shop.Shop) *shop.ShopDefaultDigitalContentSettings
	GetProductAvailability(product *product_and_discount.Product, productChannelListing *product_and_discount.ProductChannelListing, variants []*product_and_discount.ProductVariant, variantsChannelListing []*product_and_discount.ProductVariantChannelListing, collections []*product_and_discount.Collection, discounts []*product_and_discount.DiscountInfo, chanNel *channel.Channel, manager interface{}, countryCode string, localCurrency string) (*product_and_discount.ProductAvailability, *model.AppError)
	GetProductPriceRange(product *product_and_discount.Product, variants []*product_and_discount.ProductVariant, variantsChannelListing []*product_and_discount.ProductVariantChannelListing, collections []*product_and_discount.Collection, discounts []*product_and_discount.DiscountInfo, chanNel *channel.Channel) (*goprices.MoneyRange, *model.AppError)
	GetVariantAvailability(variant *product_and_discount.ProductVariant, variantChannelListing *product_and_discount.ProductVariantChannelListing, product *product_and_discount.Product, productChannelListing *product_and_discount.ProductChannelListing, collections []*product_and_discount.Collection, discounts []*product_and_discount.DiscountInfo, chanNel *channel.Channel, plugins interface{}, country string, localCurrency string) (*product_and_discount.VariantAvailability, *model.AppError)
	IncrementDownloadCount(contentURL *product_and_discount.DigitalContentUrl) *model.AppError
	ProductTypesByCheckoutToken(checkoutToken string) ([]*product_and_discount.ProductType, *model.AppError)
	UpdateProductsDiscountedPricesOfCatalogues(productIDs []string, categoryIDs []string, collectionIDs []string) *model.AppError
}
