// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"time"

	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/app/plugin/interfaces"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/modules/measurement"
	"github.com/sitename/sitename/store/store_iface"
)

// ProductService contains methods for working with products
type ProductService interface {
	// BulkUpsertProductChannelListings bulk update/inserts given product channel listings and returns them
	BulkUpsertProductChannelListings(listings []*model.ProductChannelListing) ([]*model.ProductChannelListing, *model.AppError)
	// BulkUpsertProductVariantChannelListings tells store to bulk upserts given product variant channel listings
	BulkUpsertProductVariantChannelListings(transaction store_iface.SqlxTxExecutor, listings []*model.ProductVariantChannelListing) ([]*model.ProductVariantChannelListing, *model.AppError)
	// CalculateRevenueForVariant Calculate total revenue generated by a product variant
	//
	// NOTE: `startDate` must be UTC time
	CalculateRevenueForVariant(variant *model.ProductVariant, startDate *time.Time, orderLines []*model.OrderLine, ordersDict map[string]*model.Order, currencyCode string) (*goprices.TaxedMoney, *model.AppError)
	// CategoriesByOption returns all categories that satisfy given option
	CategoriesByOption(option *model.CategoryFilterOption) (model.Categories, *model.AppError)
	// CategoryByOption returns 1 category that satisfies given option
	CategoryByOption(option *model.CategoryFilterOption) (*model.Category, *model.AppError)
	// ClassifyCategories takes a slice of single categories.
	// Returns a slice of category families
	// NOTE: you can call this function
	ClassifyCategories(categories model.Categories) model.Categories
	// CollectCategoriesTreeProducts Collect products from all levels in category tree.
	CollectCategoriesTreeProducts(category *model.Category) (model.Products, *model.AppError)
	// CollectionProductRelationsByOptions finds and returns a list of product-collection relations based on given filter options
	CollectionProductRelationsByOptions(options *model.CollectionProductFilterOptions) ([]*model.CollectionProduct, *model.AppError)
	// CollectionsByOption returns all collections that satisfy given option.
	//
	// NOTE: `ShopID` is required.
	CollectionsByOption(option *model.CollectionFilterOption) (model.Collections, *model.AppError)
	// CollectionsByProductID finds and returns all collections related to given product
	CollectionsByProductID(productID string) ([]*model.Collection, *model.AppError)
	// CollectionsByVoucherID finds all collections that have relationships with given voucher
	CollectionsByVoucherID(voucherID string) ([]*model.Collection, *model.AppError)
	// DeleteCategories Delete categories and perform all necessary actions.
	//
	// Set products of deleted categories as unpublished, delete categories
	// and update products minimal variant prices.
	DeleteCategories(categoryIDs []string, manager interfaces.PluginManagerInterface) *model.AppError
	// DigitalContentUrlIsValid Check if digital url is still valid for customer.
	//
	// It takes default settings or digital product's settings
	// to check if url is still valid.
	DigitalContentUrlIsValid(contentURL *model.DigitalContentUrl) (bool, *model.AppError)
	// DigitalContentbyOption returns 1 digital content filtered using given option
	DigitalContentbyOption(option *model.DigitalContentFilterOption) (*model.DigitalContent, *model.AppError)
	// DisplayProduct return display text for given product variant
	//
	// `translated` default to false
	DisplayProduct(productVariant *model.ProductVariant, translated bool) (stringm *model.AppError)
	// DoAnalyticCategories finds all categories in system.
	// Counts number of products of each category.
	// Sets NumberOfProducts, NumberOfChildren, Children attributes of each category.
	// Stores classified categories in cache
	DoAnalyticCategories() *model.AppError
	// GenerateAndSetVariantName Generate ProductVariant's name based on its attributes
	GenerateAndSetVariantName(variant *model.ProductVariant, sku string) *model.AppError
	// GetProductsIDsWithoutVariants Return list of product's ids without variants
	GetProductsIDsWithoutVariants(productList model.Products) ([]string, *model.AppError)
	// GetVariantPrice
	GetVariantPrice(variant model.ProductVariant, variantChannelListing model.ProductVariantChannelListing, product model.Product, collections []*model.Collection, discounts []*model.DiscountInfo, chanNel model.Channel) (*goprices.Money, *model.AppError)
	// GetVariantSelectionAttributes Return attributes that can be used in variant selection.
	//
	// Attribute must be product attribute and attribute input type must be
	// in ALLOWED_IN_VARIANT_SELECTION list.
	GetVariantSelectionAttributes(attributes []*model.Attribute) []*model.Attribute
	// ProductById returns 1 product by given id
	ProductById(productID string) (*model.Product, *model.AppError)
	// ProductByOption returns 1 product that satisfy given option
	ProductByOption(option *model.ProductFilterOption) (*model.Product, *model.AppError)
	// ProductChannelListingsByOption returns a list of product channel listings filtered using given option
	ProductChannelListingsByOption(option *model.ProductChannelListingFilterOption) ([]*model.ProductChannelListing, *model.AppError)
	// ProductGetFirstImage returns first media of given product
	ProductGetFirstImage(productID string) (*model.ProductMedia, *model.AppError)
	// ProductMediasByOption returns a list of product medias that satisfy given option
	ProductMediasByOption(option *model.ProductMediaFilterOption) ([]*model.ProductMedia, *model.AppError)
	// ProductTranslationsByOption returns a list of product translations
	ProductTranslationsByOption(option *model.ProductTranslationFilterOption) ([]*model.ProductTranslation, *model.AppError)
	// ProductTypeByOption returns a product type with given option
	ProductTypeByOption(options *model.ProductTypeFilterOption) (*model.ProductType, *model.AppError)
	// ProductTypesByProductIDs returns all product types that belong to given products
	ProductTypesByProductIDs(productIDs []string) ([]*model.ProductType, *model.AppError)
	// ProductVariantById finds product variant by given id
	ProductVariantById(id string) (*model.ProductVariant, *model.AppError)
	// ProductVariantByOrderLineID returns a product variant by given order line id
	ProductVariantByOrderLineID(orderLineID string) (*model.ProductVariant, *model.AppError)
	// ProductVariantChannelListingsByOption returns a slice of product variant channel listings by given option
	ProductVariantChannelListingsByOption(transaction store_iface.SqlxTxExecutor, option *model.ProductVariantChannelListingFilterOption) (model.ProductVariantChannelListings, *model.AppError)
	// ProductVariantGetPrice returns price
	ProductVariantGetPrice(productVariant *model.ProductVariant, product model.Product, collections []*model.Collection, channel model.Channel, channelListing *model.ProductVariantChannelListing, discounts []*model.DiscountInfo) (*goprices.Money, *model.AppError)
	// ProductVariantGetWeight returns weight of given product variant
	ProductVariantGetWeight(productVariantID string) (*measurement.Weight, *model.AppError)
	// ProductVariantIsDigital finds product type that related to given product variant and check if that product type is digital and does not require shipping
	ProductVariantIsDigital(productVariantID string) (bool, *model.AppError)
	// ProductVariantTranslationsByOption returns a list of product variant translations
	ProductVariantTranslationsByOption(option *model.ProductVariantTranslationFilterOption) ([]*model.ProductVariantTranslation, *model.AppError)
	// ProductVariantsAvailableInChannel returns product variants based on given channel slug
	ProductVariantsAvailableInChannel(channelSlug string) ([]*model.ProductVariant, *model.AppError)
	// ProductVariantsByOption returns a list of product variants satisfy given option
	ProductVariantsByOption(option *model.ProductVariantFilterOption) (model.ProductVariants, *model.AppError)
	// ProductsByOption returns a list of products that satisfy given option
	ProductsByOption(option *model.ProductFilterOption) (model.Products, *model.AppError)
	// ProductsByVoucherID finds all products that have relationships with given voucher
	ProductsByVoucherID(voucherID string) ([]*model.Product, *model.AppError)
	// ProductsRequireShipping checks if at least 1 product require shipping, then return true, false otherwise
	ProductsRequireShipping(productIDs []string) (bool, *model.AppError)
	// PublishedCollections returns all published collections
	PublishedCollections(channelSlug string, shopID string) ([]*model.Collection, *model.AppError)
	// UpdateProductDiscountedPrice
	//
	// NOTE: `discounts` can be nil
	UpdateProductDiscountedPrice(product model.Product, discounts []*model.DiscountInfo) *model.AppError
	// UpdateProductsDiscountedPrices
	UpdateProductsDiscountedPrices(products []*model.Product, discounts []*model.DiscountInfo) *model.AppError
	// UpdateProductsDiscountedPricesOfDiscount
	//
	// NOTE: discount must be either *Sale or *Voucher
	UpdateProductsDiscountedPricesOfDiscount(discount interface{}) *model.AppError
	// UpsertDigitalContentURL create a digital content url then returns it
	UpsertDigitalContentURL(contentURL *model.DigitalContentUrl) (*model.DigitalContentUrl, *model.AppError)
	// UpsertProductVariant tells store to upsert given product variant and returns it
	UpsertProductVariant(transaction store_iface.SqlxTxExecutor, variant *model.ProductVariant) (*model.ProductVariant, *model.AppError)
	// VisibleCollectionsToUser returns all collections that belong to given shop and can be viewed by given user
	VisibleCollectionsToUser(userID string, shopID string, channelSlug string) ([]*model.Collection, *model.AppError)
	CategoryByIds(ids []string, allowFromCache bool) (model.Categories, *model.AppError)
	CollectionChannelListingsByOptions(options *model.CollectionChannelListingFilterOptions) ([]*model.CollectionChannelListing, *model.AppError)
	CountProductTypesByOptions(options *model.ProductTypeFilterOption) (int64, *model.AppError)
	DigitalContentURLSByOptions(options *model.DigitalContentUrlFilterOptions) ([]*model.DigitalContentUrl, *model.AppError)
	DigitalContentsbyOptions(option *model.DigitalContentFilterOption) ([]*model.DigitalContent, *model.AppError)
	FilterCategoriesFromCache(filter func(c *model.Category) bool) model.Categories
	FilterProductsAdvanced(options *model.ExportProductsFilterOptions, channelIdOrSlug string) (model.Products, *model.AppError)
	GetDefaultDigitalContentSettings(aShop *model.Shop) *model.ShopDefaultDigitalContentSettings
	GetProductAvailability(product model.Product, productChannelListing *model.ProductChannelListing, variants []*model.ProductVariant, variantsChannelListing []*model.ProductVariantChannelListing, collections []*model.Collection, discounts []*model.DiscountInfo, chanNel model.Channel, manager interfaces.PluginManagerInterface, countryCode model.CountryCode, localCurrency string) (*model.ProductAvailability, *model.AppError)
	GetProductPriceRange(product model.Product, variants model.ProductVariants, variantsChannelListing []*model.ProductVariantChannelListing, collections []*model.Collection, discounts []*model.DiscountInfo, chanNel model.Channel) (*goprices.MoneyRange, *model.AppError)
	GetVariantAvailability(variant model.ProductVariant, variantChannelListing model.ProductVariantChannelListing, product model.Product, productChannelListing *model.ProductChannelListing, collections []*model.Collection, discounts []*model.DiscountInfo, chanNel model.Channel, plugins interfaces.PluginManagerInterface, country model.CountryCode, localCurrency string) (*model.VariantAvailability, *model.AppError)
	GetVisibleToUserProducts(userSession *model.Session, channel_IdOrSlug string) (model.Products, *model.AppError)
	IncrementDownloadCount(contentURL *model.DigitalContentUrl) *model.AppError
	ProductTypesByCheckoutToken(checkoutToken string) ([]*model.ProductType, *model.AppError)
	ProductTypesByOptions(options *model.ProductTypeFilterOption) ([]*model.ProductType, *model.AppError)
	UpdateProductsDiscountedPricesOfCatalogues(productIDs, categoryIDs, collectionIDs, variantIDs []string) *model.AppError
	UpsertCategory(cate *model.Category) (*model.Category, *model.AppError)
}
