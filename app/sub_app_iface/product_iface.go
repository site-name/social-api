// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"time"

	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/app/plugin/interfaces"
	"github.com/sitename/sitename/model_helper"
	"github.com/sitename/sitename/modules/measurement"
	"github.com/sitename/sitename/model"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"gorm.io/gorm"
)

// ProductService contains methods for working with products
type ProductService interface {
	// BulkUpsertProductChannelListings bulk update/inserts given product channel listings and returns them
	BulkUpsertProductChannelListings(transaction boil.ContextTransactor, listings model.ProductChannelListingSlice) (model.ProductChannelListingSlice, *model_helper.AppError)
	// BulkUpsertProductVariantChannelListings tells store to bulk upserts given product variant channel listings
	BulkUpsertProductVariantChannelListings(transaction boil.ContextTransactor, listings model.ProductVariantChannelListingSlice) (model.ProductVariantChannelListingSlice, *model_helper.AppError)
	// CalculateRevenueForVariant Calculate total revenue generated by a product variant
	//
	// NOTE: `startDate` must be UTC time
	CalculateRevenueForVariant(variant *model.ProductVariant, startDate *time.Time, orderLines model.OrderLineSlice, ordersDict map[string]*model.Order, currencyCode string) (*goprices.TaxedMoney, *model_helper.AppError)
	// CategoriesByOption returns all categories that satisfy given option
	CategoriesByOption(option model_helper.CategoryFilterOption) (model.CategorySlice, *model_helper.AppError)
	// CategoryByOption returns 1 category that satisfies given option
	CategoryByOption(option model_helper.CategoryFilterOption) (*model.Category, *model_helper.AppError)
	// ClassifyCategories takes a slice of single categories.
	// Returns a slice of category families
	// NOTE: you can call this function
	ClassifyCategories(categories model.CategorySlice) model.CategorySlice
	// CollectCategoriesTreeProducts Collect products from all levels in category tree.
	CollectCategoriesTreeProducts(category *model.Category) (model.ProductSlice, *model_helper.AppError)
	// CollectionProductRelationsByOptions finds and returns a list of product-collection relations based on given filter options
	CollectionProductRelationsByOptions(options model_helper.ProductCollectionFilterOptions) (model.ProductCollectionSlice, *model_helper.AppError)
	// CollectionsByOption returns all collections that satisfy given option.
	//
	// NOTE: `ShopID` is required.
	CollectionsByOption(option model_helper.CollectionFilterOptions) (int64, model.CollectionSlice, *model_helper.AppError)
	// CollectionsByProductID finds and returns all collections related to given product
	CollectionsByProductID(productID string) ([]*model.Collection, *model_helper.AppError)
	// CollectionsByVoucherID finds all collections that have relationships with given voucher
	CollectionsByVoucherID(voucherID string) ([]*model.Collection, *model_helper.AppError)
	// DeleteCategories Delete categories and perform all necessary actions.
	//
	// Set products of deleted categories as unpublished, delete categories
	// and update products minimal variant prices.
	DeleteCategories(categoryIDs []string, manager interfaces.PluginManagerInterface) *model_helper.AppError
	// DigitalContentUrlIsValid Check if digital url is still valid for customer.
	//
	// It takes default settings or digital product's settings
	// to check if url is still valid.
	DigitalContentUrlIsValid(contentURL *model.DigitalContentUrl) (bool, *model_helper.AppError)
	// DigitalContentbyOption returns 1 digital content filtered using given option
	DigitalContentbyOption(option *model.DigitalContentFilterOption) (*model.DigitalContent, *model_helper.AppError)
	// DisplayProduct return display text for given product variant
	//
	// `translated` default to false
	DisplayProduct(productVariant *model.ProductVariant, translated bool) (stringm *model_helper.AppError)
	// DoAnalyticCategories finds all categories in system.
	// Counts number of products of each category.
	// Sets NumberOfProducts, NumberOfChildren, Children attributes of each category.
	// Stores classified categories in cache
	DoAnalyticCategories() *model_helper.AppError
	// GenerateAndSetVariantName Generate ProductVariant's name based on its attributes
	GenerateAndSetVariantName(variant *model.ProductVariant, sku string) *model_helper.AppError
	// GetVariantPrice
	GetVariantPrice(variant model.ProductVariant, variantChannelListing model.ProductVariantChannelListing, product model.Product, collections []*model.Collection, discounts []*model_helper.DiscountInfo, chanNel model.Channel) (*goprices.Money, *model_helper.AppError)
	// GetVariantSelectionAttributes Return attributes that can be used in variant selection.
	//
	// Attribute must be product attribute and attribute input type must be
	// in ALLOWED_IN_VARIANT_SELECTION list.
	GetVariantSelectionAttributes(attributes []*model.Attribute) []*model.Attribute
	// ProductById returns 1 product by given id
	ProductById(productID string) (*model.Product, *model_helper.AppError)
	// ProductByOption returns 1 product that satisfy given option
	ProductByOption(option *model.ProductFilterOption) (*model.Product, *model_helper.AppError)
	// ProductChannelListingsByOption returns a list of product channel listings filtered using given option
	ProductChannelListingsByOption(option *model.ProductChannelListingFilterOption) (model.ProductChannelListingSlice, *model_helper.AppError)
	// ProductGetFirstImage returns first media of given product
	ProductGetFirstImage(productID string) (*model.ProductMedia, *model_helper.AppError)
	// ProductMediasByOption returns a list of product medias that satisfy given option
	ProductMediasByOption(option *model.ProductMediaFilterOption) ([]*model.ProductMedia, *model_helper.AppError)
	// ProductTranslationsByOption returns a list of product translations
	ProductTranslationsByOption(option model_helper.ProductTranslationFilterOption) ([]*model.ProductTranslation, *model_helper.AppError)
	// ProductTypeByOption returns a product type with given option
	ProductTypeByOption(options *model.ProductTypeFilterOption) (*model.ProductType, *model_helper.AppError)
	// ProductTypesByProductIDs returns all product types that belong to given products
	ProductTypesByProductIDs(productIDs []string) ([]*model.ProductType, *model_helper.AppError)
	// ProductVariantById finds product variant by given id
	ProductVariantById(id string) (*model.ProductVariant, *model_helper.AppError)
	// ProductVariantByOrderLineID returns a product variant by given order line id
	ProductVariantByOrderLineID(orderLineID string) (*model.ProductVariant, *model_helper.AppError)
	// ProductVariantChannelListingsByOption returns a slice of product variant channel listings by given option
	ProductVariantChannelListingsByOption(options *model.ProductVariantChannelListingFilterOption) (model.ProductVariantChannelListings, *model_helper.AppError)
	// ProductVariantGetPrice returns price
	ProductVariantGetPrice(productVariant *model.ProductVariant, product model.Product, collections []*model.Collection, channel model.Channel, channelListing *model.ProductVariantChannelListing, discounts []*model_helper.DiscountInfo) (*goprices.Money, *model_helper.AppError)
	// ProductVariantGetWeight returns weight of given product variant
	ProductVariantGetWeight(productVariantID string) (*measurement.Weight, *model_helper.AppError)
	// ProductVariantIsDigital finds product type that related to given product variant and check if that product type is digital and does not require shipping
	ProductVariantIsDigital(productVariantID string) (bool, *model_helper.AppError)
	// ProductVariantTranslationsByOption returns a list of product variant translations
	ProductVariantTranslationsByOption(option model_helper.ProductVariantTranslationFilterOption) ([]*model.ProductVariantTranslation, *model_helper.AppError)
	// ProductVariantsAvailableInChannel returns product variants based on given channel slug
	ProductVariantsAvailableInChannel(channelSlug string) ([]*model.ProductVariant, *model_helper.AppError)
	// ProductVariantsByOption returns a list of product variants satisfy given option
	ProductVariantsByOption(option *model.ProductVariantFilterOption) (model.ProductVariantSlice, *model_helper.AppError)
	// ProductsByOption returns a list of products that satisfy given option
	ProductsByOption(option *model.ProductFilterOption) (model.ProductSlice, *model_helper.AppError)
	// ProductsByVoucherID finds all products that have relationships with given voucher
	ProductsByVoucherID(voucherID string) ([]*model.Product, *model_helper.AppError)
	// ProductsRequireShipping checks if at least 1 product require shipping, then return true, false otherwise
	ProductsRequireShipping(productIDs []string) (bool, *model_helper.AppError)
	// PublishedCollections returns all published collections
	PublishedCollections(channelSlug string) ([]*model.Collection, *model_helper.AppError)
	// UpdateProductDiscountedPrice
	//
	// NOTE: `discounts` can be nil
	UpdateProductDiscountedPrice(transaction boil.ContextTransactor, product model.Product, discounts []*model_helper.DiscountInfo) *model_helper.AppError
	// UpdateProductsDiscountedPrices
	UpdateProductsDiscountedPrices(transaction boil.ContextTransactor, products []*model.Product, discounts []*model_helper.DiscountInfo) *model_helper.AppError
	// UpdateProductsDiscountedPricesOfDiscount
	//
	// NOTE: discount must be either *Sale or *Voucher
	UpdateProductsDiscountedPricesOfDiscount(transaction boil.ContextTransactor, discount any) *model_helper.AppError
	// UpsertCategory first checks if given category need a Level number.
	// Performs upsert given category into database.
	// asynchronously does category anayltic to update category cache.
	UpsertCategory(cate *model.Category) (*model.Category, *model_helper.AppError)
	// UpsertDigitalContentURL create a digital content url then returns it
	UpsertDigitalContentURL(contentURL *model.DigitalContentUrl) (*model.DigitalContentUrl, *model_helper.AppError)
	// UpsertProductVariant tells store to upsert given product variant and returns it
	UpsertProductVariant(transaction boil.ContextTransactor, variant *model.ProductVariant) (*model.ProductVariant, *model_helper.AppError)
	CategoryByIds(ids []string, allowFromCache bool) (model.CategorySlice, *model_helper.AppError)
	CollectionChannelListingsByOptions(options *model.CollectionChannelListingFilterOptions) ([]*model.CollectionChannelListing, *model_helper.AppError)
	CreateCollectionProductRelations(transaction boil.ContextTransactor, relations []*model.CollectionProduct) ([]*model.CollectionProduct, *model_helper.AppError)
	DeleteProductMedias(tx *gorm.DB, ids []string) (int64, *model_helper.AppError)
	DeleteProductTypes(tx *gorm.DB, ids []string) (int64, *model_helper.AppError)
	DeleteProductVariants(variantIds []string, requesterID string) (int64, *model_helper.AppError)
	DigitalContentURLSByOptions(options *model.DigitalContentUrlFilterOptions) ([]*model.DigitalContentUrl, *model_helper.AppError)
	DigitalContentsbyOptions(option *model.DigitalContentFilterOption) (int64, []*model.DigitalContent, *model_helper.AppError)
	FilterCategoriesFromCache(filter func(c *model.Category) bool) model.CategorySlice
	FilterProductsAdvanced(options *model.ExportProductsFilterOptions, channelIdOrSlug string) (model.ProductSlice, *model_helper.AppError)
	GetDefaultDigitalContentSettings(aShop model.ShopSettings) *model.ShopDefaultDigitalContentSettings
	GetProductAvailability(product model.Product, productChannelListing *model.ProductChannelListing, variants []*model.ProductVariant, variantsChannelListing model.ProductVariantChannelListingSlice, collections []*model.Collection, discounts []*model_helper.DiscountInfo, chanNel model.Channel, manager interfaces.PluginManagerInterface, countryCode model.CountryCode, localCurrency string) (*model.ProductAvailability, *model_helper.AppError)
	GetProductPriceRange(product model.Product, variants model.ProductVariantSlice, variantsChannelListing model.ProductVariantChannelListingSlice, collections []*model.Collection, discounts []*model_helper.DiscountInfo, chanNel model.Channel) (*goprices.MoneyRange, *model_helper.AppError)
	GetVariantAvailability(variant model.ProductVariant, variantChannelListing model.ProductVariantChannelListing, product model.Product, productChannelListing *model.ProductChannelListing, collections []*model.Collection, discounts []*model_helper.DiscountInfo, chanNel model.Channel, plugins interfaces.PluginManagerInterface, country model.CountryCode, localCurrency string) (*model.VariantAvailability, *model_helper.AppError)
	GetVisibleToUserProducts(channelIdOrSlug string, userIsShopStaff bool) (model.ProductSlice, *model_helper.AppError)
	IncrementDownloadCount(contentURL model.DigitalContentUrl) (*model.DigitalContentUrl, *model_helper.AppError)
	ProductTypesByCheckoutToken(checkoutToken string) ([]*model.ProductType, *model_helper.AppError)
	ProductTypesByOptions(options *model.ProductTypeFilterOption) (int64, []*model.ProductType, *model_helper.AppError)
	SetDefaultProductVariantForProduct(productID, variantID string) (*model.Product, *model_helper.AppError)
	ToggleProductTypeAttributeRelations(tx *gorm.DB, productTypeID string, variantAttributes, productAttributes model.Attributes, isDelete bool) *model_helper.AppError
	ToggleVariantRelations(variants model.ProductVariantSlice, medias model.ProductMedias, sales model.Sales, vouchers model.Vouchers, wishlistItems model.WishlistItems, isDelete bool) *model_helper.AppError
	UpdateOrCreateProductVariantChannelListings(variantID string, inputList []model.ProductVariantChannelListingAddInput) *model_helper.AppError
	UpdateProductsDiscountedPricesOfCatalogues(transaction boil.ContextTransactor, productIDs, categoryIDs, collectionIDs, variantIDs []string) *model_helper.AppError
	UpsertDigitalContent(digitalContent *model.DigitalContent) (*model.DigitalContent, *model_helper.AppError)
	UpsertProduct(tx *gorm.DB, product *model.Product) (*model.Product, *model_helper.AppError)
	UpsertProductMedias(tx *gorm.DB, medias model.ProductMedias) (model.ProductMedias, *model_helper.AppError)
	UpsertProductType(tx *gorm.DB, productType *model.ProductType) (*model.ProductType, *model_helper.AppError)
	ValidateVariantsAvailableForPurchase(variantIds []string, channelID string) *model_helper.AppError
	ValidateVariantsAvailableInChannel(variantIds []string, channelId string) *model_helper.AppError
	VisibleCollectionsToUser(channelSlug string, userIsShopStaff bool) ([]*model.Collection, *model_helper.AppError)
}
