// Code generated by "make app-layers"
// DO NOT EDIT

package sub_app_iface

import (
	"github.com/site-name/decimal"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/app/plugin/interfaces"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/store/store_iface"
)

// PaymentService contains methods for working with payments
type PaymentService interface {
	// @requireActivePayment
	//
	// @withLockedPayment
	//
	// @raisePaymentError
	//
	// @paymentPostProcess
	// Confirm confirms payment
	Confirm(payMent model.Payment, manager interfaces.PluginManagerInterface, channelID string, additionalData map[string]interface{}) (*model.PaymentTransaction, *model.PaymentError, *model.AppError)
	// @requireActivePayment
	//
	// @withLockedPayment
	//
	// @raisePaymentError
	//
	// @paymentPostProcess
	Authorize(payMent model.Payment, token string, manager interfaces.PluginManagerInterface, channelID string, customerID *string, storeSource bool) (*model.PaymentTransaction, *model.PaymentError, *model.AppError)
	// @requireActivePayment
	//
	// @withLockedPayment
	//
	// @raisePaymentError
	//
	// @paymentPostProcess
	Capture(payMent model.Payment, manager interfaces.PluginManagerInterface, channelID string, amount *decimal.Decimal, customerID *string, storeSource bool) (*model.PaymentTransaction, *model.PaymentError, *model.AppError)
	// @requireActivePayment
	//
	// @withLockedPayment
	//
	// @raisePaymentError
	//
	// @paymentPostProcess
	ProcessPayment(payMent model.Payment, token string, manager interfaces.PluginManagerInterface, channelID string, customerID *string, storeSource bool, additionalData map[string]interface{}) (*model.PaymentTransaction, *model.PaymentError, *model.AppError)
	// @requireActivePayment
	//
	// @withLockedPayment
	//
	// @raisePaymentError
	//
	// @paymentPostProcess
	Refund(payMent model.Payment, manager interfaces.PluginManagerInterface, channelID string, amount *decimal.Decimal) (*model.PaymentTransaction, *model.PaymentError, *model.AppError)
	// @requireActivePayment
	//
	// @withLockedPayment
	//
	// @raisePaymentError
	//
	// @paymentPostProcess
	Void(payMent model.Payment, manager interfaces.PluginManagerInterface, channelID string) (*model.PaymentTransaction, *model.PaymentError, *model.AppError)
	// CleanAuthorize Check if payment can be authorized
	CleanAuthorize(payMent *model.Payment) *model.PaymentError
	// CleanCapture Check if payment can be captured.
	CleanCapture(pm *model.Payment, amount decimal.Decimal) *model.PaymentError
	// CreatePayment Create a payment instance.
	//
	// This method is responsible for creating payment instances that works for
	// both Django views and GraphQL mutations.
	//
	// NOTE: `customerIpAddress`, `paymentToken`, `returnUrl` and `externalReference` can be empty
	//
	// `extraData`, `ckout`, `ord` can be nil
	//
	// `storePaymentMethod` default to model.StorePaymentMethod.NONE
	CreatePayment(transaction store_iface.SqlxTxExecutor, gateway string, total *decimal.Decimal, currency string, email string, customerIpAddress string, paymentToken string, extraData map[string]string, checkOut *model.Checkout, orDer *model.Order, returnUrl string, externalReference string, storePaymentMethod model.StorePaymentMethod, metadata model.StringMap) (*model.Payment, *model.PaymentError, *model.AppError)
	// CreatePaymentInformation Extract order information along with payment details.
	//
	// Returns information required to process payment and additional
	// billing/shipping addresses for optional fraud-prevention mechanisms.
	CreatePaymentInformation(payMent *model.Payment, paymentToken *string, amount *decimal.Decimal, customerId *string, storeSource bool, additionalData map[string]interface{}) (*model.PaymentData, *model.AppError)
	// CreateTransaction reate a transaction based on transaction kind and gateway response.
	CreateTransaction(paymentID string, kind model.TransactionKind, paymentInformation *model.PaymentData, actionRequired bool, gatewayResponse *model.GatewayResponse, errorMsg string, isSuccess bool) (*model.PaymentTransaction, *model.AppError)
	// FetchCustomerId Retrieve users customer_id stored for desired gateway.
	// returning string could be "" or long string
	FetchCustomerId(user *model.User, gateway string) (string, *model.AppError)
	// GatewayPostProcess
	GatewayPostProcess(paymentTransaction model.PaymentTransaction, payMent *model.Payment) *model.AppError
	// GetAllPaymentsByCheckout returns all payments that belong to given checkout
	GetAllPaymentsByCheckout(checkoutToken string) ([]*model.Payment, *model.AppError)
	// GetLastpayment compares all payments's CreatAt properties, then returns the most recent payment
	GetLastpayment(payments []*model.Payment) *model.Payment
	// GetSubTotal adds up all Total prices of given order lines
	GetSubTotal(orderLines []*model.OrderLine, fallbackCurrency string) (*goprices.TaxedMoney, *model.AppError)
	// IsCurrencySupported Return true if the given gateway supports given currency.
	IsCurrencySupported(currency string, gatewayID string, manager interfaces.PluginManagerInterface) bool
	// PaymentByID returns a payment with given id
	PaymentByID(transaction store_iface.SqlxTxExecutor, paymentID string, lockForUpdate bool) (*model.Payment, *model.AppError)
	// PaymentCanVoid checks if given payment is: Active && not charged and authorized
	PaymentCanVoid(payMent *model.Payment) (bool, *model.AppError)
	// PaymentRefundOrVoid
	PaymentRefundOrVoid(payMent *model.Payment, manager interfaces.PluginManagerInterface, channelSlug string) (*model.PaymentError, *model.AppError)
	// PaymentsByOption returns all payments that satisfy given option
	PaymentsByOption(option *model.PaymentFilterOption) ([]*model.Payment, *model.AppError)
	// StoreCustomerId stores new value into given user's PrivateMetadata
	StoreCustomerId(userID string, gateway string, customerID string) *model.AppError
	// TransactionsByOption returns a list of transactions filtered based on given option
	TransactionsByOption(option *model.PaymentTransactionFilterOpts) ([]*model.PaymentTransaction, *model.AppError)
	// UpdatePayment
	UpdatePayment(payMent model.Payment, gatewayResponse *model.GatewayResponse) *model.AppError
	// UpdatePaymentsOfCheckout updates payments of given checkout, with parameters specified in option
	UpdatePaymentsOfCheckout(transaction store_iface.SqlxTxExecutor, checkoutToken string, option *model.PaymentPatch) *model.AppError
	// UpsertPayment updates or insert given payment, depends on the validity of its Id
	UpsertPayment(transaction store_iface.SqlxTxExecutor, payMent *model.Payment) (*model.Payment, *model.AppError)
	// ValidateGatewayResponse Validate response to be a correct format for Saleor to process.
	ValidateGatewayResponse(response *model.GatewayResponse) *model.GatewayError
	GetAllPaymentTransactions(paymentID string) ([]*model.PaymentTransaction, *model.AppError)
	GetAlreadyProcessedTransaction(paymentID string, gatewayResponse *model.GatewayResponse) (*model.PaymentTransaction, *model.AppError)
	GetAlreadyProcessedTransactionOrCreateNewTransaction(paymentID string, kind model.TransactionKind, paymentInformation *model.PaymentData, actionRequired bool, gatewayResponse *model.GatewayResponse, errorMsg string) (*model.PaymentTransaction, *model.AppError)
	GetLastOrderPayment(orderID string) (*model.Payment, *model.AppError)
	GetLastPaymentTransaction(paymentID string) (*model.PaymentTransaction, *model.AppError)
	GetPaymentToken(payMent *model.Payment) (string, *model.PaymentError, *model.AppError)
	GetTotalAuthorized(payments []*model.Payment, fallbackCurrency string) (*goprices.Money, *model.AppError)
	ListGateways(manager interfaces.PluginManagerInterface, channelID string) []*model.PaymentGateway
	ListPaymentSources(gateway string, customerID string, manager interfaces.PluginManagerInterface, channelID string) ([]*model.CustomerSource, *model.AppError)
	PaymentGetAuthorizedAmount(pm *model.Payment) (*goprices.Money, *model.AppError)
	PaymentIsAuthorized(paymentID string) (bool, *model.AppError)
	SaveTransaction(transaction store_iface.SqlxTxExecutor, paymentTransaction *model.PaymentTransaction) (*model.PaymentTransaction, *model.AppError)
	UpdatePaymentMethodDetails(payMent model.Payment, paymentMethodInfo *model.PaymentMethodInfo) (changed bool)
	UpdateTransaction(transaction *model.PaymentTransaction) (*model.PaymentTransaction, *model.AppError)
}
