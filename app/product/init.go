package product

import (
	"net/http"
	"time"

	"github.com/Masterminds/squirrel"
	goprices "github.com/site-name/go-prices"
	"github.com/sitename/sitename/app"
	"github.com/sitename/sitename/app/plugin/interfaces"
	"github.com/sitename/sitename/model"
	"github.com/sitename/sitename/model/order"
	"github.com/sitename/sitename/model/product_and_discount"
	"github.com/sitename/sitename/modules/util"
	"github.com/sitename/sitename/store"
)

// CalculateRevenueForVariant Calculate total revenue generated by a product variant
//
// NOTE: `startDate` must be UTC time
func (a *ServiceProduct) CalculateRevenueForVariant(
	variant *product_and_discount.ProductVariant,
	startDate *time.Time,
	orderLines []*order.OrderLine,
	ordersDict map[string]*order.Order,
	currencyCode string,

) (*goprices.TaxedMoney, *model.AppError) {
	// validate given currencyCode is valid:
	revenue, err := util.ZeroTaxedMoney(currencyCode)
	if err != nil {
		return nil, model.NewAppError("CalculateRevenueForVariant", app.InvalidArgumentAppErrorID, map[string]interface{}{"Fields": "currencyCode"}, err.Error(), http.StatusBadRequest)
	}

	for _, orderLine := range orderLines {
		orderLine.PopulateNonDbFields() // call this to populate money fields

		orderValue := ordersDict[orderLine.OrderID]
		if orderValue != nil && orderValue.CreateAt >= util.MillisFromTime(*startDate) {
			addedRevenue, err := revenue.Add(orderLine.TotalPrice)
			if err != nil {
				return nil, model.NewAppError("CalculateRevenueForVariant", app.ErrorCalculatingMoneyErrorID, nil, err.Error(), http.StatusInternalServerError)
			}
			revenue = addedRevenue
		}
	}

	return revenue, nil
}

// DeleteCategories Delete categories and perform all necessary actions.
//
// Set products of deleted categories as unpublished, delete categories
// and update products minimal variant prices.
func (a *ServiceProduct) DeleteCategories(categoryIDs []string, manager interfaces.PluginManagerInterface) *model.AppError {
	panic("not implemented")
}

// CollectCategoriesTreeProducts Collect products from all levels in category tree.
func (a *ServiceProduct) CollectCategoriesTreeProducts(category *product_and_discount.Category) ([]*product_and_discount.Product, *model.AppError) {
	panic("not implemented")
}

// GetProductsIDsWithoutVariants Return list of product's ids without variants
func (a *ServiceProduct) GetProductsIDsWithoutVariants(productList []*product_and_discount.Product) ([]string, *model.AppError) {
	productIDs := product_and_discount.Products(productList).IDs()

	productsWithNoVariant, appErr := a.ProductsByOption(&product_and_discount.ProductFilterOption{
		Id:               squirrel.Eq{store.ProductTableName + ".Id": productIDs},
		ProductVariantID: squirrel.Eq{store.ProductVariantTableName + ".Id": nil},
	})
	if appErr != nil {
		return nil, appErr
	}

	return product_and_discount.Products(productsWithNoVariant).IDs(), nil
}
